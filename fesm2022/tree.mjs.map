{"version":3,"file":"tree.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/tree/control/base-tree-control.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/tree/control/flat-tree-control.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/tree/control/nested-tree-control.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/tree/outlet.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/tree/node.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/tree/tree-errors.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/tree/tree.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/tree/nested-node.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/tree/padding.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/tree/toggle.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/tree/tree-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {SelectionModel} from '../../collections';\nimport {Observable} from 'rxjs';\nimport {TreeControl} from './tree-control';\n\n/**\n * Base tree control. It has basic toggle/expand/collapse operations on a single data node.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor. To be removed in a future version.\n * @breaking-change 21.0.0\n */\nexport abstract class BaseTreeControl<T, K = T> implements TreeControl<T, K> {\n  /** Gets a list of descendent data nodes of a subtree rooted at given data node recursively. */\n  abstract getDescendants(dataNode: T): T[];\n\n  /** Expands all data nodes in the tree. */\n  abstract expandAll(): void;\n\n  /** Saved data node for `expandAll` action. */\n  dataNodes: T[];\n\n  /** A selection model with multi-selection to track expansion status. */\n  expansionModel: SelectionModel<K> = new SelectionModel<K>(true);\n\n  /**\n   * Returns the identifier by which a dataNode should be tracked, should its\n   * reference change.\n   *\n   * Similar to trackBy for *ngFor\n   */\n  trackBy?: (dataNode: T) => K;\n\n  /** Get depth of a given data node, return the level number. This is for flat tree node. */\n  getLevel: (dataNode: T) => number;\n\n  /**\n   * Whether the data node is expandable. Returns true if expandable.\n   * This is for flat tree node.\n   */\n  isExpandable: (dataNode: T) => boolean;\n\n  /** Gets a stream that emits whenever the given data node's children change. */\n  getChildren: (dataNode: T) => Observable<T[]> | T[] | undefined | null;\n\n  /** Toggles one single data node's expanded/collapsed state. */\n  toggle(dataNode: T): void {\n    this.expansionModel.toggle(this._trackByValue(dataNode));\n  }\n\n  /** Expands one single data node. */\n  expand(dataNode: T): void {\n    this.expansionModel.select(this._trackByValue(dataNode));\n  }\n\n  /** Collapses one single data node. */\n  collapse(dataNode: T): void {\n    this.expansionModel.deselect(this._trackByValue(dataNode));\n  }\n\n  /** Whether a given data node is expanded or not. Returns true if the data node is expanded. */\n  isExpanded(dataNode: T): boolean {\n    return this.expansionModel.isSelected(this._trackByValue(dataNode));\n  }\n\n  /** Toggles a subtree rooted at `node` recursively. */\n  toggleDescendants(dataNode: T): void {\n    this.expansionModel.isSelected(this._trackByValue(dataNode))\n      ? this.collapseDescendants(dataNode)\n      : this.expandDescendants(dataNode);\n  }\n\n  /** Collapse all dataNodes in the tree. */\n  collapseAll(): void {\n    this.expansionModel.clear();\n  }\n\n  /** Expands a subtree rooted at given data node recursively. */\n  expandDescendants(dataNode: T): void {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.select(...toBeProcessed.map(value => this._trackByValue(value)));\n  }\n\n  /** Collapses a subtree rooted at given data node recursively. */\n  collapseDescendants(dataNode: T): void {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.deselect(...toBeProcessed.map(value => this._trackByValue(value)));\n  }\n\n  protected _trackByValue(value: T | K): K {\n    return this.trackBy ? this.trackBy(value as T) : (value as K);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {BaseTreeControl} from './base-tree-control';\n\n/** Optional set of configuration that can be provided to the FlatTreeControl. */\nexport interface FlatTreeControlOptions<T, K> {\n  trackBy?: (dataNode: T) => K;\n}\n\n/**\n * Flat tree control. Able to expand/collapse a subtree recursively for flattened tree.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor instead. To be removed in a future\n * version.\n * @breaking-change 21.0.0\n */\nexport class FlatTreeControl<T, K = T> extends BaseTreeControl<T, K> {\n  /** Construct with flat tree data node functions getLevel and isExpandable. */\n  constructor(\n    public override getLevel: (dataNode: T) => number,\n    public override isExpandable: (dataNode: T) => boolean,\n    public options?: FlatTreeControlOptions<T, K>,\n  ) {\n    super();\n\n    if (this.options) {\n      this.trackBy = this.options.trackBy;\n    }\n  }\n\n  /**\n   * Gets a list of the data node's subtree of descendent data nodes.\n   *\n   * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes\n   * with correct levels.\n   */\n  getDescendants(dataNode: T): T[] {\n    const startIndex = this.dataNodes.indexOf(dataNode);\n    const results: T[] = [];\n\n    // Goes through flattened tree nodes in the `dataNodes` array, and get all descendants.\n    // The level of descendants of a tree node must be greater than the level of the given\n    // tree node.\n    // If we reach a node whose level is equal to the level of the tree node, we hit a sibling.\n    // If we reach a node whose level is greater than the level of the tree node, we hit a\n    // sibling of an ancestor.\n    for (\n      let i = startIndex + 1;\n      i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]);\n      i++\n    ) {\n      results.push(this.dataNodes[i]);\n    }\n    return results;\n  }\n\n  /**\n   * Expands all data nodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened\n   * data nodes of the tree.\n   */\n  expandAll(): void {\n    this.expansionModel.select(...this.dataNodes.map(node => this._trackByValue(node)));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {Observable, isObservable} from 'rxjs';\nimport {take, filter} from 'rxjs/operators';\nimport {BaseTreeControl} from './base-tree-control';\n\n/** Optional set of configuration that can be provided to the NestedTreeControl. */\nexport interface NestedTreeControlOptions<T, K> {\n  /** Function to determine if the provided node is expandable. */\n  isExpandable?: (dataNode: T) => boolean;\n  trackBy?: (dataNode: T) => K;\n}\n\n/**\n * Nested tree control. Able to expand/collapse a subtree recursively for NestedNode type.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor instead. To be removed in a future\n * version.\n * @breaking-change 21.0.0\n */\nexport class NestedTreeControl<T, K = T> extends BaseTreeControl<T, K> {\n  /** Construct with nested tree function getChildren. */\n  constructor(\n    public override getChildren: (dataNode: T) => Observable<T[]> | T[] | undefined | null,\n    public options?: NestedTreeControlOptions<T, K>,\n  ) {\n    super();\n\n    if (this.options) {\n      this.trackBy = this.options.trackBy;\n    }\n\n    if (this.options?.isExpandable) {\n      this.isExpandable = this.options.isExpandable;\n    }\n  }\n\n  /**\n   * Expands all dataNodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level\n   * data nodes of the tree.\n   */\n  expandAll(): void {\n    this.expansionModel.clear();\n    const allNodes = this.dataNodes.reduce(\n      (accumulator: T[], dataNode) => [...accumulator, ...this.getDescendants(dataNode), dataNode],\n      [],\n    );\n    this.expansionModel.select(...allNodes.map(node => this._trackByValue(node)));\n  }\n\n  /** Gets a list of descendant dataNodes of a subtree rooted at given data node recursively. */\n  getDescendants(dataNode: T): T[] {\n    const descendants: T[] = [];\n\n    this._getDescendants(descendants, dataNode);\n    // Remove the node itself\n    return descendants.splice(1);\n  }\n\n  /** A helper function to get descendants recursively. */\n  protected _getDescendants(descendants: T[], dataNode: T): void {\n    descendants.push(dataNode);\n    const childrenNodes = this.getChildren(dataNode);\n    if (Array.isArray(childrenNodes)) {\n      childrenNodes.forEach((child: T) => this._getDescendants(descendants, child));\n    } else if (isObservable(childrenNodes)) {\n      // TypeScript as of version 3.5 doesn't seem to treat `Boolean` like a function that\n      // returns a `boolean` specifically in the context of `filter`, so we manually clarify that.\n      childrenNodes.pipe(take(1), filter(Boolean as () => boolean)).subscribe(children => {\n        for (const child of children) {\n          this._getDescendants(descendants, child);\n        }\n      });\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {Directive, InjectionToken, ViewContainerRef, inject} from '@angular/core';\n\n/**\n * Injection token used to provide a `CdkTreeNode` to its outlet.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nexport const CDK_TREE_NODE_OUTLET_NODE = new InjectionToken<{}>('CDK_TREE_NODE_OUTLET_NODE');\n\n/**\n * Outlet for nested CdkNode. Put `[cdkTreeNodeOutlet]` on a tag to place children dataNodes\n * inside the outlet.\n */\n@Directive({\n  selector: '[cdkTreeNodeOutlet]',\n})\nexport class CdkTreeNodeOutlet {\n  viewContainer = inject(ViewContainerRef);\n  _node? = inject(CDK_TREE_NODE_OUTLET_NODE, {optional: true});\n\n  constructor(...args: unknown[]);\n  constructor() {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, TemplateRef, inject} from '@angular/core';\n\n/** Context provided to the tree node component. */\nexport class CdkTreeNodeOutletContext<T> {\n  /** Data for the node. */\n  $implicit: T;\n\n  /** Depth of the node. */\n  level: number;\n\n  /** Index location of the node. */\n  index?: number;\n\n  /** Length of the number of total dataNodes. */\n  count?: number;\n\n  constructor(data: T) {\n    this.$implicit = data;\n  }\n}\n\n/**\n * Data node definition for the CdkTree.\n * Captures the node's template and a when predicate that describes when this node should be used.\n */\n@Directive({\n  selector: '[cdkTreeNodeDef]',\n  inputs: [{name: 'when', alias: 'cdkTreeNodeDefWhen'}],\n})\nexport class CdkTreeNodeDef<T> {\n  /** @docs-private */\n  template = inject<TemplateRef<any>>(TemplateRef);\n\n  /**\n   * Function that should return true if this node template should be used for the provided node\n   * data and index. If left undefined, this node will be considered the default node template to\n   * use when no other when functions return true for the data.\n   * For every node, there must be at least one when function that passes or an undefined to\n   * default.\n   */\n  when: (index: number, nodeData: T) => boolean;\n\n  constructor(...args: unknown[]);\n  constructor() {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * Returns an error to be thrown when there is no usable data.\n * @docs-private\n */\nexport function getTreeNoValidDataSourceError() {\n  return Error(`A valid data source must be provided.`);\n}\n\n/**\n * Returns an error to be thrown when there are multiple nodes that are missing a when function.\n * @docs-private\n */\nexport function getTreeMultipleDefaultNodeDefsError() {\n  return Error(`There can only be one default row without a when predicate function.`);\n}\n\n/**\n * Returns an error to be thrown when there are no matching node defs for a particular set of data.\n * @docs-private\n */\nexport function getTreeMissingMatchingNodeDefError() {\n  return Error(`Could not find a matching node definition for the provided node data.`);\n}\n\n/**\n * Returns an error to be thrown when there is no tree control.\n * @docs-private\n */\nexport function getTreeControlMissingError() {\n  return Error(`Could not find a tree control, levelAccessor, or childrenAccessor for the tree.`);\n}\n\n/**\n * Returns an error to be thrown when there are multiple ways of specifying children or level\n * provided to the tree.\n * @docs-private\n */\nexport function getMultipleTreeControlsError() {\n  return Error(`More than one of tree control, levelAccessor, or childrenAccessor were provided.`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {\n  TREE_KEY_MANAGER,\n  TreeKeyManagerFactory,\n  TreeKeyManagerItem,\n  TreeKeyManagerOptions,\n  TreeKeyManagerStrategy,\n} from '../a11y';\nimport {Directionality} from '../bidi';\nimport {\n  CollectionViewer,\n  DataSource,\n  isDataSource,\n  SelectionChange,\n  SelectionModel,\n} from '../collections';\nimport {\n  AfterContentChecked,\n  AfterContentInit,\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  EmbeddedViewRef,\n  Input,\n  IterableChangeRecord,\n  IterableDiffer,\n  IterableDiffers,\n  OnDestroy,\n  OnInit,\n  Output,\n  QueryList,\n  TrackByFunction,\n  ViewChild,\n  ViewContainerRef,\n  ViewEncapsulation,\n  numberAttribute,\n  inject,\n  booleanAttribute,\n} from '@angular/core';\nimport {coerceObservable} from '../coercion/private';\nimport {\n  BehaviorSubject,\n  combineLatest,\n  concat,\n  EMPTY,\n  Observable,\n  Subject,\n  Subscription,\n  isObservable,\n  of as observableOf,\n} from 'rxjs';\nimport {\n  distinctUntilChanged,\n  concatMap,\n  map,\n  reduce,\n  startWith,\n  switchMap,\n  take,\n  takeUntil,\n  tap,\n} from 'rxjs/operators';\nimport {TreeControl} from './control/tree-control';\nimport {CdkTreeNodeDef, CdkTreeNodeOutletContext} from './node';\nimport {CdkTreeNodeOutlet} from './outlet';\nimport {\n  getMultipleTreeControlsError,\n  getTreeControlMissingError,\n  getTreeMissingMatchingNodeDefError,\n  getTreeMultipleDefaultNodeDefsError,\n  getTreeNoValidDataSourceError,\n} from './tree-errors';\n\ntype RenderingData<T> =\n  | {\n      flattenedNodes: null;\n      nodeType: null;\n      renderNodes: readonly T[];\n    }\n  | {\n      flattenedNodes: readonly T[];\n      nodeType: 'nested' | 'flat';\n      renderNodes: readonly T[];\n    };\n\n/**\n * CDK tree component that connects with a data source to retrieve data of type `T` and renders\n * dataNodes with hierarchy. Updates the dataNodes when new data is provided by the data source.\n */\n@Component({\n  selector: 'cdk-tree',\n  exportAs: 'cdkTree',\n  template: `<ng-container cdkTreeNodeOutlet></ng-container>`,\n  host: {\n    'class': 'cdk-tree',\n    'role': 'tree',\n    '(keydown)': '_sendKeydownToKeyManager($event)',\n  },\n  encapsulation: ViewEncapsulation.None,\n  // The \"OnPush\" status for the `CdkTree` component is effectively a noop, so we are removing it.\n  // The view for `CdkTree` consists entirely of templates declared in other views. As they are\n  // declared elsewhere, they are checked when their declaration points are checked.\n  // tslint:disable-next-line:validate-decorators\n  changeDetection: ChangeDetectionStrategy.Default,\n  imports: [CdkTreeNodeOutlet],\n})\nexport class CdkTree<T, K = T>\n  implements\n    AfterContentChecked,\n    AfterContentInit,\n    AfterViewInit,\n    CollectionViewer,\n    OnDestroy,\n    OnInit\n{\n  private _differs = inject(IterableDiffers);\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n  private _elementRef = inject(ElementRef);\n\n  private _dir = inject(Directionality);\n\n  /** Subject that emits when the component has been destroyed. */\n  private readonly _onDestroy = new Subject<void>();\n\n  /** Differ used to find the changes in the data provided by the data source. */\n  private _dataDiffer: IterableDiffer<T>;\n\n  /** Stores the node definition that does not have a when predicate. */\n  private _defaultNodeDef: CdkTreeNodeDef<T> | null;\n\n  /** Data subscription */\n  private _dataSubscription: Subscription | null;\n\n  /** Level of nodes */\n  private _levels: Map<K, number> = new Map<K, number>();\n\n  /** The immediate parents for a node. This is `null` if there is no parent. */\n  private _parents: Map<K, T | null> = new Map<K, T | null>();\n\n  /**\n   * Nodes grouped into each set, which is a list of nodes displayed together in the DOM.\n   *\n   * Lookup key is the parent of a set. Root nodes have key of null.\n   *\n   * Values is a 'set' of tree nodes. Each tree node maps to a treeitem element. Sets are in the\n   * order that it is rendered. Each set maps directly to aria-posinset and aria-setsize attributes.\n   */\n  private _ariaSets: Map<K | null, T[]> = new Map<K | null, T[]>();\n\n  /**\n   * Provides a stream containing the latest data array to render. Influenced by the tree's\n   * stream of view window (what dataNodes are currently on screen).\n   * Data source can be an observable of data array, or a data array to render.\n   */\n  @Input()\n  get dataSource(): DataSource<T> | Observable<T[]> | T[] {\n    return this._dataSource;\n  }\n  set dataSource(dataSource: DataSource<T> | Observable<T[]> | T[]) {\n    if (this._dataSource !== dataSource) {\n      this._switchDataSource(dataSource);\n    }\n  }\n  private _dataSource: DataSource<T> | Observable<T[]> | T[];\n\n  /**\n   * The tree controller\n   *\n   * @deprecated Use one of `levelAccessor` or `childrenAccessor` instead. To be removed in a\n   * future version.\n   * @breaking-change 21.0.0\n   */\n  @Input() treeControl?: TreeControl<T, K>;\n\n  /**\n   * Given a data node, determines what tree level the node is at.\n   *\n   * One of levelAccessor or childrenAccessor must be specified, not both.\n   * This is enforced at run-time.\n   */\n  @Input() levelAccessor?: (dataNode: T) => number;\n\n  /**\n   * Given a data node, determines what the children of that node are.\n   *\n   * One of levelAccessor or childrenAccessor must be specified, not both.\n   * This is enforced at run-time.\n   */\n  @Input() childrenAccessor?: (dataNode: T) => T[] | Observable<T[]>;\n\n  /**\n   * Tracking function that will be used to check the differences in data changes. Used similarly\n   * to `ngFor` `trackBy` function. Optimize node operations by identifying a node based on its data\n   * relative to the function to know if a node should be added/removed/moved.\n   * Accepts a function that takes two parameters, `index` and `item`.\n   */\n  @Input() trackBy: TrackByFunction<T>;\n\n  /**\n   * Given a data node, determines the key by which we determine whether or not this node is expanded.\n   */\n  @Input() expansionKey?: (dataNode: T) => K;\n\n  // Outlets within the tree's template where the dataNodes will be inserted.\n  @ViewChild(CdkTreeNodeOutlet, {static: true}) _nodeOutlet: CdkTreeNodeOutlet;\n\n  /** The tree node template for the tree */\n  @ContentChildren(CdkTreeNodeDef, {\n    // We need to use `descendants: true`, because Ivy will no longer match\n    // indirect descendants if it's left as false.\n    descendants: true,\n  })\n  _nodeDefs: QueryList<CdkTreeNodeDef<T>>;\n\n  // TODO(tinayuangao): Setup a listener for scrolling, emit the calculated view to viewChange.\n  //     Remove the MAX_VALUE in viewChange\n  /**\n   * Stream containing the latest information on what rows are being displayed on screen.\n   * Can be used by the data source to as a heuristic of what data should be provided.\n   */\n  readonly viewChange = new BehaviorSubject<{start: number; end: number}>({\n    start: 0,\n    end: Number.MAX_VALUE,\n  });\n\n  /** Keep track of which nodes are expanded. */\n  private _expansionModel?: SelectionModel<K>;\n\n  /**\n   * Maintain a synchronous cache of flattened data nodes. This will only be\n   * populated after initial render, and in certain cases, will be delayed due to\n   * relying on Observable `getChildren` calls.\n   */\n  private _flattenedNodes: BehaviorSubject<readonly T[]> = new BehaviorSubject<readonly T[]>([]);\n\n  /** The automatically determined node type for the tree. */\n  private _nodeType: BehaviorSubject<'flat' | 'nested' | null> = new BehaviorSubject<\n    'flat' | 'nested' | null\n  >(null);\n\n  /** The mapping between data and the node that is rendered. */\n  private _nodes: BehaviorSubject<Map<K, CdkTreeNode<T, K>>> = new BehaviorSubject(\n    new Map<K, CdkTreeNode<T, K>>(),\n  );\n\n  /**\n   * Synchronous cache of nodes for the `TreeKeyManager`. This is separate\n   * from `_flattenedNodes` so they can be independently updated at different\n   * times.\n   */\n  private _keyManagerNodes: BehaviorSubject<readonly T[]> = new BehaviorSubject<readonly T[]>([]);\n\n  private _keyManagerFactory = inject(TREE_KEY_MANAGER) as TreeKeyManagerFactory<CdkTreeNode<T, K>>;\n\n  /** The key manager for this tree. Handles focus and activation based on user keyboard input. */\n  _keyManager: TreeKeyManagerStrategy<CdkTreeNode<T, K>>;\n  private _viewInit = false;\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  ngAfterContentInit() {\n    this._initializeKeyManager();\n  }\n\n  ngAfterContentChecked() {\n    this._updateDefaultNodeDefinition();\n    this._subscribeToDataChanges();\n  }\n\n  ngOnDestroy() {\n    this._nodeOutlet.viewContainer.clear();\n\n    this._nodes.complete();\n    this._keyManagerNodes.complete();\n    this._nodeType.complete();\n    this._flattenedNodes.complete();\n    this.viewChange.complete();\n    this._onDestroy.next();\n    this._onDestroy.complete();\n\n    if (this._dataSource && typeof (this._dataSource as DataSource<T>).disconnect === 'function') {\n      (this.dataSource as DataSource<T>).disconnect(this);\n    }\n\n    if (this._dataSubscription) {\n      this._dataSubscription.unsubscribe();\n      this._dataSubscription = null;\n    }\n\n    // In certain tests, the tree might be destroyed before this is initialized\n    // in `ngAfterContentInit`.\n    this._keyManager?.destroy();\n  }\n\n  ngOnInit() {\n    this._checkTreeControlUsage();\n    this._initializeDataDiffer();\n  }\n\n  ngAfterViewInit() {\n    this._viewInit = true;\n  }\n\n  private _updateDefaultNodeDefinition() {\n    const defaultNodeDefs = this._nodeDefs.filter(def => !def.when);\n    if (defaultNodeDefs.length > 1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getTreeMultipleDefaultNodeDefsError();\n    }\n    this._defaultNodeDef = defaultNodeDefs[0];\n  }\n\n  /**\n   * Sets the node type for the tree, if it hasn't been set yet.\n   *\n   * This will be called by the first node that's rendered in order for the tree\n   * to determine what data transformations are required.\n   */\n  _setNodeTypeIfUnset(newType: 'flat' | 'nested') {\n    const currentType = this._nodeType.value;\n\n    if (currentType === null) {\n      this._nodeType.next(newType);\n    } else if ((typeof ngDevMode === 'undefined' || ngDevMode) && currentType !== newType) {\n      console.warn(\n        `Tree is using conflicting node types which can cause unexpected behavior. ` +\n          `Please use tree nodes of the same type (e.g. only flat or only nested). ` +\n          `Current node type: \"${currentType}\", new node type \"${newType}\".`,\n      );\n    }\n  }\n\n  /**\n   * Switch to the provided data source by resetting the data and unsubscribing from the current\n   * render change subscription if one exists. If the data source is null, interpret this by\n   * clearing the node outlet. Otherwise start listening for new data.\n   */\n  private _switchDataSource(dataSource: DataSource<T> | Observable<T[]> | T[]) {\n    if (this._dataSource && typeof (this._dataSource as DataSource<T>).disconnect === 'function') {\n      (this.dataSource as DataSource<T>).disconnect(this);\n    }\n\n    if (this._dataSubscription) {\n      this._dataSubscription.unsubscribe();\n      this._dataSubscription = null;\n    }\n\n    // Remove the all dataNodes if there is now no data source\n    if (!dataSource) {\n      this._nodeOutlet.viewContainer.clear();\n    }\n\n    this._dataSource = dataSource;\n    if (this._nodeDefs) {\n      this._subscribeToDataChanges();\n    }\n  }\n\n  _getExpansionModel() {\n    if (!this.treeControl) {\n      this._expansionModel ??= new SelectionModel<K>(true);\n      return this._expansionModel;\n    }\n    return this.treeControl.expansionModel;\n  }\n\n  /** Set up a subscription for the data provided by the data source. */\n  private _subscribeToDataChanges() {\n    if (this._dataSubscription) {\n      return;\n    }\n\n    let dataStream: Observable<readonly T[]> | undefined;\n\n    if (isDataSource(this._dataSource)) {\n      dataStream = this._dataSource.connect(this);\n    } else if (isObservable(this._dataSource)) {\n      dataStream = this._dataSource;\n    } else if (Array.isArray(this._dataSource)) {\n      dataStream = observableOf(this._dataSource);\n    }\n\n    if (!dataStream) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        throw getTreeNoValidDataSourceError();\n      }\n      return;\n    }\n\n    this._dataSubscription = this._getRenderData(dataStream)\n      .pipe(takeUntil(this._onDestroy))\n      .subscribe(renderingData => {\n        this._renderDataChanges(renderingData);\n      });\n  }\n\n  /** Given an Observable containing a stream of the raw data, returns an Observable containing the RenderingData */\n  private _getRenderData(dataStream: Observable<readonly T[]>): Observable<RenderingData<T>> {\n    const expansionModel = this._getExpansionModel();\n    return combineLatest([\n      dataStream,\n      this._nodeType,\n      // We don't use the expansion data directly, however we add it here to essentially\n      // trigger data rendering when expansion changes occur.\n      expansionModel.changed.pipe(\n        startWith(null),\n        tap(expansionChanges => {\n          this._emitExpansionChanges(expansionChanges);\n        }),\n      ),\n    ]).pipe(\n      switchMap(([data, nodeType]) => {\n        if (nodeType === null) {\n          return observableOf({renderNodes: data, flattenedNodes: null, nodeType} as const);\n        }\n\n        // If we're here, then we know what our node type is, and therefore can\n        // perform our usual rendering pipeline, which necessitates converting the data\n        return this._computeRenderingData(data, nodeType).pipe(\n          map(convertedData => ({...convertedData, nodeType}) as const),\n        );\n      }),\n    );\n  }\n\n  private _renderDataChanges(data: RenderingData<T>) {\n    if (data.nodeType === null) {\n      this.renderNodeChanges(data.renderNodes);\n      return;\n    }\n\n    // If we're here, then we know what our node type is, and therefore can\n    // perform our usual rendering pipeline.\n    this._updateCachedData(data.flattenedNodes);\n    this.renderNodeChanges(data.renderNodes);\n    this._updateKeyManagerItems(data.flattenedNodes);\n  }\n\n  private _emitExpansionChanges(expansionChanges: SelectionChange<K> | null) {\n    if (!expansionChanges) {\n      return;\n    }\n\n    const nodes = this._nodes.value;\n    for (const added of expansionChanges.added) {\n      const node = nodes.get(added);\n      node?._emitExpansionState(true);\n    }\n    for (const removed of expansionChanges.removed) {\n      const node = nodes.get(removed);\n      node?._emitExpansionState(false);\n    }\n  }\n\n  private _initializeKeyManager() {\n    const items = combineLatest([this._keyManagerNodes, this._nodes]).pipe(\n      map(([keyManagerNodes, renderNodes]) =>\n        keyManagerNodes.reduce<CdkTreeNode<T, K>[]>((items, data) => {\n          const node = renderNodes.get(this._getExpansionKey(data));\n          if (node) {\n            items.push(node);\n          }\n          return items;\n        }, []),\n      ),\n    );\n\n    const keyManagerOptions: TreeKeyManagerOptions<CdkTreeNode<T, K>> = {\n      trackBy: node => this._getExpansionKey(node.data),\n      skipPredicate: node => !!node.isDisabled,\n      typeAheadDebounceInterval: true,\n      horizontalOrientation: this._dir.value,\n    };\n\n    this._keyManager = this._keyManagerFactory(items, keyManagerOptions);\n  }\n\n  private _initializeDataDiffer() {\n    // Provide a default trackBy based on `_getExpansionKey` if one isn't provided.\n    const trackBy = this.trackBy ?? ((_index: number, item: T) => this._getExpansionKey(item));\n    this._dataDiffer = this._differs.find([]).create(trackBy);\n  }\n\n  private _checkTreeControlUsage() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      // Verify that Tree follows API contract of using one of TreeControl, levelAccessor or\n      // childrenAccessor. Throw an appropriate error if contract is not met.\n      let numTreeControls = 0;\n\n      if (this.treeControl) {\n        numTreeControls++;\n      }\n      if (this.levelAccessor) {\n        numTreeControls++;\n      }\n      if (this.childrenAccessor) {\n        numTreeControls++;\n      }\n\n      if (!numTreeControls) {\n        throw getTreeControlMissingError();\n      } else if (numTreeControls > 1) {\n        throw getMultipleTreeControlsError();\n      }\n    }\n  }\n\n  /** Check for changes made in the data and render each change (node added/removed/moved). */\n  renderNodeChanges(\n    data: readonly T[],\n    dataDiffer: IterableDiffer<T> = this._dataDiffer,\n    viewContainer: ViewContainerRef = this._nodeOutlet.viewContainer,\n    parentData?: T,\n  ) {\n    const changes = dataDiffer.diff(data);\n\n    // Some tree consumers expect change detection to propagate to nodes\n    // even when the array itself hasn't changed; we explicitly detect changes\n    // anyways in order for nodes to update their data.\n    //\n    // However, if change detection is called while the component's view is\n    // still initing, then the order of child views initing will be incorrect;\n    // to prevent this, we only exit early if the view hasn't initialized yet.\n    if (!changes && !this._viewInit) {\n      return;\n    }\n\n    changes?.forEachOperation(\n      (\n        item: IterableChangeRecord<T>,\n        adjustedPreviousIndex: number | null,\n        currentIndex: number | null,\n      ) => {\n        if (item.previousIndex == null) {\n          this.insertNode(data[currentIndex!], currentIndex!, viewContainer, parentData);\n        } else if (currentIndex == null) {\n          viewContainer.remove(adjustedPreviousIndex!);\n        } else {\n          const view = viewContainer.get(adjustedPreviousIndex!);\n          viewContainer.move(view!, currentIndex);\n        }\n      },\n    );\n\n    // If the data itself changes, but keeps the same trackBy, we need to update the templates'\n    // context to reflect the new object.\n    changes?.forEachIdentityChange((record: IterableChangeRecord<T>) => {\n      const newData = record.item;\n      if (record.currentIndex != undefined) {\n        const view = viewContainer.get(record.currentIndex);\n        (view as EmbeddedViewRef<any>).context.$implicit = newData;\n      }\n    });\n\n    // Note: we only `detectChanges` from a top-level call, otherwise we risk overflowing\n    // the call stack since this method is called recursively (see #29733.)\n    // TODO: change to `this._changeDetectorRef.markForCheck()`,\n    // or just switch this component to use signals.\n    if (parentData) {\n      this._changeDetectorRef.markForCheck();\n    } else {\n      this._changeDetectorRef.detectChanges();\n    }\n  }\n\n  /**\n   * Finds the matching node definition that should be used for this node data. If there is only\n   * one node definition, it is returned. Otherwise, find the node definition that has a when\n   * predicate that returns true with the data. If none return true, return the default node\n   * definition.\n   */\n  _getNodeDef(data: T, i: number): CdkTreeNodeDef<T> {\n    if (this._nodeDefs.length === 1) {\n      return this._nodeDefs.first!;\n    }\n\n    const nodeDef =\n      this._nodeDefs.find(def => def.when && def.when(i, data)) || this._defaultNodeDef;\n\n    if (!nodeDef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getTreeMissingMatchingNodeDefError();\n    }\n\n    return nodeDef!;\n  }\n\n  /**\n   * Create the embedded view for the data node template and place it in the correct index location\n   * within the data node view container.\n   */\n  insertNode(nodeData: T, index: number, viewContainer?: ViewContainerRef, parentData?: T) {\n    const levelAccessor = this._getLevelAccessor();\n\n    const node = this._getNodeDef(nodeData, index);\n    const key = this._getExpansionKey(nodeData);\n\n    // Node context that will be provided to created embedded view\n    const context = new CdkTreeNodeOutletContext<T>(nodeData);\n    context.index = index;\n\n    parentData ??= this._parents.get(key) ?? undefined;\n    // If the tree is flat tree, then use the `getLevel` function in flat tree control\n    // Otherwise, use the level of parent node.\n    if (levelAccessor) {\n      context.level = levelAccessor(nodeData);\n    } else if (parentData !== undefined && this._levels.has(this._getExpansionKey(parentData))) {\n      context.level = this._levels.get(this._getExpansionKey(parentData))! + 1;\n    } else {\n      context.level = 0;\n    }\n    this._levels.set(key, context.level);\n\n    // Use default tree nodeOutlet, or nested node's nodeOutlet\n    const container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;\n    container.createEmbeddedView(node.template, context, index);\n\n    // Set the data to just created `CdkTreeNode`.\n    // The `CdkTreeNode` created from `createEmbeddedView` will be saved in static variable\n    //     `mostRecentTreeNode`. We get it from static variable and pass the node data to it.\n    if (CdkTreeNode.mostRecentTreeNode) {\n      CdkTreeNode.mostRecentTreeNode.data = nodeData;\n    }\n  }\n\n  /** Whether the data node is expanded or collapsed. Returns true if it's expanded. */\n  isExpanded(dataNode: T): boolean {\n    return !!(\n      this.treeControl?.isExpanded(dataNode) ||\n      this._expansionModel?.isSelected(this._getExpansionKey(dataNode))\n    );\n  }\n\n  /** If the data node is currently expanded, collapse it. Otherwise, expand it. */\n  toggle(dataNode: T): void {\n    if (this.treeControl) {\n      this.treeControl.toggle(dataNode);\n    } else if (this._expansionModel) {\n      this._expansionModel.toggle(this._getExpansionKey(dataNode));\n    }\n  }\n\n  /** Expand the data node. If it is already expanded, does nothing. */\n  expand(dataNode: T): void {\n    if (this.treeControl) {\n      this.treeControl.expand(dataNode);\n    } else if (this._expansionModel) {\n      this._expansionModel.select(this._getExpansionKey(dataNode));\n    }\n  }\n\n  /** Collapse the data node. If it is already collapsed, does nothing. */\n  collapse(dataNode: T): void {\n    if (this.treeControl) {\n      this.treeControl.collapse(dataNode);\n    } else if (this._expansionModel) {\n      this._expansionModel.deselect(this._getExpansionKey(dataNode));\n    }\n  }\n\n  /**\n   * If the data node is currently expanded, collapse it and all its descendants.\n   * Otherwise, expand it and all its descendants.\n   */\n  toggleDescendants(dataNode: T): void {\n    if (this.treeControl) {\n      this.treeControl.toggleDescendants(dataNode);\n    } else if (this._expansionModel) {\n      if (this.isExpanded(dataNode)) {\n        this.collapseDescendants(dataNode);\n      } else {\n        this.expandDescendants(dataNode);\n      }\n    }\n  }\n\n  /**\n   * Expand the data node and all its descendants. If they are already expanded, does nothing.\n   */\n  expandDescendants(dataNode: T): void {\n    if (this.treeControl) {\n      this.treeControl.expandDescendants(dataNode);\n    } else if (this._expansionModel) {\n      const expansionModel = this._expansionModel;\n      expansionModel.select(this._getExpansionKey(dataNode));\n      this._getDescendants(dataNode)\n        .pipe(take(1), takeUntil(this._onDestroy))\n        .subscribe(children => {\n          expansionModel.select(...children.map(child => this._getExpansionKey(child)));\n        });\n    }\n  }\n\n  /** Collapse the data node and all its descendants. If it is already collapsed, does nothing. */\n  collapseDescendants(dataNode: T): void {\n    if (this.treeControl) {\n      this.treeControl.collapseDescendants(dataNode);\n    } else if (this._expansionModel) {\n      const expansionModel = this._expansionModel;\n      expansionModel.deselect(this._getExpansionKey(dataNode));\n      this._getDescendants(dataNode)\n        .pipe(take(1), takeUntil(this._onDestroy))\n        .subscribe(children => {\n          expansionModel.deselect(...children.map(child => this._getExpansionKey(child)));\n        });\n    }\n  }\n\n  /** Expands all data nodes in the tree. */\n  expandAll(): void {\n    if (this.treeControl) {\n      this.treeControl.expandAll();\n    } else if (this._expansionModel) {\n      this._forEachExpansionKey(keys => this._expansionModel?.select(...keys));\n    }\n  }\n\n  /** Collapse all data nodes in the tree. */\n  collapseAll(): void {\n    if (this.treeControl) {\n      this.treeControl.collapseAll();\n    } else if (this._expansionModel) {\n      this._forEachExpansionKey(keys => this._expansionModel?.deselect(...keys));\n    }\n  }\n\n  /** Level accessor, used for compatibility between the old Tree and new Tree */\n  _getLevelAccessor() {\n    return this.treeControl?.getLevel?.bind(this.treeControl) ?? this.levelAccessor;\n  }\n\n  /** Children accessor, used for compatibility between the old Tree and new Tree */\n  _getChildrenAccessor() {\n    return this.treeControl?.getChildren?.bind(this.treeControl) ?? this.childrenAccessor;\n  }\n\n  /**\n   * Gets the direct children of a node; used for compatibility between the old tree and the\n   * new tree.\n   */\n  _getDirectChildren(dataNode: T): Observable<T[]> {\n    const levelAccessor = this._getLevelAccessor();\n    const expansionModel = this._expansionModel ?? this.treeControl?.expansionModel;\n    if (!expansionModel) {\n      return observableOf([]);\n    }\n\n    const key = this._getExpansionKey(dataNode);\n\n    const isExpanded = expansionModel.changed.pipe(\n      switchMap(changes => {\n        if (changes.added.includes(key)) {\n          return observableOf(true);\n        } else if (changes.removed.includes(key)) {\n          return observableOf(false);\n        }\n        return EMPTY;\n      }),\n      startWith(this.isExpanded(dataNode)),\n    );\n\n    if (levelAccessor) {\n      return combineLatest([isExpanded, this._flattenedNodes]).pipe(\n        map(([expanded, flattenedNodes]) => {\n          if (!expanded) {\n            return [];\n          }\n          return this._findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, 1);\n        }),\n      );\n    }\n    const childrenAccessor = this._getChildrenAccessor();\n    if (childrenAccessor) {\n      return coerceObservable(childrenAccessor(dataNode) ?? []);\n    }\n    throw getTreeControlMissingError();\n  }\n\n  /**\n   * Given the list of flattened nodes, the level accessor, and the level range within\n   * which to consider children, finds the children for a given node.\n   *\n   * For example, for direct children, `levelDelta` would be 1. For all descendants,\n   * `levelDelta` would be Infinity.\n   */\n  private _findChildrenByLevel(\n    levelAccessor: (node: T) => number,\n    flattenedNodes: readonly T[],\n    dataNode: T,\n    levelDelta: number,\n  ): T[] {\n    const key = this._getExpansionKey(dataNode);\n    const startIndex = flattenedNodes.findIndex(node => this._getExpansionKey(node) === key);\n    const dataNodeLevel = levelAccessor(dataNode);\n    const expectedLevel = dataNodeLevel + levelDelta;\n    const results: T[] = [];\n\n    // Goes through flattened tree nodes in the `flattenedNodes` array, and get all\n    // descendants within a certain level range.\n    //\n    // If we reach a node whose level is equal to or less than the level of the tree node,\n    // we hit a sibling or parent's sibling, and should stop.\n    for (let i = startIndex + 1; i < flattenedNodes.length; i++) {\n      const currentLevel = levelAccessor(flattenedNodes[i]);\n      if (currentLevel <= dataNodeLevel) {\n        break;\n      }\n      if (currentLevel <= expectedLevel) {\n        results.push(flattenedNodes[i]);\n      }\n    }\n    return results;\n  }\n\n  /**\n   * Adds the specified node component to the tree's internal registry.\n   *\n   * This primarily facilitates keyboard navigation.\n   */\n  _registerNode(node: CdkTreeNode<T, K>) {\n    this._nodes.value.set(this._getExpansionKey(node.data), node);\n    this._nodes.next(this._nodes.value);\n  }\n\n  /** Removes the specified node component from the tree's internal registry. */\n  _unregisterNode(node: CdkTreeNode<T, K>) {\n    this._nodes.value.delete(this._getExpansionKey(node.data));\n    this._nodes.next(this._nodes.value);\n  }\n\n  /**\n   * For the given node, determine the level where this node appears in the tree.\n   *\n   * This is intended to be used for `aria-level` but is 0-indexed.\n   */\n  _getLevel(node: T) {\n    return this._levels.get(this._getExpansionKey(node));\n  }\n\n  /**\n   * For the given node, determine the size of the parent's child set.\n   *\n   * This is intended to be used for `aria-setsize`.\n   */\n  _getSetSize(dataNode: T) {\n    const set = this._getAriaSet(dataNode);\n    return set.length;\n  }\n\n  /**\n   * For the given node, determine the index (starting from 1) of the node in its parent's child set.\n   *\n   * This is intended to be used for `aria-posinset`.\n   */\n  _getPositionInSet(dataNode: T) {\n    const set = this._getAriaSet(dataNode);\n    const key = this._getExpansionKey(dataNode);\n    return set.findIndex(node => this._getExpansionKey(node) === key) + 1;\n  }\n\n  /** Given a CdkTreeNode, gets the node that renders that node's parent's data. */\n  _getNodeParent(node: CdkTreeNode<T, K>) {\n    const parent = this._parents.get(this._getExpansionKey(node.data));\n    return parent && this._nodes.value.get(this._getExpansionKey(parent));\n  }\n\n  /** Given a CdkTreeNode, gets the nodes that renders that node's child data. */\n  _getNodeChildren(node: CdkTreeNode<T, K>) {\n    return this._getDirectChildren(node.data).pipe(\n      map(children =>\n        children.reduce<CdkTreeNode<T, K>[]>((nodes, child) => {\n          const value = this._nodes.value.get(this._getExpansionKey(child));\n          if (value) {\n            nodes.push(value);\n          }\n\n          return nodes;\n        }, []),\n      ),\n    );\n  }\n\n  /** `keydown` event handler; this just passes the event to the `TreeKeyManager`. */\n  protected _sendKeydownToKeyManager(event: KeyboardEvent): void {\n    // Only handle events directly on the tree or directly on one of the nodes, otherwise\n    // we risk interfering with events in the projected content (see #29828).\n    if (event.target === this._elementRef.nativeElement) {\n      this._keyManager.onKeydown(event);\n    } else {\n      const nodes = this._nodes.getValue();\n      for (const [, node] of nodes) {\n        if (event.target === node._elementRef.nativeElement) {\n          this._keyManager.onKeydown(event);\n          break;\n        }\n      }\n    }\n  }\n\n  /** Gets all nested descendants of a given node. */\n  private _getDescendants(dataNode: T): Observable<T[]> {\n    if (this.treeControl) {\n      return observableOf(this.treeControl.getDescendants(dataNode));\n    }\n    if (this.levelAccessor) {\n      const results = this._findChildrenByLevel(\n        this.levelAccessor,\n        this._flattenedNodes.value,\n        dataNode,\n        Infinity,\n      );\n      return observableOf(results);\n    }\n    if (this.childrenAccessor) {\n      return this._getAllChildrenRecursively(dataNode).pipe(\n        reduce((allChildren: T[], nextChildren) => {\n          allChildren.push(...nextChildren);\n          return allChildren;\n        }, []),\n      );\n    }\n    throw getTreeControlMissingError();\n  }\n\n  /**\n   * Gets all children and sub-children of the provided node.\n   *\n   * This will emit multiple times, in the order that the children will appear\n   * in the tree, and can be combined with a `reduce` operator.\n   */\n  private _getAllChildrenRecursively(dataNode: T): Observable<T[]> {\n    if (!this.childrenAccessor) {\n      return observableOf([]);\n    }\n\n    return coerceObservable(this.childrenAccessor(dataNode)).pipe(\n      take(1),\n      switchMap(children => {\n        // Here, we cache the parents of a particular child so that we can compute the levels.\n        for (const child of children) {\n          this._parents.set(this._getExpansionKey(child), dataNode);\n        }\n        return observableOf(...children).pipe(\n          concatMap(child => concat(observableOf([child]), this._getAllChildrenRecursively(child))),\n        );\n      }),\n    );\n  }\n\n  private _getExpansionKey(dataNode: T): K {\n    // In the case that a key accessor function was not provided by the\n    // tree user, we'll default to using the node object itself as the key.\n    //\n    // This cast is safe since:\n    // - if an expansionKey is provided, TS will infer the type of K to be\n    //   the return type.\n    // - if it's not, then K will be defaulted to T.\n    return this.expansionKey?.(dataNode) ?? (dataNode as unknown as K);\n  }\n\n  private _getAriaSet(node: T) {\n    const key = this._getExpansionKey(node);\n    const parent = this._parents.get(key);\n    const parentKey = parent ? this._getExpansionKey(parent) : null;\n    const set = this._ariaSets.get(parentKey);\n    return set ?? [node];\n  }\n\n  /**\n   * Finds the parent for the given node. If this is a root node, this\n   * returns null. If we're unable to determine the parent, for example,\n   * if we don't have cached node data, this returns undefined.\n   */\n  private _findParentForNode(node: T, index: number, cachedNodes: readonly T[]): T | null {\n    // In all cases, we have a mapping from node to level; all we need to do here is backtrack in\n    // our flattened list of nodes to determine the first node that's of a level lower than the\n    // provided node.\n    if (!cachedNodes.length) {\n      return null;\n    }\n    const currentLevel = this._levels.get(this._getExpansionKey(node)) ?? 0;\n    for (let parentIndex = index - 1; parentIndex >= 0; parentIndex--) {\n      const parentNode = cachedNodes[parentIndex];\n      const parentLevel = this._levels.get(this._getExpansionKey(parentNode)) ?? 0;\n\n      if (parentLevel < currentLevel) {\n        return parentNode;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Given a set of root nodes and the current node level, flattens any nested\n   * nodes into a single array.\n   *\n   * If any nodes are not expanded, then their children will not be added into the array.\n   * This will still traverse all nested children in order to build up our internal data\n   * models, but will not include them in the returned array.\n   */\n  private _flattenNestedNodesWithExpansion(nodes: readonly T[], level = 0): Observable<T[]> {\n    const childrenAccessor = this._getChildrenAccessor();\n    // If we're using a level accessor, we don't need to flatten anything.\n    if (!childrenAccessor) {\n      return observableOf([...nodes]);\n    }\n\n    return observableOf(...nodes).pipe(\n      concatMap(node => {\n        const parentKey = this._getExpansionKey(node);\n        if (!this._parents.has(parentKey)) {\n          this._parents.set(parentKey, null);\n        }\n        this._levels.set(parentKey, level);\n\n        const children = coerceObservable(childrenAccessor(node));\n        return concat(\n          observableOf([node]),\n          children.pipe(\n            take(1),\n            tap(childNodes => {\n              this._ariaSets.set(parentKey, [...(childNodes ?? [])]);\n              for (const child of childNodes ?? []) {\n                const childKey = this._getExpansionKey(child);\n                this._parents.set(childKey, node);\n                this._levels.set(childKey, level + 1);\n              }\n            }),\n            switchMap(childNodes => {\n              if (!childNodes) {\n                return observableOf([]);\n              }\n              return this._flattenNestedNodesWithExpansion(childNodes, level + 1).pipe(\n                map(nestedNodes => (this.isExpanded(node) ? nestedNodes : [])),\n              );\n            }),\n          ),\n        );\n      }),\n      reduce((results, children) => {\n        results.push(...children);\n        return results;\n      }, [] as T[]),\n    );\n  }\n\n  /**\n   * Converts children for certain tree configurations.\n   *\n   * This also computes parent, level, and group data.\n   */\n  private _computeRenderingData(\n    nodes: readonly T[],\n    nodeType: 'flat' | 'nested',\n  ): Observable<{\n    renderNodes: readonly T[];\n    flattenedNodes: readonly T[];\n  }> {\n    // The only situations where we have to convert children types is when\n    // they're mismatched; i.e. if the tree is using a childrenAccessor and the\n    // nodes are flat, or if the tree is using a levelAccessor and the nodes are\n    // nested.\n    if (this.childrenAccessor && nodeType === 'flat') {\n      // clear previously generated data so we don't keep end up retaining data overtime causing\n      // memory leaks.\n      this._clearPreviousCache();\n      // This flattens children into a single array.\n      this._ariaSets.set(null, [...nodes]);\n      return this._flattenNestedNodesWithExpansion(nodes).pipe(\n        map(flattenedNodes => ({\n          renderNodes: flattenedNodes,\n          flattenedNodes,\n        })),\n      );\n    } else if (this.levelAccessor && nodeType === 'nested') {\n      // In the nested case, we only look for root nodes. The CdkNestedNode\n      // itself will handle rendering each individual node's children.\n      const levelAccessor = this.levelAccessor;\n      return observableOf(nodes.filter(node => levelAccessor(node) === 0)).pipe(\n        map(rootNodes => ({\n          renderNodes: rootNodes,\n          flattenedNodes: nodes,\n        })),\n        tap(({flattenedNodes}) => {\n          this._calculateParents(flattenedNodes);\n        }),\n      );\n    } else if (nodeType === 'flat') {\n      // In the case of a TreeControl, we know that the node type matches up\n      // with the TreeControl, and so no conversions are necessary. Otherwise,\n      // we've already confirmed that the data model matches up with the\n      // desired node type here.\n      return observableOf({renderNodes: nodes, flattenedNodes: nodes}).pipe(\n        tap(({flattenedNodes}) => {\n          this._calculateParents(flattenedNodes);\n        }),\n      );\n    } else {\n      // clear previously generated data so we don't keep end up retaining data overtime causing\n      // memory leaks.\n      this._clearPreviousCache();\n      // For nested nodes, we still need to perform the node flattening in order\n      // to maintain our caches for various tree operations.\n      this._ariaSets.set(null, [...nodes]);\n      return this._flattenNestedNodesWithExpansion(nodes).pipe(\n        map(flattenedNodes => ({\n          renderNodes: nodes,\n          flattenedNodes,\n        })),\n      );\n    }\n  }\n\n  private _updateCachedData(flattenedNodes: readonly T[]) {\n    this._flattenedNodes.next(flattenedNodes);\n  }\n\n  private _updateKeyManagerItems(flattenedNodes: readonly T[]) {\n    this._keyManagerNodes.next(flattenedNodes);\n  }\n\n  /** Traverse the flattened node data and compute parents, levels, and group data. */\n  private _calculateParents(flattenedNodes: readonly T[]): void {\n    const levelAccessor = this._getLevelAccessor();\n    if (!levelAccessor) {\n      return;\n    }\n\n    // clear previously generated data so we don't keep end up retaining data overtime causing\n    // memory leaks.\n    this._clearPreviousCache();\n\n    for (let index = 0; index < flattenedNodes.length; index++) {\n      const dataNode = flattenedNodes[index];\n      const key = this._getExpansionKey(dataNode);\n      this._levels.set(key, levelAccessor(dataNode));\n      const parent = this._findParentForNode(dataNode, index, flattenedNodes);\n      this._parents.set(key, parent);\n      const parentKey = parent ? this._getExpansionKey(parent) : null;\n\n      const group = this._ariaSets.get(parentKey) ?? [];\n      group.splice(index, 0, dataNode);\n      this._ariaSets.set(parentKey, group);\n    }\n  }\n\n  /** Invokes a callback with all node expansion keys. */\n  private _forEachExpansionKey(callback: (keys: K[]) => void) {\n    const toToggle: K[] = [];\n    const observables: Observable<T[]>[] = [];\n\n    this._nodes.value.forEach(node => {\n      toToggle.push(this._getExpansionKey(node.data));\n      observables.push(this._getDescendants(node.data));\n    });\n\n    if (observables.length > 0) {\n      combineLatest(observables)\n        .pipe(take(1), takeUntil(this._onDestroy))\n        .subscribe(results => {\n          results.forEach(inner => inner.forEach(r => toToggle.push(this._getExpansionKey(r))));\n          callback(toToggle);\n        });\n    } else {\n      callback(toToggle);\n    }\n  }\n\n  /** Clears the maps we use to store parents, level & aria-sets in. */\n  private _clearPreviousCache() {\n    this._parents.clear();\n    this._levels.clear();\n    this._ariaSets.clear();\n  }\n}\n\n/**\n * Tree node for CdkTree. It contains the data in the tree node.\n */\n@Directive({\n  selector: 'cdk-tree-node',\n  exportAs: 'cdkTreeNode',\n  host: {\n    'class': 'cdk-tree-node',\n    '[attr.aria-expanded]': '_getAriaExpanded()',\n    '[attr.aria-level]': 'level + 1',\n    '[attr.aria-posinset]': '_getPositionInSet()',\n    '[attr.aria-setsize]': '_getSetSize()',\n    '[tabindex]': '_tabindex',\n    'role': 'treeitem',\n    '(click)': '_setActiveItem()',\n    '(focus)': '_focusItem()',\n  },\n})\nexport class CdkTreeNode<T, K = T> implements OnDestroy, OnInit, TreeKeyManagerItem {\n  _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  protected _tree = inject<CdkTree<T, K>>(CdkTree);\n  protected _tabindex: number | null = -1;\n  protected readonly _type: 'flat' | 'nested' = 'flat';\n\n  /**\n   * The role of the tree node.\n   *\n   * @deprecated This will be ignored; the tree will automatically determine the appropriate role\n   * for tree node. This input will be removed in a future version.\n   * @breaking-change 21.0.0\n   */\n  @Input() get role(): 'treeitem' | 'group' {\n    return 'treeitem';\n  }\n\n  set role(_role: 'treeitem' | 'group') {\n    // ignore any role setting, we handle this internally.\n  }\n\n  /**\n   * Whether or not this node is expandable.\n   *\n   * If not using `FlatTreeControl`, or if `isExpandable` is not provided to\n   * `NestedTreeControl`, this should be provided for correct node a11y.\n   */\n  @Input({transform: booleanAttribute})\n  get isExpandable() {\n    return this._isExpandable();\n  }\n  set isExpandable(isExpandable: boolean) {\n    this._inputIsExpandable = isExpandable;\n    if ((this.data && !this._isExpandable) || !this._inputIsExpandable) {\n      return;\n    }\n    // If the node is being set to expandable, ensure that the status of the\n    // node is propagated\n    if (this._inputIsExpanded) {\n      this.expand();\n    } else if (this._inputIsExpanded === false) {\n      this.collapse();\n    }\n  }\n\n  @Input()\n  get isExpanded(): boolean {\n    return this._tree.isExpanded(this._data);\n  }\n  set isExpanded(isExpanded: boolean) {\n    this._inputIsExpanded = isExpanded;\n    if (isExpanded) {\n      this.expand();\n    } else {\n      this.collapse();\n    }\n  }\n\n  /**\n   * Whether or not this node is disabled. If it's disabled, then the user won't be able to focus\n   * or activate this node.\n   */\n  @Input({transform: booleanAttribute}) isDisabled: boolean;\n\n  /**\n   * The text used to locate this item during typeahead. If not specified, the `textContent` will\n   * will be used.\n   */\n  @Input('cdkTreeNodeTypeaheadLabel') typeaheadLabel: string | null;\n\n  getLabel(): string {\n    return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || '';\n  }\n\n  /** This emits when the node has been programatically activated or activated by keyboard. */\n  @Output()\n  readonly activation: EventEmitter<T> = new EventEmitter<T>();\n\n  /** This emits when the node's expansion status has been changed. */\n  @Output()\n  readonly expandedChange: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n  /**\n   * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it\n   * in `CdkTree` and set the data to it.\n   */\n  static mostRecentTreeNode: CdkTreeNode<any> | null = null;\n\n  /** Subject that emits when the component has been destroyed. */\n  protected readonly _destroyed = new Subject<void>();\n\n  /** Emits when the node's data has changed. */\n  readonly _dataChanges = new Subject<void>();\n\n  private _inputIsExpandable: boolean = false;\n  private _inputIsExpanded: boolean | undefined = undefined;\n  /**\n   * Flag used to determine whether or not we should be focusing the actual element based on\n   * some user interaction (click or focus). On click, we don't forcibly focus the element\n   * since the click could trigger some other component that wants to grab its own focus\n   * (e.g. menu, dialog).\n   */\n  private _shouldFocus = true;\n  private _parentNodeAriaLevel: number;\n\n  /** The tree node's data. */\n  get data(): T {\n    return this._data;\n  }\n  set data(value: T) {\n    if (value !== this._data) {\n      this._data = value;\n      this._dataChanges.next();\n    }\n  }\n  protected _data: T;\n\n  /* If leaf node, return true to not assign aria-expanded attribute */\n  get isLeafNode(): boolean {\n    // If flat tree node data returns false for expandable property, it's a leaf node\n    if (\n      this._tree.treeControl?.isExpandable !== undefined &&\n      !this._tree.treeControl.isExpandable(this._data)\n    ) {\n      return true;\n\n      // If nested tree node data returns 0 descendants, it's a leaf node\n    } else if (\n      this._tree.treeControl?.isExpandable === undefined &&\n      this._tree.treeControl?.getDescendants(this._data).length === 0\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  get level(): number {\n    // If the tree has a levelAccessor, use it to get the level. Otherwise read the\n    // aria-level off the parent node and use it as the level for this node (note aria-level is\n    // 1-indexed, while this property is 0-indexed, so we don't need to increment).\n    return this._tree._getLevel(this._data) ?? this._parentNodeAriaLevel;\n  }\n\n  /** Determines if the tree node is expandable. */\n  _isExpandable(): boolean {\n    if (this._tree.treeControl) {\n      if (this.isLeafNode) {\n        return false;\n      }\n\n      // For compatibility with trees created using TreeControl before we added\n      // CdkTreeNode#isExpandable.\n      return true;\n    }\n    return this._inputIsExpandable;\n  }\n\n  /**\n   * Determines the value for `aria-expanded`.\n   *\n   * For non-expandable nodes, this is `null`.\n   */\n  _getAriaExpanded(): string | null {\n    if (!this._isExpandable()) {\n      return null;\n    }\n    return String(this.isExpanded);\n  }\n\n  /**\n   * Determines the size of this node's parent's child set.\n   *\n   * This is intended to be used for `aria-setsize`.\n   */\n  _getSetSize(): number {\n    return this._tree._getSetSize(this._data);\n  }\n\n  /**\n   * Determines the index (starting from 1) of this node in its parent's child set.\n   *\n   * This is intended to be used for `aria-posinset`.\n   */\n  _getPositionInSet(): number {\n    return this._tree._getPositionInSet(this._data);\n  }\n\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    CdkTreeNode.mostRecentTreeNode = this as CdkTreeNode<T, K>;\n  }\n\n  ngOnInit(): void {\n    this._parentNodeAriaLevel = getParentNodeAriaLevel(this._elementRef.nativeElement);\n    this._tree\n      ._getExpansionModel()\n      .changed.pipe(\n        map(() => this.isExpanded),\n        distinctUntilChanged(),\n        takeUntil(this._destroyed),\n      )\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => this._changeDetectorRef.markForCheck());\n    this._tree._setNodeTypeIfUnset(this._type);\n    this._tree._registerNode(this);\n  }\n\n  ngOnDestroy() {\n    // If this is the last tree node being destroyed,\n    // clear out the reference to avoid leaking memory.\n    if (CdkTreeNode.mostRecentTreeNode === this) {\n      CdkTreeNode.mostRecentTreeNode = null;\n    }\n\n    this._dataChanges.complete();\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  getParent(): CdkTreeNode<T, K> | null {\n    return this._tree._getNodeParent(this) ?? null;\n  }\n\n  getChildren(): CdkTreeNode<T, K>[] | Observable<CdkTreeNode<T, K>[]> {\n    return this._tree._getNodeChildren(this);\n  }\n\n  /** Focuses this data node. Implemented for TreeKeyManagerItem. */\n  focus(): void {\n    this._tabindex = 0;\n    if (this._shouldFocus) {\n      this._elementRef.nativeElement.focus();\n    }\n\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /** Defocus this data node. */\n  unfocus(): void {\n    this._tabindex = -1;\n\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /** Emits an activation event. Implemented for TreeKeyManagerItem. */\n  activate(): void {\n    if (this.isDisabled) {\n      return;\n    }\n    this.activation.next(this._data);\n  }\n\n  /** Collapses this data node. Implemented for TreeKeyManagerItem. */\n  collapse(): void {\n    if (this.isExpandable) {\n      this._tree.collapse(this._data);\n    }\n  }\n\n  /** Expands this data node. Implemented for TreeKeyManagerItem. */\n  expand(): void {\n    if (this.isExpandable) {\n      this._tree.expand(this._data);\n    }\n  }\n\n  /** Makes the node focusable. Implemented for TreeKeyManagerItem. */\n  makeFocusable(): void {\n    this._tabindex = 0;\n    this._changeDetectorRef.markForCheck();\n  }\n\n  _focusItem() {\n    if (this.isDisabled) {\n      return;\n    }\n    this._tree._keyManager.focusItem(this);\n  }\n\n  _setActiveItem() {\n    if (this.isDisabled) {\n      return;\n    }\n    this._shouldFocus = false;\n    this._tree._keyManager.focusItem(this);\n    this._shouldFocus = true;\n  }\n\n  _emitExpansionState(expanded: boolean) {\n    this.expandedChange.emit(expanded);\n  }\n}\n\nfunction getParentNodeAriaLevel(nodeElement: HTMLElement): number {\n  let parent = nodeElement.parentElement;\n  while (parent && !isNodeElement(parent)) {\n    parent = parent.parentElement;\n  }\n  if (!parent) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throw Error('Incorrect tree structure containing detached node.');\n    } else {\n      return -1;\n    }\n  } else if (parent.classList.contains('cdk-nested-tree-node')) {\n    return numberAttribute(parent.getAttribute('aria-level')!);\n  } else {\n    // The ancestor element is the cdk-tree itself\n    return 0;\n  }\n}\n\nfunction isNodeElement(element: HTMLElement) {\n  const classList = element.classList;\n  return !!(classList?.contains('cdk-nested-tree-node') || classList?.contains('cdk-tree'));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {\n  AfterContentInit,\n  ContentChildren,\n  Directive,\n  IterableDiffer,\n  IterableDiffers,\n  OnDestroy,\n  QueryList,\n  inject,\n} from '@angular/core';\nimport {takeUntil} from 'rxjs/operators';\n\nimport {CDK_TREE_NODE_OUTLET_NODE, CdkTreeNodeOutlet} from './outlet';\nimport {CdkTreeNode} from './tree';\n\n/**\n * Nested node is a child of `<cdk-tree>`. It works with nested tree.\n * By using `cdk-nested-tree-node` component in tree node template, children of the parent node will\n * be added in the `cdkTreeNodeOutlet` in tree node template.\n * The children of node will be automatically added to `cdkTreeNodeOutlet`.\n */\n@Directive({\n  selector: 'cdk-nested-tree-node',\n  exportAs: 'cdkNestedTreeNode',\n  providers: [\n    {provide: CdkTreeNode, useExisting: CdkNestedTreeNode},\n    {provide: CDK_TREE_NODE_OUTLET_NODE, useExisting: CdkNestedTreeNode},\n  ],\n  host: {\n    'class': 'cdk-nested-tree-node',\n  },\n})\nexport class CdkNestedTreeNode<T, K = T>\n  extends CdkTreeNode<T, K>\n  implements AfterContentInit, OnDestroy\n{\n  protected override _type: 'flat' | 'nested' = 'nested';\n  protected _differs = inject(IterableDiffers);\n\n  /** Differ used to find the changes in the data provided by the data source. */\n  private _dataDiffer: IterableDiffer<T>;\n\n  /** The children data dataNodes of current node. They will be placed in `CdkTreeNodeOutlet`. */\n  protected _children: T[];\n\n  /** The children node placeholder. */\n  @ContentChildren(CdkTreeNodeOutlet, {\n    // We need to use `descendants: true`, because Ivy will no longer match\n    // indirect descendants if it's left as false.\n    descendants: true,\n  })\n  nodeOutlet: QueryList<CdkTreeNodeOutlet>;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    super();\n  }\n\n  ngAfterContentInit() {\n    this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);\n    this._tree\n      ._getDirectChildren(this.data)\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(result => this.updateChildrenNodes(result));\n    this.nodeOutlet.changes\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => this.updateChildrenNodes());\n  }\n\n  override ngOnDestroy() {\n    this._clear();\n    super.ngOnDestroy();\n  }\n\n  /** Add children dataNodes to the NodeOutlet */\n  protected updateChildrenNodes(children?: T[]): void {\n    const outlet = this._getNodeOutlet();\n    if (children) {\n      this._children = children;\n    }\n    if (outlet && this._children) {\n      const viewContainer = outlet.viewContainer;\n      this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);\n    } else {\n      // Reset the data differ if there's no children nodes displayed\n      this._dataDiffer.diff([]);\n    }\n  }\n\n  /** Clear the children dataNodes. */\n  protected _clear(): void {\n    const outlet = this._getNodeOutlet();\n    if (outlet) {\n      outlet.viewContainer.clear();\n      this._dataDiffer.diff([]);\n    }\n  }\n\n  /** Gets the outlet for the current node. */\n  private _getNodeOutlet() {\n    const outlets = this.nodeOutlet;\n\n    // Note that since we use `descendants: true` on the query, we have to ensure\n    // that we don't pick up the outlet of a child node by accident.\n    return outlets && outlets.find(outlet => !outlet._node || outlet._node === this);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directionality} from '../bidi';\nimport {Directive, ElementRef, Input, numberAttribute, OnDestroy, inject} from '@angular/core';\nimport {takeUntil} from 'rxjs/operators';\nimport {Subject} from 'rxjs';\nimport {CdkTree, CdkTreeNode} from './tree';\n\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n\n/**\n * Indent for the children tree dataNodes.\n * This directive will add left-padding to the node to show hierarchy.\n */\n@Directive({\n  selector: '[cdkTreeNodePadding]',\n})\nexport class CdkTreeNodePadding<T, K = T> implements OnDestroy {\n  private _treeNode = inject<CdkTreeNode<T, K>>(CdkTreeNode);\n  private _tree = inject<CdkTree<T, K>>(CdkTree);\n  private _element = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _dir = inject(Directionality, {optional: true});\n\n  /** Current padding value applied to the element. Used to avoid unnecessarily hitting the DOM. */\n  private _currentPadding: string | null;\n\n  /** Subject that emits when the component has been destroyed. */\n  private readonly _destroyed = new Subject<void>();\n\n  /** CSS units used for the indentation value. */\n  indentUnits = 'px';\n\n  /** The level of depth of the tree node. The padding will be `level * indent` pixels. */\n  @Input({alias: 'cdkTreeNodePadding', transform: numberAttribute})\n  get level(): number {\n    return this._level;\n  }\n  set level(value: number) {\n    this._setLevelInput(value);\n  }\n  _level: number;\n\n  /**\n   * The indent for each level. Can be a number or a CSS string.\n   * Default number 40px from material design menu sub-menu spec.\n   */\n  @Input('cdkTreeNodePaddingIndent')\n  get indent(): number | string {\n    return this._indent;\n  }\n  set indent(indent: number | string) {\n    this._setIndentInput(indent);\n  }\n  _indent: number = 40;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    this._setPadding();\n    this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(() => this._setPadding(true));\n\n    // In Ivy the indentation binding might be set before the tree node's data has been added,\n    // which means that we'll miss the first render. We have to subscribe to changes in the\n    // data to ensure that everything is up to date.\n    this._treeNode._dataChanges.subscribe(() => this._setPadding());\n  }\n\n  ngOnDestroy() {\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /** The padding indent value for the tree node. Returns a string with px numbers if not null. */\n  _paddingIndent(): string | null {\n    const nodeLevel = (this._treeNode.data && this._tree._getLevel(this._treeNode.data)) ?? null;\n    const level = this._level == null ? nodeLevel : this._level;\n    return typeof level === 'number' ? `${level * this._indent}${this.indentUnits}` : null;\n  }\n\n  _setPadding(forceChange = false) {\n    const padding = this._paddingIndent();\n\n    if (padding !== this._currentPadding || forceChange) {\n      const element = this._element.nativeElement;\n      const paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';\n      const resetProp = paddingProp === 'paddingLeft' ? 'paddingRight' : 'paddingLeft';\n      element.style[paddingProp] = padding || '';\n      element.style[resetProp] = '';\n      this._currentPadding = padding;\n    }\n  }\n\n  /**\n   * This has been extracted to a util because of TS 4 and VE.\n   * View Engine doesn't support property rename inheritance.\n   * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n   * @docs-private\n   */\n  protected _setLevelInput(value: number) {\n    // Set to null as the fallback value so that _setPadding can fall back to the node level if the\n    // consumer set the directive as `cdkTreeNodePadding=\"\"`. We still want to take this value if\n    // they set 0 explicitly.\n    this._level = isNaN(value) ? null! : value;\n    this._setPadding();\n  }\n\n  /**\n   * This has been extracted to a util because of TS 4 and VE.\n   * View Engine doesn't support property rename inheritance.\n   * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n   * @docs-private\n   */\n  protected _setIndentInput(indent: number | string) {\n    let value = indent;\n    let units = 'px';\n\n    if (typeof indent === 'string') {\n      const parts = indent.split(cssUnitPattern);\n      value = parts[0];\n      units = parts[1] || units;\n    }\n\n    this.indentUnits = units;\n    this._indent = numberAttribute(value);\n    this._setPadding();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, Input, booleanAttribute, inject} from '@angular/core';\n\nimport {CdkTree, CdkTreeNode} from './tree';\n\n/**\n * Node toggle to expand and collapse the node.\n */\n@Directive({\n  selector: '[cdkTreeNodeToggle]',\n  host: {\n    '(click)': '_toggle(); $event.stopPropagation();',\n    '(keydown.Enter)': '_toggle(); $event.preventDefault();',\n    '(keydown.Space)': '_toggle(); $event.preventDefault();',\n    'tabindex': '-1',\n  },\n})\nexport class CdkTreeNodeToggle<T, K = T> {\n  protected _tree = inject<CdkTree<T, K>>(CdkTree);\n  protected _treeNode = inject<CdkTreeNode<T, K>>(CdkTreeNode);\n\n  /** Whether expand/collapse the node recursively. */\n  @Input({alias: 'cdkTreeNodeToggleRecursive', transform: booleanAttribute})\n  recursive: boolean = false;\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  // Toggle the expanded or collapsed state of this node.\n  //\n  // Focus this node with expanding or collapsing it. This ensures that the active node will always\n  // be visible when expanding and collapsing.\n  _toggle(): void {\n    this.recursive\n      ? this._tree.toggleDescendants(this._treeNode.data)\n      : this._tree.toggle(this._treeNode.data);\n\n    this._tree._keyManager.focusItem(this._treeNode);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {CdkTreeNodeOutlet} from './outlet';\nimport {CdkTreeNodePadding} from './padding';\nimport {CdkTreeNodeToggle} from './toggle';\nimport {CdkTree, CdkTreeNode} from './tree';\nimport {CdkTreeNodeDef} from './node';\nimport {CdkNestedTreeNode} from './nested-node';\n\nconst EXPORTED_DECLARATIONS = [\n  CdkNestedTreeNode,\n  CdkTreeNodeDef,\n  CdkTreeNodePadding,\n  CdkTreeNodeToggle,\n  CdkTree,\n  CdkTreeNode,\n  CdkTreeNodeOutlet,\n];\n\n@NgModule({\n  imports: EXPORTED_DECLARATIONS,\n  exports: EXPORTED_DECLARATIONS,\n})\nexport class CdkTreeModule {}\n"],"names":["expand","dataNode","expansionModel","select","_trackByValue","collapse","isExpanded","toggleDescendants","expandDescendants","getLevel","options","results","NestedTreeControl","BaseTreeControl","isExpandable","getDescendants","descendants","_getDescendants","splice","push","InjectionToken","viewContainer","inject","ViewContainerRef","CDK_TREE_NODE_OUTLET_NODE","optional","i0","ɵɵngDeclareClassMetadata","minVersion","version","ngImport","type","CdkTreeNodeOutlet","decorators","count","constructor","data","$implicit","getTreeMultipleDefaultNodeDefsError","Error","getTreeMissingMatchingNodeDefError","getTreeControlMissingError","CdkTree","_differs","IterableDiffers","_onDestroy","Subject","_dataDiffer","_defaultNodeDef","_levels","Map","_parents","dataSource","_dataSource","levelAccessor","childrenAccessor","trackBy","BehaviorSubject","start","_flattenedNodes","_keyManagerNodes","_keyManagerFactory","TREE_KEY_MANAGER","ngAfterContentInit","_initializeKeyManager","_updateDefaultNodeDefinition","_subscribeToDataChanges","_nodeOutlet","clear","_nodes","complete","_nodeType","viewChange","next","disconnect","_dataSubscription","unsubscribe","_initializeDataDiffer","_viewInit","_nodeDefs","filter","def","when","ngDevMode","defaultNodeDefs","console","warn","currentType","newType","_getExpansionModel","_expansionModel","SelectionModel","treeControl","dataStream","connect","isObservable","Array","isArray","observableOf","getTreeNoValidDataSourceError","_getRenderData","pipe","takeUntil","renderingData","_renderDataChanges","changed","startWith","tap","expansionChanges","_emitExpansionChanges","nodeType","renderNodes","flattenedNodes","renderNodeChanges","_updateCachedData","_updateKeyManagerItems","nodes","value","added","node","get","_emitExpansionState","removed","items","combineLatest","map","keyManagerNodes","reduce","_getExpansionKey","skipPredicate","isDisabled","_keyManager","keyManagerOptions","_index","item","find","create","_checkTreeControlUsage","numTreeControls","getMultipleTreeControlsError","dataDiffer","parentData","diff","changes","insertNode","currentIndex","remove","adjustedPreviousIndex","view","move","forEachIdentityChange","record","newData","undefined","_changeDetectorRef","markForCheck","_getNodeDef","i","nodeDef","nodeData","index","key","context","level","container","createEmbeddedView","template","CdkTreeNode","mostRecentTreeNode","isSelected","toggle","deselect","take","subscribe","children","collapseDescendants","expandAll","collapseAll","_getLevelAccessor","bind","_getChildrenAccessor","getChildren","switchMap","includes","_findChildrenByLevel","startIndex","length","currentLevel","dataNodeLevel","expectedLevel","_getLevel","_getSetSize","set","_getAriaSet","_getPositionInSet","parent","child","_sendKeydownToKeyManager","event","target","_elementRef","nativeElement","getValue","onKeydown","allChildren","nextChildren","_getAllChildrenRecursively","expansionKey","_findParentForNode","cachedNodes","parentNode","parentIndex","parentLevel","concatMap","parentKey","has","_ariaSets","childNodes","childKey","_flattenNestedNodesWithExpansion","nestedNodes","_computeRenderingData","rootNodes","_calculateParents","_clearPreviousCache","group","_forEachExpansionKey","callback","toToggle","forEach","observables","inner","r","Component","args","selector","ViewEncapsulation","None","Input","ViewChild","static","CdkTreeNodeDef","ElementRef","_type","_inputIsExpanded","role","transform","booleanAttribute","_children","nodeOutlet","_tree","_destroyed","result","updateChildrenNodes","ngOnDestroy","_clear","outlet","_getNodeOutlet","_data","exportAs","host","ctorParameters","propDecorators","cssUnitPattern","_treeNode","_currentPadding","indentUnits","_level","indent","_setPadding","_dataChanges","_paddingIndent","forceChange","element","_element","paddingProp","_dir","resetProp","style","padding","CdkTreeNodeToggle","_toggle","recursive","ɵfac","ɵɵngDeclareFactory","deps","ɵɵFactoryTarget","Directive","alias","CdkTreeModule","NgModule","ɵɵngDeclareNgModule","imports","CdkNestedTreeNode","EXPORTED_DECLARATIONS"],"mappings":"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"}