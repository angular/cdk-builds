{"version":3,"file":"_recycle-view-repeater-strategy-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/collections/array-data-source.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/collections/recycle-view-repeater-strategy.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Observable, isObservable, of as observableOf} from 'rxjs';\nimport {DataSource} from './data-source';\n\n/** DataSource wrapper for a native array. */\nexport class ArrayDataSource<T> extends DataSource<T> {\n  constructor(private _data: readonly T[] | Observable<readonly T[]>) {\n    super();\n  }\n\n  connect(): Observable<readonly T[]> {\n    return isObservable(this._data) ? this._data : observableOf(this._data);\n  }\n\n  disconnect() {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  EmbeddedViewRef,\n  IterableChangeRecord,\n  IterableChanges,\n  ViewContainerRef,\n} from '@angular/core';\nimport {\n  _ViewRepeater,\n  _ViewRepeaterItemChanged,\n  _ViewRepeaterItemContext,\n  _ViewRepeaterItemContextFactory,\n  _ViewRepeaterItemInsertArgs,\n  _ViewRepeaterItemValueResolver,\n  _ViewRepeaterOperation,\n} from './view-repeater';\n\n/**\n * A repeater that caches views when they are removed from a\n * `ViewContainerRef`. When new items are inserted into the container,\n * the repeater will reuse one of the cached views instead of creating a new\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\n * inserts.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nexport class _RecycleViewRepeaterStrategy<T, R, C extends _ViewRepeaterItemContext<T>>\n  implements _ViewRepeater<T, R, C>\n{\n  /**\n   * The size of the cache used to store unused views.\n   * Setting the cache size to `0` will disable caching. Defaults to 20 views.\n   */\n  viewCacheSize: number = 20;\n\n  /**\n   * View cache that stores embedded view instances that have been previously stamped out,\n   * but don't are not currently rendered. The view repeater will reuse these views rather than\n   * creating brand new ones.\n   *\n   * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\n   */\n  private _viewCache: EmbeddedViewRef<C>[] = [];\n\n  /** Apply changes to the DOM. */\n  applyChanges(\n    changes: IterableChanges<R>,\n    viewContainerRef: ViewContainerRef,\n    itemContextFactory: _ViewRepeaterItemContextFactory<T, R, C>,\n    itemValueResolver: _ViewRepeaterItemValueResolver<T, R>,\n    itemViewChanged?: _ViewRepeaterItemChanged<R, C>,\n  ) {\n    // Rearrange the views to put them in the right location.\n    changes.forEachOperation(\n      (\n        record: IterableChangeRecord<R>,\n        adjustedPreviousIndex: number | null,\n        currentIndex: number | null,\n      ) => {\n        let view: EmbeddedViewRef<C> | undefined;\n        let operation: _ViewRepeaterOperation;\n        if (record.previousIndex == null) {\n          // Item added.\n          const viewArgsFactory = () =>\n            itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n          view = this._insertView(\n            viewArgsFactory,\n            currentIndex!,\n            viewContainerRef,\n            itemValueResolver(record),\n          );\n          operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;\n        } else if (currentIndex == null) {\n          // Item removed.\n          this._detachAndCacheView(adjustedPreviousIndex!, viewContainerRef);\n          operation = _ViewRepeaterOperation.REMOVED;\n        } else {\n          // Item moved.\n          view = this._moveView(\n            adjustedPreviousIndex!,\n            currentIndex!,\n            viewContainerRef,\n            itemValueResolver(record),\n          );\n          operation = _ViewRepeaterOperation.MOVED;\n        }\n\n        if (itemViewChanged) {\n          itemViewChanged({\n            context: view?.context,\n            operation,\n            record,\n          });\n        }\n      },\n    );\n  }\n\n  detach() {\n    for (const view of this._viewCache) {\n      view.destroy();\n    }\n    this._viewCache = [];\n  }\n\n  /**\n   * Inserts a view for a new item, either from the cache or by creating a new\n   * one. Returns `undefined` if the item was inserted into a cached view.\n   */\n  private _insertView(\n    viewArgsFactory: () => _ViewRepeaterItemInsertArgs<C>,\n    currentIndex: number,\n    viewContainerRef: ViewContainerRef,\n    value: T,\n  ): EmbeddedViewRef<C> | undefined {\n    const cachedView = this._insertViewFromCache(currentIndex!, viewContainerRef);\n    if (cachedView) {\n      cachedView.context.$implicit = value;\n      return undefined;\n    }\n\n    const viewArgs = viewArgsFactory();\n    return viewContainerRef.createEmbeddedView(\n      viewArgs.templateRef,\n      viewArgs.context,\n      viewArgs.index,\n    );\n  }\n\n  /** Detaches the view at the given index and inserts into the view cache. */\n  private _detachAndCacheView(index: number, viewContainerRef: ViewContainerRef) {\n    const detachedView = viewContainerRef.detach(index) as EmbeddedViewRef<C>;\n    this._maybeCacheView(detachedView, viewContainerRef);\n  }\n\n  /** Moves view at the previous index to the current index. */\n  private _moveView(\n    adjustedPreviousIndex: number,\n    currentIndex: number,\n    viewContainerRef: ViewContainerRef,\n    value: T,\n  ): EmbeddedViewRef<C> {\n    const view = viewContainerRef.get(adjustedPreviousIndex!) as EmbeddedViewRef<C>;\n    viewContainerRef.move(view, currentIndex);\n    view.context.$implicit = value;\n    return view;\n  }\n\n  /**\n   * Cache the given detached view. If the cache is full, the view will be\n   * destroyed.\n   */\n  private _maybeCacheView(view: EmbeddedViewRef<C>, viewContainerRef: ViewContainerRef) {\n    if (this._viewCache.length < this.viewCacheSize) {\n      this._viewCache.push(view);\n    } else {\n      const index = viewContainerRef.indexOf(view);\n\n      // The host component could remove views from the container outside of\n      // the view repeater. It's unlikely this will occur, but just in case,\n      // destroy the view on its own, otherwise destroy it through the\n      // container to ensure that all the references are removed.\n      if (index === -1) {\n        view.destroy();\n      } else {\n        viewContainerRef.remove(index);\n      }\n    }\n  }\n\n  /** Inserts a recycled view from the cache at the given index. */\n  private _insertViewFromCache(\n    index: number,\n    viewContainerRef: ViewContainerRef,\n  ): EmbeddedViewRef<C> | null {\n    const cachedView = this._viewCache.pop();\n    if (cachedView) {\n      viewContainerRef.insert(cachedView, index);\n    }\n    return cachedView || null;\n  }\n}\n"],"names":["_data","isObservable","observableOf","disconnect","record","previousIndex","viewArgsFactory","itemContextFactory","adjustedPreviousIndex","view","_insertView","currentIndex","viewContainerRef","itemValueResolver","operation","_ViewRepeaterOperation","REPLACED","_detachAndCacheView","REMOVED","_moveView","MOVED","itemViewChanged","context","_viewCache","value","cachedView","_insertViewFromCache","$implicit","viewArgs"],"mappings":";;;;;;;AAcI,IAAA,KAAA,EAAA;IACF,IAAA,CAAAA,KAAA,GAAAA,KAAA;;;IAMA,OAAAC,YAAA,CAAc,IAAAD,CAAAA,KAAA,SAAAA,KAAA,GAAAE,EAAA,CAAA,IAAA,CAAAF,KAAA,CAAA;AACf;AAAAG,EAAAA,UAAAA,GAAA;;;;;;;;;;;;;;;;;;;UC6EWC,MAAS,CAAAC,aAAA,IAAA,IAAA,EAAA;QAGb,MACFC,eAEJ,GAAAA,MAEAC,kBACE,CAAAH,MAAA,EAAAI,mCACgB,CAAA;QAEhBC,IAAA,GAAA,IAAA,CAAAC,WAAA,CAAAJ,eAAA,EAAAK,YAAoB,EAAAC,gBAAA,EAAAC,iBAAA,CAAAT,MAAA,CAAA,CAAA;QACtBU,SAAA,GAAAL,IAAA,kCAKG,GAAAM,sBACK,CAAAC,QAAA;AAMN,OAAA,MACI,IAAAL,YAAY,IAAA,IAAA,EAAA;AAEd,QAAA,IAAA,CAAAM;QACFH,SAAA,GAAAC,sBAEA,CAAAG,OAAA;AAYF,OAAA,MAAA;YAE6D,GAAA,IAAA,CAAAC,SAAA,CAAAX,qBAAA,EAAAG,YAAA,EAAAC,gBAAA,EAAAC,iBAAA,CAAAT,MAAA,CAAA,CAAA;QACrDU,SAAA,GAAAC,sBACuB,CAAAK,KAAA;;UAM7BC,eAAA,EAAA;QACAA,eAAA,CAAA;UAAYC,OAAA,EAAAb,IAAA,EAAAa,OAAA;UACZR,SAAA;AACFV,UAAAA;AAOM,SAAA,CAAA;AACF;;;;AAKA,IAAA,KAAA,MAAA,IAAA,IAAA,IAAsE,CAAAmB,UAAA,EAAA;kBACtE,EAAgE;;AAEhE,IAAA,IAAA,CAAAA,UAAA,GAAA,EAAA;;AAQ6Db,EAAAA,WAAAA,CAAAJ,eAAA,EAAAK,YAAA,EAAAC,gBAAA,EAAAY,KAAA,EAAA;IACzD,MAAoBC,UAAA,GAAA,IAC1B,CAAAC,oBAAA,CAAAf,YAAA,EAAAC,gBAAA,CAAA;;AAKEa,MAAAA,UAAA,CAAAH,OAAA,CAAAK,SAAA,GAAAH,KAAA;;;IAGJ,MAAAI,QAAA,GAAAtB,eAAA,EAAA;AACD,IAAA,OAAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}