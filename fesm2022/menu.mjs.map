{"version":3,"file":"menu.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/menu-group.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/menu-stack.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/menu-trigger-base.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/menu-errors.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/menu-aim.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/event-detection.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/menu-trigger.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/menu-item.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/pointer-focus-tracker.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/menu-base.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/menu.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/menu-bar.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/menu-item-selectable.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/menu-item-radio.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/menu-item-checkbox.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/context-menu-trigger.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/menu/menu-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive} from '@angular/core';\nimport {UniqueSelectionDispatcher} from '../collections';\n\n/**\n * A grouping container for `CdkMenuItemRadio` instances, similar to a `role=\"radiogroup\"` element.\n */\n@Directive({\n  selector: '[cdkMenuGroup]',\n  exportAs: 'cdkMenuGroup',\n  host: {\n    'role': 'group',\n    'class': 'cdk-menu-group',\n  },\n  providers: [{provide: UniqueSelectionDispatcher, useClass: UniqueSelectionDispatcher}],\n})\nexport class CdkMenuGroup {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject, Injectable, InjectionToken} from '@angular/core';\nimport {_IdGenerator} from '../a11y';\nimport {Observable, Subject} from 'rxjs';\nimport {debounceTime, distinctUntilChanged, startWith} from 'rxjs/operators';\n\n/** The relative item in the inline menu to focus after closing all popup menus. */\nexport enum FocusNext {\n  nextItem,\n  previousItem,\n  currentItem,\n}\n\n/** A single item (menu) in the menu stack. */\nexport interface MenuStackItem {\n  /** A reference to the menu stack this menu stack item belongs to. */\n  menuStack?: MenuStack;\n}\n\n/** Injection token used for an implementation of MenuStack. */\nexport const MENU_STACK = new InjectionToken<MenuStack>('cdk-menu-stack');\n\n/** Provider that provides the parent menu stack, or a new menu stack if there is no parent one. */\nexport const PARENT_OR_NEW_MENU_STACK_PROVIDER = {\n  provide: MENU_STACK,\n  useFactory: () => inject(MENU_STACK, {optional: true, skipSelf: true}) || new MenuStack(),\n};\n\n/** Provider that provides the parent menu stack, or a new inline menu stack if there is no parent one. */\nexport const PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER = (\n  orientation: 'vertical' | 'horizontal',\n) => ({\n  provide: MENU_STACK,\n  useFactory: () =>\n    inject(MENU_STACK, {optional: true, skipSelf: true}) || MenuStack.inline(orientation),\n});\n\n/** Options that can be provided to the close or closeAll methods. */\nexport interface CloseOptions {\n  /** The element to focus next if the close operation causes the menu stack to become empty. */\n  focusNextOnEmpty?: FocusNext;\n  /** Whether to focus the parent trigger after closing the menu. */\n  focusParentTrigger?: boolean;\n}\n\n/** Event dispatched when a menu is closed. */\nexport interface MenuStackCloseEvent {\n  /** The menu being closed. */\n  item: MenuStackItem;\n  /** Whether to focus the parent trigger after closing the menu. */\n  focusParentTrigger?: boolean;\n}\n\n/**\n * MenuStack allows subscribers to listen for close events (when a MenuStackItem is popped off\n * of the stack) in order to perform closing actions. Upon the MenuStack being empty it emits\n * from the `empty` observable specifying the next focus action which the listener should perform\n * as requested by the closer.\n */\n@Injectable()\nexport class MenuStack {\n  /** The ID of this menu stack. */\n  readonly id = inject(_IdGenerator).getId('cdk-menu-stack-');\n\n  /** All MenuStackItems tracked by this MenuStack. */\n  private readonly _elements: MenuStackItem[] = [];\n\n  /** Emits the element which was popped off of the stack when requested by a closer. */\n  private readonly _close = new Subject<MenuStackCloseEvent>();\n\n  /** Emits once the MenuStack has become empty after popping off elements. */\n  private readonly _empty = new Subject<FocusNext | undefined>();\n\n  /** Emits whether any menu in the menu stack has focus. */\n  private readonly _hasFocus = new Subject<boolean>();\n\n  /** Observable which emits the MenuStackItem which has been requested to close. */\n  readonly closed: Observable<MenuStackCloseEvent> = this._close;\n\n  /** Observable which emits whether any menu in the menu stack has focus. */\n  readonly hasFocus: Observable<boolean> = this._hasFocus.pipe(\n    startWith(false),\n    debounceTime(0),\n    distinctUntilChanged(),\n  );\n\n  /**\n   * Observable which emits when the MenuStack is empty after popping off the last element. It\n   * emits a FocusNext event which specifies the action the closer has requested the listener\n   * perform.\n   */\n  readonly emptied: Observable<FocusNext | undefined> = this._empty;\n\n  /**\n   * Whether the inline menu associated with this menu stack is vertical or horizontal.\n   * `null` indicates there is no inline menu associated with this menu stack.\n   */\n  private _inlineMenuOrientation: 'vertical' | 'horizontal' | null = null;\n\n  /** Creates a menu stack that originates from an inline menu. */\n  static inline(orientation: 'vertical' | 'horizontal') {\n    const stack = new MenuStack();\n    stack._inlineMenuOrientation = orientation;\n    return stack;\n  }\n\n  /**\n   * Adds an item to the menu stack.\n   * @param menu the MenuStackItem to put on the stack.\n   */\n  push(menu: MenuStackItem) {\n    this._elements.push(menu);\n  }\n\n  /**\n   * Pop items off of the stack up to and including `lastItem` and emit each on the close\n   * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\n   * @param lastItem the last item to pop off the stack.\n   * @param options Options that configure behavior on close.\n   */\n  close(lastItem: MenuStackItem, options?: CloseOptions) {\n    const {focusNextOnEmpty, focusParentTrigger} = {...options};\n    if (this._elements.indexOf(lastItem) >= 0) {\n      let poppedElement;\n      do {\n        poppedElement = this._elements.pop()!;\n        this._close.next({item: poppedElement, focusParentTrigger});\n      } while (poppedElement !== lastItem);\n\n      if (this.isEmpty()) {\n        this._empty.next(focusNextOnEmpty);\n      }\n    }\n  }\n\n  /**\n   * Pop items off of the stack up to but excluding `lastItem` and emit each on the close\n   * observable. If the stack is empty or `lastItem` is not on the stack it does nothing.\n   * @param lastItem the element which should be left on the stack\n   * @return whether or not an item was removed from the stack\n   */\n  closeSubMenuOf(lastItem: MenuStackItem) {\n    let removed = false;\n    if (this._elements.indexOf(lastItem) >= 0) {\n      removed = this.peek() !== lastItem;\n      while (this.peek() !== lastItem) {\n        this._close.next({item: this._elements.pop()!});\n      }\n    }\n    return removed;\n  }\n\n  /**\n   * Pop off all MenuStackItems and emit each one on the `close` observable one by one.\n   * @param options Options that configure behavior on close.\n   */\n  closeAll(options?: CloseOptions) {\n    const {focusNextOnEmpty, focusParentTrigger} = {...options};\n    if (!this.isEmpty()) {\n      while (!this.isEmpty()) {\n        const menuStackItem = this._elements.pop();\n        if (menuStackItem) {\n          this._close.next({item: menuStackItem, focusParentTrigger});\n        }\n      }\n      this._empty.next(focusNextOnEmpty);\n    }\n  }\n\n  /** Return true if this stack is empty. */\n  isEmpty() {\n    return !this._elements.length;\n  }\n\n  /** Return the length of the stack. */\n  length() {\n    return this._elements.length;\n  }\n\n  /** Get the top most element on the stack. */\n  peek(): MenuStackItem | undefined {\n    return this._elements[this._elements.length - 1];\n  }\n\n  /** Whether the menu stack is associated with an inline menu. */\n  hasInlineMenu() {\n    return this._inlineMenuOrientation != null;\n  }\n\n  /** The orientation of the associated inline menu. */\n  inlineMenuOrientation() {\n    return this._inlineMenuOrientation;\n  }\n\n  /** Sets whether the menu stack contains the focused element. */\n  setHasFocus(hasFocus: boolean) {\n    this._hasFocus.next(hasFocus);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Directive,\n  EventEmitter,\n  inject,\n  Injectable,\n  InjectionToken,\n  Injector,\n  OnDestroy,\n  TemplateRef,\n  ViewContainerRef,\n} from '@angular/core';\nimport {Menu} from './menu-interface';\nimport {MENU_STACK, MenuStack} from './menu-stack';\nimport {\n  ConnectedPosition,\n  createRepositionScrollStrategy,\n  OverlayRef,\n  ScrollStrategy,\n} from '../overlay';\nimport {TemplatePortal} from '../portal';\nimport {merge, Subject} from 'rxjs';\n\n/** Injection token used for an implementation of MenuStack. */\nexport const MENU_TRIGGER = new InjectionToken<CdkMenuTriggerBase>('cdk-menu-trigger');\n\n/** Injection token used to configure the behavior of the menu when the page is scrolled. */\nexport const MENU_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'cdk-menu-scroll-strategy',\n  {\n    providedIn: 'root',\n    factory: () => {\n      const injector = inject(Injector);\n      return () => createRepositionScrollStrategy(injector);\n    },\n  },\n);\n\n/** Tracks the last open menu trigger across the entire application. */\n@Injectable({providedIn: 'root'})\nexport class MenuTracker {\n  /** The last open menu trigger. */\n  private static _openMenuTrigger?: CdkMenuTriggerBase;\n\n  /**\n   * Close the previous open menu and set the given one as being open.\n   * @param trigger The trigger for the currently open Menu.\n   */\n  update(trigger: CdkMenuTriggerBase) {\n    if (MenuTracker._openMenuTrigger !== trigger) {\n      MenuTracker._openMenuTrigger?.close();\n      MenuTracker._openMenuTrigger = trigger;\n    }\n  }\n}\n\n/**\n * Abstract directive that implements shared logic common to all menu triggers.\n * This class can be extended to create custom menu trigger types.\n */\n@Directive({\n  host: {\n    '[attr.aria-controls]': 'childMenu?.id',\n    '[attr.data-cdk-menu-stack-id]': 'menuStack.id',\n  },\n})\nexport abstract class CdkMenuTriggerBase implements OnDestroy {\n  /** The DI injector for this component. */\n  readonly injector = inject(Injector);\n\n  /** The view container ref for this component */\n  protected readonly viewContainerRef = inject(ViewContainerRef);\n\n  /** The menu stack in which this menu resides. */\n  protected readonly menuStack: MenuStack = inject(MENU_STACK);\n\n  /** Function used to configure the scroll strategy for the menu. */\n  protected readonly menuScrollStrategy = inject(MENU_SCROLL_STRATEGY);\n\n  /**\n   * A list of preferred menu positions to be used when constructing the\n   * `FlexibleConnectedPositionStrategy` for this trigger's menu.\n   */\n  menuPosition: ConnectedPosition[];\n\n  /** Emits when the attached menu is requested to open */\n  readonly opened: EventEmitter<void> = new EventEmitter();\n\n  /** Emits when the attached menu is requested to close */\n  readonly closed: EventEmitter<void> = new EventEmitter();\n\n  /** Template reference variable to the menu this trigger opens */\n  menuTemplateRef: TemplateRef<unknown> | null;\n\n  /** Context data to be passed along to the menu template */\n  menuData: unknown;\n\n  /** Close the opened menu. */\n  abstract close(): void;\n\n  /** A reference to the overlay which manages the triggered menu */\n  protected overlayRef: OverlayRef | null = null;\n\n  /** Emits when this trigger is destroyed. */\n  protected readonly destroyed: Subject<void> = new Subject();\n\n  /** Emits when the outside pointer events listener on the overlay should be stopped. */\n  protected readonly stopOutsideClicksListener = merge(this.closed, this.destroyed);\n\n  /** The child menu opened by this trigger. */\n  protected childMenu?: Menu;\n\n  /** The content of the menu panel opened by this trigger. */\n  private _menuPortal: TemplatePortal;\n\n  /** The injector to use for the child menu opened by this trigger. */\n  private _childMenuInjector?: Injector;\n\n  ngOnDestroy() {\n    this._destroyOverlay();\n\n    this.destroyed.next();\n    this.destroyed.complete();\n  }\n\n  /** Whether the attached menu is open. */\n  isOpen() {\n    return !!this.overlayRef?.hasAttached();\n  }\n\n  /** Registers a child menu as having been opened by this trigger. */\n  registerChildMenu(child: Menu) {\n    this.childMenu = child;\n  }\n\n  /**\n   * Get the portal to be attached to the overlay which contains the menu. Allows for the menu\n   * content to change dynamically and be reflected in the application.\n   */\n  protected getMenuContentPortal() {\n    const hasMenuContentChanged = this.menuTemplateRef !== this._menuPortal?.templateRef;\n    if (this.menuTemplateRef && (!this._menuPortal || hasMenuContentChanged)) {\n      this._menuPortal = new TemplatePortal(\n        this.menuTemplateRef,\n        this.viewContainerRef,\n        this.menuData,\n        this._getChildMenuInjector(),\n      );\n    }\n\n    return this._menuPortal;\n  }\n\n  /**\n   * Whether the given element is inside the scope of this trigger's menu stack.\n   * @param element The element to check.\n   * @return Whether the element is inside the scope of this trigger's menu stack.\n   */\n  protected isElementInsideMenuStack(element: Element) {\n    for (let el: Element | null = element; el; el = el?.parentElement ?? null) {\n      if (el.getAttribute('data-cdk-menu-stack-id') === this.menuStack.id) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** Destroy and unset the overlay reference it if exists */\n  private _destroyOverlay() {\n    if (this.overlayRef) {\n      this.overlayRef.dispose();\n      this.overlayRef = null;\n    }\n  }\n\n  /** Gets the injector to use when creating a child menu. */\n  private _getChildMenuInjector() {\n    this._childMenuInjector =\n      this._childMenuInjector ||\n      Injector.create({\n        providers: [\n          {provide: MENU_TRIGGER, useValue: this},\n          {provide: MENU_STACK, useValue: this.menuStack},\n        ],\n        parent: this.injector,\n      });\n    return this._childMenuInjector;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * Throws an exception when an instance of the PointerFocusTracker is not provided.\n * @docs-private\n */\nexport function throwMissingPointerFocusTracker() {\n  throw Error('expected an instance of PointerFocusTracker to be provided');\n}\n\n/**\n * Throws an exception when a reference to the parent menu is not provided.\n * @docs-private\n */\nexport function throwMissingMenuReference() {\n  throw Error('expected a reference to the parent menu');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Directive,\n  inject,\n  Injectable,\n  InjectionToken,\n  NgZone,\n  OnDestroy,\n  RendererFactory2,\n} from '@angular/core';\nimport {Subject} from 'rxjs';\nimport {FocusableElement, PointerFocusTracker} from './pointer-focus-tracker';\nimport {Menu} from './menu-interface';\nimport {throwMissingMenuReference, throwMissingPointerFocusTracker} from './menu-errors';\n\n/**\n * MenuAim is responsible for determining if a sibling menuitem's menu should be closed when a\n * Toggler item is hovered into. It is up to the hovered in item to call the MenuAim service in\n * order to determine if it may perform its close actions.\n */\nexport interface MenuAim {\n  /**\n   * Set the Menu and its PointerFocusTracker.\n   * @param menu The menu that this menu aim service controls.\n   * @param pointerTracker The `PointerFocusTracker` for the given menu.\n   */\n  initialize(menu: Menu, pointerTracker: PointerFocusTracker<FocusableElement & Toggler>): void;\n\n  /**\n   * Calls the `doToggle` callback when it is deemed that the user is not moving towards\n   * the submenu.\n   * @param doToggle the function called when the user is not moving towards the submenu.\n   */\n  toggle(doToggle: () => void): void;\n}\n\n/** Injection token used for an implementation of MenuAim. */\nexport const MENU_AIM = new InjectionToken<MenuAim>('cdk-menu-aim');\n\n/** Capture every nth mouse move event. */\nconst MOUSE_MOVE_SAMPLE_FREQUENCY = 3;\n\n/** The number of mouse move events to track. */\nconst NUM_POINTS = 5;\n\n/**\n * How long to wait before closing a sibling menu if a user stops short of the submenu they were\n * predicted to go into.\n */\nconst CLOSE_DELAY = 300;\n\n/** An element which when hovered over may open or close a menu. */\nexport interface Toggler {\n  /** Gets the open menu, or undefined if no menu is open. */\n  getMenu(): Menu | undefined;\n}\n\n/** Calculate the slope between point a and b. */\nfunction getSlope(a: Point, b: Point) {\n  return (b.y - a.y) / (b.x - a.x);\n}\n\n/** Calculate the y intercept for the given point and slope. */\nfunction getYIntercept(point: Point, slope: number) {\n  return point.y - slope * point.x;\n}\n\n/** Represents a coordinate of mouse travel. */\ntype Point = {x: number; y: number};\n\n/**\n * Whether the given mouse trajectory line defined by the slope and y intercept falls within the\n * submenu as defined by `submenuPoints`\n * @param submenuPoints the submenu DOMRect points.\n * @param m the slope of the trajectory line.\n * @param b the y intercept of the trajectory line.\n * @return true if any point on the line falls within the submenu.\n */\nfunction isWithinSubmenu(submenuPoints: DOMRect, m: number, b: number) {\n  const {left, right, top, bottom} = submenuPoints;\n\n  // Check for intersection with each edge of the submenu (left, right, top, bottom)\n  // by fixing one coordinate to that edge's coordinate (either x or y) and checking if the\n  // other coordinate is within bounds.\n  return (\n    (m * left + b >= top && m * left + b <= bottom) ||\n    (m * right + b >= top && m * right + b <= bottom) ||\n    ((top - b) / m >= left && (top - b) / m <= right) ||\n    ((bottom - b) / m >= left && (bottom - b) / m <= right)\n  );\n}\n\n/**\n * TargetMenuAim predicts if a user is moving into a submenu. It calculates the\n * trajectory of the user's mouse movement in the current menu to determine if the\n * mouse is moving towards an open submenu.\n *\n * The determination is made by calculating the slope of the users last NUM_POINTS moves where each\n * pair of points determines if the trajectory line points into the submenu. It uses consensus\n * approach by checking if at least NUM_POINTS / 2 pairs determine that the user is moving towards\n * to submenu.\n */\n@Injectable()\nexport class TargetMenuAim implements MenuAim, OnDestroy {\n  private readonly _ngZone = inject(NgZone);\n  private readonly _renderer = inject(RendererFactory2).createRenderer(null, null);\n  private _cleanupMousemove: (() => void) | undefined;\n\n  /** The last NUM_POINTS mouse move events. */\n  private readonly _points: Point[] = [];\n\n  /** Reference to the root menu in which we are tracking mouse moves. */\n  private _menu: Menu;\n\n  /** Reference to the root menu's mouse manager. */\n  private _pointerTracker: PointerFocusTracker<Toggler & FocusableElement>;\n\n  /** The id associated with the current timeout call waiting to resolve. */\n  private _timeoutId: number | null;\n\n  /** Emits when this service is destroyed. */\n  private readonly _destroyed: Subject<void> = new Subject();\n\n  ngOnDestroy() {\n    this._cleanupMousemove?.();\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /**\n   * Set the Menu and its PointerFocusTracker.\n   * @param menu The menu that this menu aim service controls.\n   * @param pointerTracker The `PointerFocusTracker` for the given menu.\n   */\n  initialize(menu: Menu, pointerTracker: PointerFocusTracker<FocusableElement & Toggler>) {\n    this._menu = menu;\n    this._pointerTracker = pointerTracker;\n    this._subscribeToMouseMoves();\n  }\n\n  /**\n   * Calls the `doToggle` callback when it is deemed that the user is not moving towards\n   * the submenu.\n   * @param doToggle the function called when the user is not moving towards the submenu.\n   */\n  toggle(doToggle: () => void) {\n    // If the menu is horizontal the sub-menus open below and there is no risk of premature\n    // closing of any sub-menus therefore we automatically resolve the callback.\n    if (this._menu.orientation === 'horizontal') {\n      doToggle();\n    }\n\n    this._checkConfigured();\n\n    const siblingItemIsWaiting = !!this._timeoutId;\n    const hasPoints = this._points.length > 1;\n\n    if (hasPoints && !siblingItemIsWaiting) {\n      if (this._isMovingToSubmenu()) {\n        this._startTimeout(doToggle);\n      } else {\n        doToggle();\n      }\n    } else if (!siblingItemIsWaiting) {\n      doToggle();\n    }\n  }\n\n  /**\n   * Start the delayed toggle handler if one isn't running already.\n   *\n   * The delayed toggle handler executes the `doToggle` callback after some period of time iff the\n   * users mouse is on an item in the current menu.\n   *\n   * @param doToggle the function called when the user is not moving towards the submenu.\n   */\n  private _startTimeout(doToggle: () => void) {\n    // If the users mouse is moving towards a submenu we don't want to immediately resolve.\n    // Wait for some period of time before determining if the previous menu should close in\n    // cases where the user may have moved towards the submenu but stopped on a sibling menu\n    // item intentionally.\n    const timeoutId = setTimeout(() => {\n      // Resolve if the user is currently moused over some element in the root menu\n      if (this._pointerTracker!.activeElement && timeoutId === this._timeoutId) {\n        doToggle();\n      }\n      this._timeoutId = null;\n    }, CLOSE_DELAY) as any as number;\n\n    this._timeoutId = timeoutId;\n  }\n\n  /** Whether the user is heading towards the open submenu. */\n  private _isMovingToSubmenu() {\n    const submenuPoints = this._getSubmenuBounds();\n    if (!submenuPoints) {\n      return false;\n    }\n\n    let numMoving = 0;\n    const currPoint = this._points[this._points.length - 1];\n    // start from the second last point and calculate the slope between each point and the last\n    // point.\n    for (let i = this._points.length - 2; i >= 0; i--) {\n      const previous = this._points[i];\n      const slope = getSlope(currPoint, previous);\n      if (isWithinSubmenu(submenuPoints, slope, getYIntercept(currPoint, slope))) {\n        numMoving++;\n      }\n    }\n    return numMoving >= Math.floor(NUM_POINTS / 2);\n  }\n\n  /** Get the bounding DOMRect for the open submenu. */\n  private _getSubmenuBounds(): DOMRect | undefined {\n    return this._pointerTracker?.previousElement?.getMenu()?.nativeElement.getBoundingClientRect();\n  }\n\n  /**\n   * Check if a reference to the PointerFocusTracker and menu element is provided.\n   * @throws an error if neither reference is provided.\n   */\n  private _checkConfigured() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._pointerTracker) {\n        throwMissingPointerFocusTracker();\n      }\n      if (!this._menu) {\n        throwMissingMenuReference();\n      }\n    }\n  }\n\n  /** Subscribe to the root menus mouse move events and update the tracked mouse points. */\n  private _subscribeToMouseMoves() {\n    this._cleanupMousemove?.();\n\n    this._cleanupMousemove = this._ngZone.runOutsideAngular(() => {\n      let eventIndex = 0;\n\n      return this._renderer.listen(this._menu.nativeElement, 'mousemove', (event: MouseEvent) => {\n        if (eventIndex % MOUSE_MOVE_SAMPLE_FREQUENCY === 0) {\n          this._points.push({x: event.clientX, y: event.clientY});\n          if (this._points.length > NUM_POINTS) {\n            this._points.shift();\n          }\n        }\n        eventIndex++;\n      });\n    });\n  }\n}\n\n/**\n * CdkTargetMenuAim is a provider for the TargetMenuAim service. It can be added to an\n * element with either the `cdkMenu` or `cdkMenuBar` directive and child menu items.\n */\n@Directive({\n  selector: '[cdkTargetMenuAim]',\n  exportAs: 'cdkTargetMenuAim',\n  providers: [{provide: MENU_AIM, useClass: TargetMenuAim}],\n})\nexport class CdkTargetMenuAim {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ElementRef} from '@angular/core';\nimport {ENTER, SPACE} from '../keycodes';\n\n/** Checks whether a keyboard event will trigger a native `click` event on an element. */\nexport function eventDispatchesNativeClick(\n  elementRef: ElementRef<HTMLElement>,\n  event: KeyboardEvent,\n): boolean {\n  // Synthetic events won't trigger clicks.\n  if (!event.isTrusted) {\n    return false;\n  }\n\n  const el = elementRef.nativeElement;\n  const keyCode = event.keyCode;\n\n  // Buttons trigger clicks both on space and enter events.\n  if (el.nodeName === 'BUTTON' && !(el as HTMLButtonElement).disabled) {\n    return keyCode === ENTER || keyCode === SPACE;\n  }\n\n  // Links only trigger clicks on enter.\n  if (el.nodeName === 'A') {\n    return keyCode === ENTER;\n  }\n\n  // Any other elements won't dispatch clicks from keyboard events.\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ChangeDetectorRef,\n  Directive,\n  ElementRef,\n  inject,\n  Injector,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Renderer2,\n  SimpleChanges,\n} from '@angular/core';\nimport {InputModalityDetector} from '../a11y';\nimport {Directionality} from '../bidi';\nimport {\n  ConnectedPosition,\n  createFlexibleConnectedPositionStrategy,\n  createOverlayRef,\n  FlexibleConnectedPositionStrategy,\n  OverlayConfig,\n  STANDARD_DROPDOWN_ADJACENT_POSITIONS,\n  STANDARD_DROPDOWN_BELOW_POSITIONS,\n} from '../overlay';\nimport {\n  DOWN_ARROW,\n  ENTER,\n  hasModifierKey,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n  SPACE,\n  UP_ARROW,\n} from '../keycodes';\nimport {_getEventTarget} from '../platform';\nimport {takeUntil} from 'rxjs/operators';\nimport {CDK_MENU, Menu} from './menu-interface';\nimport {PARENT_OR_NEW_MENU_STACK_PROVIDER} from './menu-stack';\nimport {MENU_AIM} from './menu-aim';\nimport {CdkMenuTriggerBase, MENU_TRIGGER, MenuTracker} from './menu-trigger-base';\nimport {eventDispatchesNativeClick} from './event-detection';\n\n/**\n * A directive that turns its host element into a trigger for a popup menu.\n * It can be combined with cdkMenuItem to create sub-menus. If the element is in a top level\n * MenuBar it will open the menu on click, or if a sibling is already opened it will open on hover.\n * If it is inside of a Menu it will open the attached Submenu on hover regardless of its sibling\n * state.\n */\n@Directive({\n  selector: '[cdkMenuTriggerFor]',\n  exportAs: 'cdkMenuTriggerFor',\n  host: {\n    'class': 'cdk-menu-trigger',\n    '[attr.aria-haspopup]': 'menuTemplateRef ? \"menu\" : null',\n    '[attr.aria-expanded]': 'menuTemplateRef == null ? null : isOpen()',\n    '(focusin)': '_setHasFocus(true)',\n    '(focusout)': '_setHasFocus(false)',\n    '(keydown)': '_toggleOnKeydown($event)',\n    '(click)': '_handleClick()',\n  },\n  inputs: [\n    {name: 'menuTemplateRef', alias: 'cdkMenuTriggerFor'},\n    {name: 'menuPosition', alias: 'cdkMenuPosition'},\n    {name: 'menuData', alias: 'cdkMenuTriggerData'},\n  ],\n  outputs: ['opened: cdkMenuOpened', 'closed: cdkMenuClosed'],\n  providers: [\n    {provide: MENU_TRIGGER, useExisting: CdkMenuTrigger},\n    PARENT_OR_NEW_MENU_STACK_PROVIDER,\n  ],\n})\nexport class CdkMenuTrigger extends CdkMenuTriggerBase implements OnChanges, OnDestroy {\n  private readonly _elementRef: ElementRef<HTMLElement> = inject(ElementRef);\n  private readonly _ngZone = inject(NgZone);\n  private readonly _changeDetectorRef = inject(ChangeDetectorRef);\n  private readonly _inputModalityDetector = inject(InputModalityDetector);\n  private readonly _directionality = inject(Directionality, {optional: true});\n  private readonly _renderer = inject(Renderer2);\n  private readonly _injector = inject(Injector);\n  private _cleanupMouseenter: () => void;\n\n  /** The app's menu tracking registry */\n  private readonly _menuTracker = inject(MenuTracker);\n\n  /** The parent menu this trigger belongs to. */\n  private readonly _parentMenu = inject(CDK_MENU, {optional: true});\n\n  /** The menu aim service used by this menu. */\n  private readonly _menuAim = inject(MENU_AIM, {optional: true});\n\n  constructor() {\n    super();\n    this._setRole();\n    this._registerCloseHandler();\n    this._subscribeToMenuStackClosed();\n    this._subscribeToMouseEnter();\n    this._subscribeToMenuStackHasFocus();\n    this._setType();\n  }\n\n  /** Toggle the attached menu. */\n  toggle() {\n    this.isOpen() ? this.close() : this.open();\n  }\n\n  /** Open the attached menu. */\n  open() {\n    if (!this._parentMenu) {\n      this._menuTracker.update(this);\n    }\n    if (!this.isOpen() && this.menuTemplateRef != null) {\n      this.opened.next();\n\n      this.overlayRef =\n        this.overlayRef || createOverlayRef(this._injector, this._getOverlayConfig());\n      this.overlayRef.attach(this.getMenuContentPortal());\n      this._changeDetectorRef.markForCheck();\n      this._subscribeToOutsideClicks();\n    }\n  }\n\n  /** Close the opened menu. */\n  close() {\n    if (this.isOpen()) {\n      this.closed.next();\n\n      this.overlayRef!.detach();\n      this._changeDetectorRef.markForCheck();\n    }\n    this._closeSiblingTriggers();\n  }\n\n  /**\n   * Get a reference to the rendered Menu if the Menu is open and rendered in the DOM.\n   */\n  getMenu(): Menu | undefined {\n    return this.childMenu;\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes['menuPosition'] && this.overlayRef) {\n      this.overlayRef.updatePositionStrategy(this._getOverlayPositionStrategy());\n    }\n  }\n\n  override ngOnDestroy(): void {\n    this._cleanupMouseenter();\n    super.ngOnDestroy();\n  }\n\n  /**\n   * Handles keyboard events for the menu item.\n   * @param event The keyboard event to handle\n   */\n  _toggleOnKeydown(event: KeyboardEvent) {\n    const isParentVertical = this._parentMenu?.orientation === 'vertical';\n    switch (event.keyCode) {\n      case SPACE:\n      case ENTER:\n        // Skip events that will trigger clicks so the handler doesn't get triggered twice.\n        if (!hasModifierKey(event) && !eventDispatchesNativeClick(this._elementRef, event)) {\n          this.toggle();\n          this.childMenu?.focusFirstItem('keyboard');\n        }\n        break;\n\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && isParentVertical && this._directionality?.value !== 'rtl') {\n            event.preventDefault();\n            this.open();\n            this.childMenu?.focusFirstItem('keyboard');\n          }\n        }\n        break;\n\n      case LEFT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && isParentVertical && this._directionality?.value === 'rtl') {\n            event.preventDefault();\n            this.open();\n            this.childMenu?.focusFirstItem('keyboard');\n          }\n        }\n        break;\n\n      case DOWN_ARROW:\n      case UP_ARROW:\n        if (!hasModifierKey(event)) {\n          if (!isParentVertical) {\n            event.preventDefault();\n            this.open();\n            event.keyCode === DOWN_ARROW\n              ? this.childMenu?.focusFirstItem('keyboard')\n              : this.childMenu?.focusLastItem('keyboard');\n          }\n        }\n        break;\n    }\n  }\n\n  /** Handles clicks on the menu trigger. */\n  _handleClick() {\n    this.toggle();\n    this.childMenu?.focusFirstItem('mouse');\n  }\n\n  /**\n   * Sets whether the trigger's menu stack has focus.\n   * @param hasFocus Whether the menu stack has focus.\n   */\n  _setHasFocus(hasFocus: boolean) {\n    if (!this._parentMenu) {\n      this.menuStack.setHasFocus(hasFocus);\n    }\n  }\n\n  /**\n   * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\n   * into.\n   */\n  private _subscribeToMouseEnter() {\n    this._cleanupMouseenter = this._ngZone.runOutsideAngular(() => {\n      return this._renderer.listen(this._elementRef.nativeElement, 'mouseenter', () => {\n        if (\n          // Skip fake `mouseenter` events dispatched by touch devices.\n          this._inputModalityDetector.mostRecentModality !== 'touch' &&\n          !this.menuStack.isEmpty() &&\n          !this.isOpen()\n        ) {\n          // Closes any sibling menu items and opens the menu associated with this trigger.\n          const toggleMenus = () =>\n            this._ngZone.run(() => {\n              this._closeSiblingTriggers();\n              this.open();\n            });\n\n          if (this._menuAim) {\n            this._menuAim.toggle(toggleMenus);\n          } else {\n            toggleMenus();\n          }\n        }\n      });\n    });\n  }\n\n  /** Close out any sibling menu trigger menus. */\n  private _closeSiblingTriggers() {\n    if (this._parentMenu) {\n      // If nothing was removed from the stack and the last element is not the parent item\n      // that means that the parent menu is a menu bar since we don't put the menu bar on the\n      // stack\n      const isParentMenuBar =\n        !this.menuStack.closeSubMenuOf(this._parentMenu) &&\n        this.menuStack.peek() !== this._parentMenu;\n\n      if (isParentMenuBar) {\n        this.menuStack.closeAll();\n      }\n    } else {\n      this.menuStack.closeAll();\n    }\n  }\n\n  /** Get the configuration object used to create the overlay. */\n  private _getOverlayConfig() {\n    return new OverlayConfig({\n      positionStrategy: this._getOverlayPositionStrategy(),\n      scrollStrategy: this.menuScrollStrategy(),\n      direction: this._directionality || undefined,\n    });\n  }\n\n  /** Build the position strategy for the overlay which specifies where to place the menu. */\n  private _getOverlayPositionStrategy(): FlexibleConnectedPositionStrategy {\n    return createFlexibleConnectedPositionStrategy(this._injector, this._elementRef)\n      .withLockedPosition()\n      .withFlexibleDimensions(false)\n      .withPositions(this._getOverlayPositions());\n  }\n\n  /** Get the preferred positions for the opened menu relative to the menu item. */\n  private _getOverlayPositions(): ConnectedPosition[] {\n    return (\n      this.menuPosition ??\n      (!this._parentMenu || this._parentMenu.orientation === 'horizontal'\n        ? STANDARD_DROPDOWN_BELOW_POSITIONS\n        : STANDARD_DROPDOWN_ADJACENT_POSITIONS)\n    );\n  }\n\n  /**\n   * Subscribe to the MenuStack close events if this is a standalone trigger and close out the menu\n   * this triggers when requested.\n   */\n  private _registerCloseHandler() {\n    if (!this._parentMenu) {\n      this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({item}) => {\n        if (item === this.childMenu) {\n          this.close();\n        }\n      });\n    }\n  }\n\n  /**\n   * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\n   * click occurs outside the menus.\n   */\n  private _subscribeToOutsideClicks() {\n    if (this.overlayRef) {\n      this.overlayRef\n        .outsidePointerEvents()\n        .pipe(takeUntil(this.stopOutsideClicksListener))\n        .subscribe(event => {\n          const target = _getEventTarget(event) as Element;\n          const element = this._elementRef.nativeElement;\n\n          if (target !== element && !element.contains(target)) {\n            if (!this.isElementInsideMenuStack(target)) {\n              this.menuStack.closeAll();\n            } else {\n              this._closeSiblingTriggers();\n            }\n          }\n        });\n    }\n  }\n\n  /** Subscribe to the MenuStack hasFocus events. */\n  private _subscribeToMenuStackHasFocus() {\n    if (!this._parentMenu) {\n      this.menuStack.hasFocus.pipe(takeUntil(this.destroyed)).subscribe(hasFocus => {\n        if (!hasFocus) {\n          this.menuStack.closeAll();\n        }\n      });\n    }\n  }\n\n  /** Subscribe to the MenuStack closed events. */\n  private _subscribeToMenuStackClosed() {\n    if (!this._parentMenu) {\n      this.menuStack.closed.subscribe(({focusParentTrigger}) => {\n        if (focusParentTrigger && !this.menuStack.length()) {\n          this._elementRef.nativeElement.focus();\n        }\n      });\n    }\n  }\n\n  /** Sets the role attribute for this trigger if needed. */\n  private _setRole() {\n    // If this trigger is part of another menu, the cdkMenuItem directive will handle setting the\n    // role, otherwise this is a standalone trigger, and we should ensure it has role=\"button\".\n    if (!this._parentMenu) {\n      this._elementRef.nativeElement.setAttribute('role', 'button');\n    }\n  }\n\n  /** Sets thte `type` attribute of the trigger. */\n  private _setType() {\n    const element = this._elementRef.nativeElement;\n\n    if (element.nodeName === 'BUTTON' && !element.getAttribute('type')) {\n      // Prevents form submissions.\n      element.setAttribute('type', 'button');\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  booleanAttribute,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  inject,\n  Input,\n  NgZone,\n  OnDestroy,\n  Output,\n  Renderer2,\n} from '@angular/core';\nimport {FocusableOption, InputModalityDetector} from '../a11y';\nimport {ENTER, hasModifierKey, LEFT_ARROW, RIGHT_ARROW, SPACE} from '../keycodes';\nimport {Directionality} from '../bidi';\nimport {Subject} from 'rxjs';\nimport {CdkMenuTrigger} from './menu-trigger';\nimport {CDK_MENU, Menu} from './menu-interface';\nimport {FocusNext, MENU_STACK} from './menu-stack';\nimport {FocusableElement} from './pointer-focus-tracker';\nimport {MENU_AIM, Toggler} from './menu-aim';\nimport {eventDispatchesNativeClick} from './event-detection';\n\n/**\n * Directive which provides the ability for an element to be focused and navigated to using the\n * keyboard when residing in a CdkMenu, CdkMenuBar, or CdkMenuGroup. It performs user defined\n * behavior when clicked.\n */\n@Directive({\n  selector: '[cdkMenuItem]',\n  exportAs: 'cdkMenuItem',\n  host: {\n    'role': 'menuitem',\n    'class': 'cdk-menu-item',\n    '[class.cdk-menu-item-disabled]': 'disabled',\n    '[tabindex]': '_tabindex',\n    '[attr.aria-disabled]': 'disabled || null',\n    '(blur)': '_resetTabIndex()',\n    '(focus)': '_setTabIndex()',\n    '(click)': '_handleClick($event)',\n    '(keydown)': '_onKeydown($event)',\n  },\n})\nexport class CdkMenuItem implements FocusableOption, FocusableElement, Toggler, OnDestroy {\n  protected readonly _dir = inject(Directionality, {optional: true});\n  readonly _elementRef: ElementRef<HTMLElement> = inject(ElementRef);\n  protected _ngZone = inject(NgZone);\n  private readonly _inputModalityDetector = inject(InputModalityDetector);\n  private readonly _renderer = inject(Renderer2);\n  private _cleanupMouseEnter: (() => void) | undefined;\n\n  /** The menu aim service used by this menu. */\n  private readonly _menuAim = inject(MENU_AIM, {optional: true});\n\n  /** The stack of menus this menu belongs to. */\n  private readonly _menuStack = inject(MENU_STACK);\n\n  /** The parent menu in which this menuitem resides. */\n  readonly _parentMenu = inject(CDK_MENU, {optional: true});\n\n  /** Reference to the CdkMenuItemTrigger directive if one is added to the same element */\n  private readonly _menuTrigger = inject(CdkMenuTrigger, {optional: true, self: true});\n\n  /**  Whether the CdkMenuItem is disabled - defaults to false */\n  @Input({alias: 'cdkMenuItemDisabled', transform: booleanAttribute}) disabled: boolean = false;\n\n  /**\n   * The text used to locate this item during menu typeahead. If not specified,\n   * the `textContent` of the item will be used.\n   */\n  @Input('cdkMenuitemTypeaheadLabel') typeaheadLabel: string | null;\n\n  /**\n   * If this MenuItem is a regular MenuItem, outputs when it is triggered by a keyboard or mouse\n   * event.\n   */\n  @Output('cdkMenuItemTriggered') readonly triggered: EventEmitter<void> = new EventEmitter();\n\n  /** Whether the menu item opens a menu. */\n  get hasMenu() {\n    return this._menuTrigger?.menuTemplateRef != null;\n  }\n\n  /**\n   * The tabindex for this menu item managed internally and used for implementing roving a\n   * tab index.\n   */\n  _tabindex: 0 | -1 = -1;\n\n  /** Whether the item should close the menu if triggered by the spacebar. */\n  protected closeOnSpacebarTrigger = true;\n\n  /** Emits when the menu item is destroyed. */\n  protected readonly destroyed = new Subject<void>();\n\n  constructor() {\n    this._setupMouseEnter();\n    this._setType();\n\n    if (this._isStandaloneItem()) {\n      this._tabindex = 0;\n    }\n  }\n\n  ngOnDestroy() {\n    this._cleanupMouseEnter?.();\n    this.destroyed.next();\n    this.destroyed.complete();\n  }\n\n  /** Place focus on the element. */\n  focus() {\n    this._elementRef.nativeElement.focus();\n  }\n\n  /**\n   * If the menu item is not disabled and the element does not have a menu trigger attached, emit\n   * on the cdkMenuItemTriggered emitter and close all open menus.\n   * @param options Options the configure how the item is triggered\n   *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n   */\n  trigger(options?: {keepOpen: boolean}) {\n    const {keepOpen} = {...options};\n    if (!this.disabled && !this.hasMenu) {\n      this.triggered.next();\n      if (!keepOpen) {\n        this._menuStack.closeAll({focusParentTrigger: true});\n      }\n    }\n  }\n\n  /** Return true if this MenuItem has an attached menu and it is open. */\n  isMenuOpen() {\n    return !!this._menuTrigger?.isOpen();\n  }\n\n  /**\n   * Get a reference to the rendered Menu if the Menu is open and it is visible in the DOM.\n   * @return the menu if it is open, otherwise undefined.\n   */\n  getMenu(): Menu | undefined {\n    return this._menuTrigger?.getMenu();\n  }\n\n  /** Get the CdkMenuTrigger associated with this element. */\n  getMenuTrigger(): CdkMenuTrigger | null {\n    return this._menuTrigger;\n  }\n\n  /** Get the label for this element which is required by the FocusableOption interface. */\n  getLabel(): string {\n    return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || '';\n  }\n\n  /** Reset the tabindex to -1. */\n  _resetTabIndex() {\n    if (!this._isStandaloneItem()) {\n      this._tabindex = -1;\n    }\n  }\n\n  /**\n   * Set the tab index to 0 if not disabled and it's a focus event, or a mouse enter if this element\n   * is not in a menu bar.\n   */\n  _setTabIndex(event?: MouseEvent) {\n    if (this.disabled) {\n      return;\n    }\n\n    // don't set the tabindex if there are no open sibling or parent menus\n    if (!event || !this._menuStack.isEmpty()) {\n      this._tabindex = 0;\n    }\n  }\n\n  /** Handles click events on the item. */\n  protected _handleClick(event: MouseEvent) {\n    if (this.disabled) {\n      event.preventDefault();\n      event.stopPropagation();\n    } else {\n      this.trigger();\n    }\n  }\n\n  /**\n   * Handles keyboard events for the menu item, specifically either triggering the user defined\n   * callback or opening/closing the current menu based on whether the left or right arrow key was\n   * pressed.\n   * @param event the keyboard event to handle\n   */\n  _onKeydown(event: KeyboardEvent) {\n    switch (event.keyCode) {\n      case SPACE:\n      case ENTER:\n        // Skip events that will trigger clicks so the handler doesn't get triggered twice.\n        if (!hasModifierKey(event) && !eventDispatchesNativeClick(this._elementRef, event)) {\n          const nodeName = this._elementRef.nativeElement.nodeName;\n\n          // Avoid repeat events on non-native elements (see #30250). Note that we don't do this\n          // on the native elements so we don't interfere with their behavior (see #26296).\n          if (nodeName !== 'A' && nodeName !== 'BUTTON') {\n            event.preventDefault();\n          }\n\n          this.trigger({keepOpen: event.keyCode === SPACE && !this.closeOnSpacebarTrigger});\n        }\n        break;\n\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && this._isParentVertical()) {\n            if (this._dir?.value !== 'rtl') {\n              this._forwardArrowPressed(event);\n            } else {\n              this._backArrowPressed(event);\n            }\n          }\n        }\n        break;\n\n      case LEFT_ARROW:\n        if (!hasModifierKey(event)) {\n          if (this._parentMenu && this._isParentVertical()) {\n            if (this._dir?.value !== 'rtl') {\n              this._backArrowPressed(event);\n            } else {\n              this._forwardArrowPressed(event);\n            }\n          }\n        }\n        break;\n    }\n  }\n\n  /** Whether this menu item is standalone or within a menu or menu bar. */\n  private _isStandaloneItem() {\n    return !this._parentMenu;\n  }\n\n  /**\n   * Handles the user pressing the back arrow key.\n   * @param event The keyboard event.\n   */\n  private _backArrowPressed(event: KeyboardEvent) {\n    const parentMenu = this._parentMenu!;\n    if (this._menuStack.hasInlineMenu() || this._menuStack.length() > 1) {\n      event.preventDefault();\n      this._menuStack.close(parentMenu, {\n        focusNextOnEmpty:\n          this._menuStack.inlineMenuOrientation() === 'horizontal'\n            ? FocusNext.previousItem\n            : FocusNext.currentItem,\n        focusParentTrigger: true,\n      });\n    }\n  }\n\n  /**\n   * Handles the user pressing the forward arrow key.\n   * @param event The keyboard event.\n   */\n  private _forwardArrowPressed(event: KeyboardEvent) {\n    if (!this.hasMenu && this._menuStack.inlineMenuOrientation() === 'horizontal') {\n      event.preventDefault();\n      this._menuStack.closeAll({\n        focusNextOnEmpty: FocusNext.nextItem,\n        focusParentTrigger: true,\n      });\n    }\n  }\n\n  /**\n   * Subscribe to the mouseenter events and close any sibling menu items if this element is moused\n   * into.\n   */\n  private _setupMouseEnter() {\n    if (!this._isStandaloneItem()) {\n      const closeOpenSiblings = () =>\n        this._ngZone.run(() => this._menuStack.closeSubMenuOf(this._parentMenu!));\n\n      this._cleanupMouseEnter = this._ngZone.runOutsideAngular(() =>\n        this._renderer.listen(this._elementRef.nativeElement, 'mouseenter', () => {\n          // Skip fake `mouseenter` events dispatched by touch devices.\n          if (\n            this._inputModalityDetector.mostRecentModality !== 'touch' &&\n            !this._menuStack.isEmpty() &&\n            !this.hasMenu\n          ) {\n            if (this._menuAim) {\n              this._menuAim.toggle(closeOpenSiblings);\n            } else {\n              closeOpenSiblings();\n            }\n          }\n        }),\n      );\n    }\n  }\n\n  /**\n   * Return true if the enclosing parent menu is configured in a horizontal orientation, false\n   * otherwise or if no parent.\n   */\n  private _isParentVertical() {\n    return this._parentMenu?.orientation === 'vertical';\n  }\n\n  /** Sets the `type` attribute of the menu item. */\n  private _setType() {\n    const element = this._elementRef.nativeElement;\n\n    if (element.nodeName === 'BUTTON' && !element.getAttribute('type')) {\n      // Prevent form submissions.\n      element.setAttribute('type', 'button');\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ElementRef, QueryList, Renderer2} from '@angular/core';\nimport {Observable, Subject, Subscription} from 'rxjs';\nimport {startWith} from 'rxjs/operators';\n\n/** Item to track for mouse focus events. */\nexport interface FocusableElement {\n  /** A reference to the element to be tracked. */\n  _elementRef: ElementRef<HTMLElement>;\n}\n\n/**\n * PointerFocusTracker keeps track of the currently active item under mouse focus. It also has\n * observables which emit when the users mouse enters and leaves a tracked element.\n */\nexport class PointerFocusTracker<T extends FocusableElement> {\n  private _eventCleanups: (() => void)[] | undefined;\n  private _itemsSubscription: Subscription | undefined;\n\n  /** Emits when an element is moused into. */\n  readonly entered: Observable<T> = new Subject<T>();\n\n  /** Emits when an element is moused out. */\n  readonly exited: Observable<T> = new Subject<T>();\n\n  /** The element currently under mouse focus. */\n  activeElement?: T;\n\n  /** The element previously under mouse focus. */\n  previousElement?: T;\n\n  constructor(\n    private _renderer: Renderer2,\n    private readonly _items: QueryList<T>,\n  ) {\n    this._bindEvents();\n    this.entered.subscribe(element => (this.activeElement = element));\n    this.exited.subscribe(() => {\n      this.previousElement = this.activeElement;\n      this.activeElement = undefined;\n    });\n  }\n\n  /** Stop the managers listeners. */\n  destroy() {\n    this._cleanupEvents();\n    this._itemsSubscription?.unsubscribe();\n  }\n\n  /** Binds the enter/exit events on all the items. */\n  private _bindEvents() {\n    // TODO(crisbeto): this can probably be simplified by binding a single event on a parent node.\n    this._itemsSubscription = this._items.changes.pipe(startWith(this._items)).subscribe(() => {\n      this._cleanupEvents();\n      this._eventCleanups = [];\n      this._items.forEach(item => {\n        const element = item._elementRef.nativeElement;\n        this._eventCleanups!.push(\n          this._renderer.listen(element, 'mouseenter', () => {\n            (this.entered as Subject<T>).next(item);\n          }),\n          this._renderer.listen(element, 'mouseout', () => {\n            (this.exited as Subject<T>).next(item);\n          }),\n        );\n      });\n    });\n  }\n\n  /** Cleans up the currently-bound events. */\n  private _cleanupEvents() {\n    this._eventCleanups?.forEach(cleanup => cleanup());\n    this._eventCleanups = undefined;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {_IdGenerator, FocusKeyManager, FocusMonitor, FocusOrigin} from '../a11y';\nimport {Directionality} from '../bidi';\nimport {\n  AfterContentInit,\n  ContentChildren,\n  Directive,\n  ElementRef,\n  Input,\n  NgZone,\n  OnDestroy,\n  QueryList,\n  Renderer2,\n  computed,\n  inject,\n  signal,\n} from '@angular/core';\nimport {Subject, merge} from 'rxjs';\nimport {mapTo, mergeAll, mergeMap, startWith, switchMap, takeUntil} from 'rxjs/operators';\nimport {MENU_AIM} from './menu-aim';\nimport {CdkMenuGroup} from './menu-group';\nimport {Menu} from './menu-interface';\nimport {CdkMenuItem} from './menu-item';\nimport {MENU_STACK, MenuStack, MenuStackItem} from './menu-stack';\nimport {PointerFocusTracker} from './pointer-focus-tracker';\n\n/**\n * Abstract directive that implements shared logic common to all menus.\n * This class can be extended to create custom menu types.\n */\n@Directive({\n  host: {\n    'role': 'menu',\n    'class': '', // reset the css class added by the super-class\n    '[tabindex]': '_getTabIndex()',\n    '[id]': 'id',\n    '[attr.aria-orientation]': 'orientation',\n    '[attr.data-cdk-menu-stack-id]': 'menuStack.id',\n    '(focusin)': 'menuStack.setHasFocus(true)',\n    '(focusout)': 'menuStack.setHasFocus(false)',\n  },\n})\nexport abstract class CdkMenuBase\n  extends CdkMenuGroup\n  implements Menu, AfterContentInit, OnDestroy\n{\n  private _focusMonitor = inject(FocusMonitor);\n  protected ngZone = inject(NgZone);\n  private _renderer = inject(Renderer2);\n\n  /** The menu's native DOM host element. */\n  readonly nativeElement: HTMLElement = inject(ElementRef).nativeElement;\n\n  /** The stack of menus this menu belongs to. */\n  readonly menuStack: MenuStack = inject(MENU_STACK);\n\n  /** The menu aim service used by this menu. */\n  protected readonly menuAim = inject(MENU_AIM, {optional: true, self: true});\n\n  /** The directionality (text direction) of the current page. */\n  protected readonly dir = inject(Directionality, {optional: true});\n\n  /** All items inside the menu, including ones that belong to other menus. */\n  @ContentChildren(CdkMenuItem, {descendants: true})\n  protected _allItems: QueryList<CdkMenuItem>;\n\n  /** The id of the menu's host element. */\n  @Input() id: string = inject(_IdGenerator).getId('cdk-menu-');\n\n  /** All child MenuItem elements belonging to this Menu. */\n  readonly items: QueryList<CdkMenuItem> = new QueryList();\n\n  /** The direction items in the menu flow. */\n  orientation: 'horizontal' | 'vertical' = 'vertical';\n\n  /**\n   * Whether the menu is displayed inline (i.e. always present vs a conditional popup that the\n   * user triggers with a trigger element).\n   */\n  isInline = false;\n\n  /** Handles keyboard events for the menu. */\n  protected keyManager: FocusKeyManager<CdkMenuItem>;\n\n  /** Emits when the MenuBar is destroyed. */\n  protected readonly destroyed: Subject<void> = new Subject();\n\n  /** The Menu Item which triggered the open submenu. */\n  protected triggerItem?: CdkMenuItem;\n\n  /** Tracks the users mouse movements over the menu. */\n  protected pointerTracker?: PointerFocusTracker<CdkMenuItem>;\n\n  /** Whether this menu's menu stack has focus. */\n  private _menuStackHasFocus = signal(false);\n\n  private _tabIndexSignal = computed(() => {\n    const tabindexIfInline = this._menuStackHasFocus() ? -1 : 0;\n    return this.isInline ? tabindexIfInline : null;\n  });\n\n  ngAfterContentInit() {\n    if (!this.isInline) {\n      this.menuStack.push(this);\n    }\n    this._setItems();\n    this._setKeyManager();\n    this._handleFocus();\n    this._subscribeToMenuStackHasFocus();\n    this._subscribeToMenuOpen();\n    this._subscribeToMenuStackClosed();\n    this._setUpPointerTracker();\n  }\n\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this.nativeElement);\n    this.keyManager?.destroy();\n    this.destroyed.next();\n    this.destroyed.complete();\n    this.pointerTracker?.destroy();\n  }\n\n  /**\n   * Place focus on the first MenuItem in the menu and set the focus origin.\n   * @param focusOrigin The origin input mode of the focus event.\n   */\n  focusFirstItem(focusOrigin: FocusOrigin = 'program') {\n    this.keyManager.setFocusOrigin(focusOrigin);\n    this.keyManager.setFirstItemActive();\n  }\n\n  /**\n   * Place focus on the last MenuItem in the menu and set the focus origin.\n   * @param focusOrigin The origin input mode of the focus event.\n   */\n  focusLastItem(focusOrigin: FocusOrigin = 'program') {\n    this.keyManager.setFocusOrigin(focusOrigin);\n    this.keyManager.setLastItemActive();\n  }\n\n  /**\n   * Sets the active item to the item at the specified index and focuses the newly active item.\n   * @param item The index of the item to be set as active, or the CdkMenuItem instance.\n   */\n  setActiveMenuItem(item: number | CdkMenuItem) {\n    this.keyManager?.setActiveItem(item);\n  }\n\n  /** Gets the tabindex for this menu. */\n  _getTabIndex() {\n    return this._tabIndexSignal();\n  }\n\n  /**\n   * Close the open menu if the current active item opened the requested MenuStackItem.\n   * @param menu The menu requested to be closed.\n   * @param options Options to configure the behavior on close.\n   *   - `focusParentTrigger` Whether to focus the parent trigger after closing the menu.\n   */\n  protected closeOpenMenu(menu: MenuStackItem, options?: {focusParentTrigger?: boolean}) {\n    const {focusParentTrigger} = {...options};\n    const keyManager = this.keyManager;\n    const trigger = this.triggerItem;\n    if (menu === trigger?.getMenuTrigger()?.getMenu()) {\n      trigger?.getMenuTrigger()?.close();\n      // If the user has moused over a sibling item we want to focus the element under mouse focus\n      // not the trigger which previously opened the now closed menu.\n      if (focusParentTrigger) {\n        if (trigger) {\n          keyManager.setActiveItem(trigger);\n        } else {\n          keyManager.setFirstItemActive();\n        }\n      }\n    }\n  }\n\n  /** Sets up the subscription that keeps the items list in sync. */\n  private _setItems() {\n    // Since the items query has `descendants: true`, we need\n    // to filter out items belonging to a different menu.\n    this._allItems.changes\n      .pipe(startWith(this._allItems), takeUntil(this.destroyed))\n      .subscribe((items: QueryList<CdkMenuItem>) => {\n        this.items.reset(items.filter(item => item._parentMenu === this));\n        this.items.notifyOnChanges();\n      });\n  }\n\n  /** Setup the FocusKeyManager with the correct orientation for the menu. */\n  private _setKeyManager() {\n    this.keyManager = new FocusKeyManager(this.items)\n      .withWrap()\n      .withTypeAhead()\n      .withHomeAndEnd()\n      .skipPredicate(() => false);\n\n    if (this.orientation === 'horizontal') {\n      this.keyManager.withHorizontalOrientation(this.dir?.value || 'ltr');\n    } else {\n      this.keyManager.withVerticalOrientation();\n    }\n  }\n\n  /**\n   * Subscribe to the menu trigger's open events in order to track the trigger which opened the menu\n   * and stop tracking it when the menu is closed.\n   */\n  private _subscribeToMenuOpen() {\n    const exitCondition = merge(this.items.changes, this.destroyed);\n    this.items.changes\n      .pipe(\n        startWith(this.items),\n        mergeMap((list: QueryList<CdkMenuItem>) =>\n          list\n            .filter(item => item.hasMenu)\n            .map(item => item.getMenuTrigger()!.opened.pipe(mapTo(item), takeUntil(exitCondition))),\n        ),\n        mergeAll(),\n        switchMap((item: CdkMenuItem) => {\n          this.triggerItem = item;\n          return item.getMenuTrigger()!.closed;\n        }),\n        takeUntil(this.destroyed),\n      )\n      .subscribe(() => (this.triggerItem = undefined));\n  }\n\n  /** Subscribe to the MenuStack close events. */\n  private _subscribeToMenuStackClosed() {\n    this.menuStack.closed\n      .pipe(takeUntil(this.destroyed))\n      .subscribe(({item, focusParentTrigger}) => this.closeOpenMenu(item, {focusParentTrigger}));\n  }\n\n  /** Subscribe to the MenuStack hasFocus events. */\n  private _subscribeToMenuStackHasFocus() {\n    if (this.isInline) {\n      this.menuStack.hasFocus.pipe(takeUntil(this.destroyed)).subscribe(hasFocus => {\n        this._menuStackHasFocus.set(hasFocus);\n      });\n    }\n  }\n\n  /**\n   * Set the PointerFocusTracker and ensure that when mouse focus changes the key manager is updated\n   * with the latest menu item under mouse focus.\n   */\n  private _setUpPointerTracker() {\n    if (this.menuAim) {\n      this.ngZone.runOutsideAngular(() => {\n        this.pointerTracker = new PointerFocusTracker(this._renderer, this.items);\n      });\n      this.menuAim.initialize(this, this.pointerTracker!);\n    }\n  }\n\n  /** Handles focus landing on the host element of the menu. */\n  private _handleFocus() {\n    this._focusMonitor\n      .monitor(this.nativeElement, false)\n      .pipe(takeUntil(this.destroyed))\n      .subscribe(origin => {\n        // Don't forward focus on mouse interactions, because it can\n        // mess with the user's scroll position. See #30130.\n        if (origin !== null && origin !== 'mouse') {\n          this.focusFirstItem(origin);\n        }\n      });\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {AfterContentInit, Directive, EventEmitter, inject, OnDestroy, Output} from '@angular/core';\nimport {ESCAPE, hasModifierKey, LEFT_ARROW, RIGHT_ARROW, TAB} from '../keycodes';\nimport {takeUntil} from 'rxjs/operators';\nimport {CdkMenuGroup} from './menu-group';\nimport {CDK_MENU} from './menu-interface';\nimport {FocusNext, PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER} from './menu-stack';\nimport {MENU_TRIGGER} from './menu-trigger-base';\nimport {CdkMenuBase} from './menu-base';\n\n/**\n * Directive which configures the element as a Menu which should contain child elements marked as\n * CdkMenuItem or CdkMenuGroup. Sets the appropriate role and aria-attributes for a menu and\n * contains accessible keyboard and mouse handling logic.\n *\n * It also acts as a RadioGroup for elements marked with role `menuitemradio`.\n */\n@Directive({\n  selector: '[cdkMenu]',\n  exportAs: 'cdkMenu',\n  host: {\n    'role': 'menu',\n    'class': 'cdk-menu',\n    '[class.cdk-menu-inline]': 'isInline',\n    '(keydown)': '_handleKeyEvent($event)',\n  },\n  providers: [\n    {provide: CdkMenuGroup, useExisting: CdkMenu},\n    {provide: CDK_MENU, useExisting: CdkMenu},\n    PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER('vertical'),\n  ],\n})\nexport class CdkMenu extends CdkMenuBase implements AfterContentInit, OnDestroy {\n  private _parentTrigger = inject(MENU_TRIGGER, {optional: true});\n\n  /** Event emitted when the menu is closed. */\n  @Output() readonly closed: EventEmitter<void> = new EventEmitter();\n\n  /** The direction items in the menu flow. */\n  override readonly orientation = 'vertical';\n\n  /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\n  override readonly isInline = !this._parentTrigger;\n\n  constructor() {\n    super();\n    this.destroyed.subscribe(this.closed);\n    this._parentTrigger?.registerChildMenu(this);\n  }\n\n  override ngAfterContentInit() {\n    super.ngAfterContentInit();\n    this._subscribeToMenuStackEmptied();\n  }\n\n  override ngOnDestroy() {\n    super.ngOnDestroy();\n    this.closed.complete();\n  }\n\n  /**\n   * Handle keyboard events for the Menu.\n   * @param event The keyboard event to be handled.\n   */\n  _handleKeyEvent(event: KeyboardEvent) {\n    const keyManager = this.keyManager;\n    switch (event.keyCode) {\n      case LEFT_ARROW:\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          event.preventDefault();\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.onKeydown(event);\n        }\n        break;\n\n      case ESCAPE:\n        if (!hasModifierKey(event)) {\n          event.preventDefault();\n          this.menuStack.close(this, {\n            focusNextOnEmpty: FocusNext.currentItem,\n            focusParentTrigger: true,\n          });\n        }\n        break;\n\n      case TAB:\n        if (!hasModifierKey(event, 'altKey', 'metaKey', 'ctrlKey')) {\n          this.menuStack.closeAll({focusParentTrigger: true});\n        }\n        break;\n\n      default:\n        keyManager.onKeydown(event);\n    }\n  }\n\n  /**\n   * Set focus the either the current, previous or next item based on the FocusNext event.\n   * @param focusNext The element to focus.\n   */\n  private _toggleMenuFocus(focusNext: FocusNext | undefined) {\n    const keyManager = this.keyManager;\n    switch (focusNext) {\n      case FocusNext.nextItem:\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setNextItemActive();\n        break;\n\n      case FocusNext.previousItem:\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setPreviousItemActive();\n        break;\n\n      case FocusNext.currentItem:\n        if (keyManager.activeItem) {\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.setActiveItem(keyManager.activeItem);\n        }\n        break;\n    }\n  }\n\n  /** Subscribe to the MenuStack emptied events. */\n  private _subscribeToMenuStackEmptied() {\n    this.menuStack.emptied\n      .pipe(takeUntil(this.destroyed))\n      .subscribe(event => this._toggleMenuFocus(event));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {AfterContentInit, Directive} from '@angular/core';\nimport {\n  DOWN_ARROW,\n  ESCAPE,\n  hasModifierKey,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n  TAB,\n  UP_ARROW,\n} from '../keycodes';\nimport {takeUntil} from 'rxjs/operators';\nimport {CdkMenuGroup} from './menu-group';\nimport {CDK_MENU} from './menu-interface';\nimport {FocusNext, MENU_STACK, MenuStack} from './menu-stack';\nimport {CdkMenuBase} from './menu-base';\n\n/**\n * Directive applied to an element which configures it as a MenuBar by setting the appropriate\n * role, aria attributes, and accessible keyboard and mouse handling logic. The component that\n * this directive is applied to should contain components marked with CdkMenuItem.\n *\n */\n@Directive({\n  selector: '[cdkMenuBar]',\n  exportAs: 'cdkMenuBar',\n  host: {\n    'role': 'menubar',\n    'class': 'cdk-menu-bar',\n    '(keydown)': '_handleKeyEvent($event)',\n  },\n  providers: [\n    {provide: CdkMenuGroup, useExisting: CdkMenuBar},\n    {provide: CDK_MENU, useExisting: CdkMenuBar},\n    {provide: MENU_STACK, useFactory: () => MenuStack.inline('horizontal')},\n  ],\n})\nexport class CdkMenuBar extends CdkMenuBase implements AfterContentInit {\n  /** The direction items in the menu flow. */\n  override readonly orientation = 'horizontal';\n\n  /** Whether the menu is displayed inline (i.e. always present vs a conditional popup that the user triggers with a trigger element). */\n  override readonly isInline = true;\n\n  override ngAfterContentInit() {\n    super.ngAfterContentInit();\n    this._subscribeToMenuStackEmptied();\n  }\n\n  /**\n   * Handle keyboard events for the Menu.\n   * @param event The keyboard event to be handled.\n   */\n  _handleKeyEvent(event: KeyboardEvent) {\n    const keyManager = this.keyManager;\n    switch (event.keyCode) {\n      case UP_ARROW:\n      case DOWN_ARROW:\n      case LEFT_ARROW:\n      case RIGHT_ARROW:\n        if (!hasModifierKey(event)) {\n          const horizontalArrows = event.keyCode === LEFT_ARROW || event.keyCode === RIGHT_ARROW;\n          // For a horizontal menu if the left/right keys were clicked, or a vertical menu if the\n          // up/down keys were clicked: if the current menu is open, close it then focus and open the\n          // next  menu.\n          if (horizontalArrows) {\n            event.preventDefault();\n\n            const prevIsOpen = keyManager.activeItem?.isMenuOpen();\n            keyManager.activeItem?.getMenuTrigger()?.close();\n\n            keyManager.setFocusOrigin('keyboard');\n            keyManager.onKeydown(event);\n            if (prevIsOpen) {\n              keyManager.activeItem?.getMenuTrigger()?.open();\n            }\n          }\n        }\n        break;\n\n      case ESCAPE:\n        if (!hasModifierKey(event)) {\n          event.preventDefault();\n          keyManager.activeItem?.getMenuTrigger()?.close();\n        }\n        break;\n\n      case TAB:\n        if (!hasModifierKey(event, 'altKey', 'metaKey', 'ctrlKey')) {\n          keyManager.activeItem?.getMenuTrigger()?.close();\n        }\n        break;\n\n      default:\n        keyManager.onKeydown(event);\n    }\n  }\n\n  /**\n   * Set focus to either the current, previous or next item based on the FocusNext event, then\n   * open the previous or next item.\n   * @param focusNext The element to focus.\n   */\n  private _toggleOpenMenu(focusNext: FocusNext | undefined) {\n    const keyManager = this.keyManager;\n    switch (focusNext) {\n      case FocusNext.nextItem:\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setNextItemActive();\n        keyManager.activeItem?.getMenuTrigger()?.open();\n        break;\n\n      case FocusNext.previousItem:\n        keyManager.setFocusOrigin('keyboard');\n        keyManager.setPreviousItemActive();\n        keyManager.activeItem?.getMenuTrigger()?.open();\n        break;\n\n      case FocusNext.currentItem:\n        if (keyManager.activeItem) {\n          keyManager.setFocusOrigin('keyboard');\n          keyManager.setActiveItem(keyManager.activeItem);\n        }\n        break;\n    }\n  }\n\n  /** Subscribe to the MenuStack emptied events. */\n  private _subscribeToMenuStackEmptied() {\n    this.menuStack?.emptied\n      .pipe(takeUntil(this.destroyed))\n      .subscribe(event => this._toggleOpenMenu(event));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, Input, booleanAttribute} from '@angular/core';\nimport {CdkMenuItem} from './menu-item';\n\n/** Base class providing checked state for selectable MenuItems. */\n@Directive({\n  host: {\n    '[attr.aria-checked]': '!!checked',\n    '[attr.aria-disabled]': 'disabled || null',\n  },\n})\nexport abstract class CdkMenuItemSelectable extends CdkMenuItem {\n  /** Whether the element is checked */\n  @Input({alias: 'cdkMenuItemChecked', transform: booleanAttribute}) checked: boolean = false;\n\n  /** Whether the item should close the menu if triggered by the spacebar. */\n  protected override closeOnSpacebarTrigger = false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, inject, OnDestroy} from '@angular/core';\nimport {UniqueSelectionDispatcher} from '../collections';\nimport {_IdGenerator} from '../a11y';\nimport {CdkMenuItemSelectable} from './menu-item-selectable';\nimport {CdkMenuItem} from './menu-item';\n\n/**\n * A directive providing behavior for the \"menuitemradio\" ARIA role, which behaves similarly to\n * a conventional radio-button. Any sibling `CdkMenuItemRadio` instances within the same `CdkMenu`\n * or `CdkMenuGroup` comprise a radio group with unique selection enforced.\n */\n@Directive({\n  selector: '[cdkMenuItemRadio]',\n  exportAs: 'cdkMenuItemRadio',\n  host: {\n    'role': 'menuitemradio',\n    '[class.cdk-menu-item-radio]': 'true',\n  },\n  providers: [\n    {provide: CdkMenuItemSelectable, useExisting: CdkMenuItemRadio},\n    {provide: CdkMenuItem, useExisting: CdkMenuItemSelectable},\n  ],\n})\nexport class CdkMenuItemRadio extends CdkMenuItemSelectable implements OnDestroy {\n  /** The unique selection dispatcher for this radio's `CdkMenuGroup`. */\n  private readonly _selectionDispatcher = inject(UniqueSelectionDispatcher);\n\n  /** An ID to identify this radio item to the `UniqueSelectionDispatcher`. */\n  private _id = inject(_IdGenerator).getId('cdk-menu-item-radio-');\n\n  /** Function to unregister the selection dispatcher */\n  private _removeDispatcherListener: () => void;\n\n  constructor() {\n    super();\n    this._registerDispatcherListener();\n  }\n\n  override ngOnDestroy() {\n    super.ngOnDestroy();\n\n    this._removeDispatcherListener();\n  }\n\n  /**\n   * Toggles the checked state of the radio-button.\n   * @param options Options the configure how the item is triggered\n   *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n   */\n  override trigger(options?: {keepOpen: boolean}) {\n    super.trigger(options);\n\n    if (!this.disabled) {\n      this._selectionDispatcher.notify(this._id, '');\n    }\n  }\n\n  /** Configure the unique selection dispatcher listener in order to toggle the checked state  */\n  private _registerDispatcherListener() {\n    this._removeDispatcherListener = this._selectionDispatcher.listen((id: string) => {\n      this.checked = this._id === id;\n    });\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive} from '@angular/core';\nimport {CdkMenuItemSelectable} from './menu-item-selectable';\nimport {CdkMenuItem} from './menu-item';\n\n/**\n * A directive providing behavior for the \"menuitemcheckbox\" ARIA role, which behaves similarly to a\n * conventional checkbox.\n */\n@Directive({\n  selector: '[cdkMenuItemCheckbox]',\n  exportAs: 'cdkMenuItemCheckbox',\n  host: {\n    'role': 'menuitemcheckbox',\n    '[class.cdk-menu-item-checkbox]': 'true',\n  },\n  providers: [\n    {provide: CdkMenuItemSelectable, useExisting: CdkMenuItemCheckbox},\n    {provide: CdkMenuItem, useExisting: CdkMenuItemSelectable},\n  ],\n})\nexport class CdkMenuItemCheckbox extends CdkMenuItemSelectable {\n  /**\n   * Toggle the checked state of the checkbox.\n   * @param options Options the configure how the item is triggered\n   *   - keepOpen: specifies that the menu should be kept open after triggering the item.\n   */\n  override trigger(options?: {keepOpen: boolean}) {\n    super.trigger(options);\n\n    if (!this.disabled) {\n      this.checked = !this.checked;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  booleanAttribute,\n  ChangeDetectorRef,\n  Directive,\n  inject,\n  Injector,\n  Input,\n  OnDestroy,\n} from '@angular/core';\nimport {Directionality} from '../bidi';\nimport {\n  createFlexibleConnectedPositionStrategy,\n  createOverlayRef,\n  FlexibleConnectedPositionStrategy,\n  OverlayConfig,\n  STANDARD_DROPDOWN_BELOW_POSITIONS,\n} from '../overlay';\nimport {_getEventTarget} from '../platform';\nimport {merge, partition} from 'rxjs';\nimport {skip, takeUntil, skipWhile} from 'rxjs/operators';\nimport {MENU_STACK, MenuStack} from './menu-stack';\nimport {CdkMenuTriggerBase, MENU_TRIGGER, MenuTracker} from './menu-trigger-base';\n\n/** The preferred menu positions for the context menu. */\nconst CONTEXT_MENU_POSITIONS = STANDARD_DROPDOWN_BELOW_POSITIONS.map(position => {\n  // In cases where the first menu item in the context menu is a trigger the submenu opens on a\n  // hover event. We offset the context menu 2px by default to prevent this from occurring.\n  const offsetX = position.overlayX === 'start' ? 2 : -2;\n  const offsetY = position.overlayY === 'top' ? 2 : -2;\n  return {...position, offsetX, offsetY};\n});\n\n/**\n * @deprecated Will be removed. Use `MenuTracker` instead.\n * @breaking-change 22.0.0\n */\nexport {MenuTracker as ContextMenuTracker};\n\n/** The coordinates where the context menu should open. */\nexport type ContextMenuCoordinates = {x: number; y: number};\n\n/**\n * A directive that opens a menu when a user right-clicks within its host element.\n * It is aware of nested context menus and will trigger only the lowest level non-disabled context menu.\n */\n@Directive({\n  selector: '[cdkContextMenuTriggerFor]',\n  exportAs: 'cdkContextMenuTriggerFor',\n  host: {\n    '[attr.data-cdk-menu-stack-id]': 'null',\n    '(contextmenu)': '_openOnContextMenu($event)',\n  },\n  inputs: [\n    {name: 'menuTemplateRef', alias: 'cdkContextMenuTriggerFor'},\n    {name: 'menuPosition', alias: 'cdkContextMenuPosition'},\n    {name: 'menuData', alias: 'cdkContextMenuTriggerData'},\n  ],\n  outputs: ['opened: cdkContextMenuOpened', 'closed: cdkContextMenuClosed'],\n  providers: [\n    {provide: MENU_TRIGGER, useExisting: CdkContextMenuTrigger},\n    {provide: MENU_STACK, useClass: MenuStack},\n  ],\n})\nexport class CdkContextMenuTrigger extends CdkMenuTriggerBase implements OnDestroy {\n  private readonly _injector = inject(Injector);\n  private readonly _directionality = inject(Directionality, {optional: true});\n\n  /** The app's menu tracking registry */\n  private readonly _menuTracker = inject(MenuTracker);\n\n  private readonly _changeDetectorRef = inject(ChangeDetectorRef);\n\n  /** Whether the context menu is disabled. */\n  @Input({alias: 'cdkContextMenuDisabled', transform: booleanAttribute}) disabled: boolean = false;\n\n  constructor() {\n    super();\n    this._setMenuStackCloseListener();\n  }\n\n  /**\n   * Open the attached menu at the specified location.\n   * @param coordinates where to open the context menu\n   */\n  open(coordinates: ContextMenuCoordinates) {\n    this._open(null, coordinates);\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /** Close the currently opened context menu. */\n  close() {\n    this.menuStack.closeAll();\n  }\n\n  /**\n   * Open the context menu and closes any previously open menus.\n   * @param event the mouse event which opens the context menu.\n   */\n  _openOnContextMenu(event: MouseEvent) {\n    if (!this.disabled) {\n      // Prevent the native context menu from opening because we're opening a custom one.\n      event.preventDefault();\n\n      // Stop event propagation to ensure that only the closest enabled context menu opens.\n      // Otherwise, any context menus attached to containing elements would *also* open,\n      // resulting in multiple stacked context menus being displayed.\n      event.stopPropagation();\n\n      this._menuTracker.update(this);\n      this._open(event, {x: event.clientX, y: event.clientY});\n\n      // A context menu can be triggered via a mouse right click or a keyboard shortcut.\n      if (event.button === 2) {\n        this.childMenu?.focusFirstItem('mouse');\n      } else if (event.button === 0) {\n        this.childMenu?.focusFirstItem('keyboard');\n      } else {\n        this.childMenu?.focusFirstItem('program');\n      }\n    }\n  }\n\n  /**\n   * Get the configuration object used to create the overlay.\n   * @param coordinates the location to place the opened menu\n   */\n  private _getOverlayConfig(coordinates: ContextMenuCoordinates) {\n    return new OverlayConfig({\n      positionStrategy: this._getOverlayPositionStrategy(coordinates),\n      scrollStrategy: this.menuScrollStrategy(),\n      direction: this._directionality || undefined,\n    });\n  }\n\n  /**\n   * Get the position strategy for the overlay which specifies where to place the menu.\n   * @param coordinates the location to place the opened menu\n   */\n  private _getOverlayPositionStrategy(\n    coordinates: ContextMenuCoordinates,\n  ): FlexibleConnectedPositionStrategy {\n    return createFlexibleConnectedPositionStrategy(this._injector, coordinates)\n      .withLockedPosition()\n      .withGrowAfterOpen()\n      .withPositions(this.menuPosition ?? CONTEXT_MENU_POSITIONS);\n  }\n\n  /** Subscribe to the menu stack close events and close this menu when requested. */\n  private _setMenuStackCloseListener() {\n    this.menuStack.closed.pipe(takeUntil(this.destroyed)).subscribe(({item}) => {\n      if (item === this.childMenu && this.isOpen()) {\n        this.closed.next();\n        this.overlayRef!.detach();\n        this.childMenu = undefined;\n        this._changeDetectorRef.markForCheck();\n      }\n    });\n  }\n\n  /**\n   * Subscribe to the overlays outside pointer events stream and handle closing out the stack if a\n   * click occurs outside the menus.\n   * @param userEvent User-generated event that opened the menu.\n   */\n  private _subscribeToOutsideClicks(userEvent: MouseEvent | null) {\n    if (this.overlayRef) {\n      let outsideClicks = this.overlayRef.outsidePointerEvents();\n\n      if (userEvent) {\n        const [auxClicks, nonAuxClicks] = partition(outsideClicks, ({type}) => type === 'auxclick');\n        outsideClicks = merge(\n          // Using a mouse, the `contextmenu` event can fire either when pressing the right button\n          // or left button + control. Most browsers won't dispatch a `click` event right after\n          // a `contextmenu` event triggered by left button + control, but Safari will (see #27832).\n          // This closes the menu immediately. To work around it, we check that both the triggering\n          // event and the current outside click event both had the control key pressed, and that\n          // that this is the first outside click event.\n          nonAuxClicks.pipe(\n            skipWhile((event, index) => userEvent.ctrlKey && index === 0 && event.ctrlKey),\n          ),\n\n          // If the menu was triggered by the `contextmenu` event, skip the first `auxclick` event\n          // because it fires when the mouse is released on the same click that opened the menu.\n          auxClicks.pipe(skip(1)),\n        );\n      }\n\n      outsideClicks.pipe(takeUntil(this.stopOutsideClicksListener)).subscribe(event => {\n        if (!this.isElementInsideMenuStack(_getEventTarget(event)!)) {\n          this.menuStack.closeAll();\n        }\n      });\n    }\n  }\n\n  /**\n   * Open the attached menu at the specified location.\n   * @param userEvent User-generated event that opened the menu\n   * @param coordinates where to open the context menu\n   */\n  private _open(userEvent: MouseEvent | null, coordinates: ContextMenuCoordinates) {\n    if (this.disabled) {\n      return;\n    }\n    if (this.isOpen()) {\n      // since we're moving this menu we need to close any submenus first otherwise they end up\n      // disconnected from this one.\n      this.menuStack.closeSubMenuOf(this.childMenu!);\n\n      (\n        this.overlayRef!.getConfig().positionStrategy as FlexibleConnectedPositionStrategy\n      ).setOrigin(coordinates);\n      this.overlayRef!.updatePosition();\n    } else {\n      this.opened.next();\n\n      if (this.overlayRef) {\n        (\n          this.overlayRef.getConfig().positionStrategy as FlexibleConnectedPositionStrategy\n        ).setOrigin(coordinates);\n        this.overlayRef.updatePosition();\n      } else {\n        this.overlayRef = createOverlayRef(this._injector, this._getOverlayConfig(coordinates));\n      }\n\n      this.overlayRef.attach(this.getMenuContentPortal());\n      this._subscribeToOutsideClicks(userEvent);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {OverlayModule} from '../overlay';\nimport {CdkMenu} from './menu';\nimport {CdkMenuBar} from './menu-bar';\nimport {CdkMenuItem} from './menu-item';\nimport {CdkMenuGroup} from './menu-group';\nimport {CdkMenuItemRadio} from './menu-item-radio';\nimport {CdkMenuItemCheckbox} from './menu-item-checkbox';\nimport {CdkMenuTrigger} from './menu-trigger';\nimport {CdkContextMenuTrigger} from './context-menu-trigger';\nimport {CdkTargetMenuAim} from './menu-aim';\n\nconst MENU_DIRECTIVES = [\n  CdkMenuBar,\n  CdkMenu,\n  CdkMenuItem,\n  CdkMenuItemRadio,\n  CdkMenuItemCheckbox,\n  CdkMenuTrigger,\n  CdkMenuGroup,\n  CdkContextMenuTrigger,\n  CdkTargetMenuAim,\n];\n\n/** Module that declares components and directives for the CDK menu. */\n@NgModule({\n  imports: [OverlayModule, ...MENU_DIRECTIVES],\n  exports: MENU_DIRECTIVES,\n})\nexport class CdkMenuModule {}\n"],"names":["CdkMenuGroup","args","providers","provide","UniqueSelectionDispatcher","useClass","FocusNext","MENU_STACK","InjectionToken","PARENT_OR_NEW_MENU_STACK_PROVIDER","skipSelf","MenuStack","useFactory","inject","optional","inline","orientation","_close","Subject","closed","_elements","push","menu","next","item","poppedElement","focusParentTrigger","lastItem","isEmpty","_empty","focusNextOnEmpty","removed","MENU_TRIGGER","MENU_SCROLL_STRATEGY","providedIn","factory","MenuTracker","update","trigger","_openMenuTrigger","close","fac","i0","ngDeclareFactory","minVersion","version","ngImport","type","deps","target","FactoryTarget","Injectable","prov","ngDeclareInjectable","decorators","menuStack","menuScrollStrategy","menuPosition","opened","EventEmitter","childMenu","_menuPortal","ngOnDestroy","_destroyOverlay","destroyed","overlayRef","hasAttached","registerChildMenu","child","getMenuContentPortal","hasMenuContentChanged","menuTemplateRef","templateRef","TemplatePortal","viewContainerRef","menuData","_getChildMenuInjector","throwMissingMenuReference","Error","MOUSE_MOVE_SAMPLE_FREQUENCY","NUM_POINTS","getSlope","a","b","y","x","point","slope","m","right","top","bottom","left","_cleanupMousemove","_destroyed","complete","initialize","pointerTracker","_checkConfigured","hasPoints","siblingItemIsWaiting","_isMovingToSubmenu","doToggle","CLOSE_DELAY","numMoving","currPoint","_points","length","el","elementRef","nativeElement","keyCode","event","ENTER","SPACE","_renderer","Renderer2","Injector","_cleanupMouseenter","_menuTracker","_parentMenu","CDK_MENU","_menuAim","MENU_AIM","constructor","_setRole","_subscribeToMenuStackClosed","_subscribeToMouseEnter","_subscribeToMenuStackHasFocus","isOpen","open","_changeDetectorRef","markForCheck","_toggleOnKeydown","isParentVertical","hasModifierKey","eventDispatchesNativeClick","_elementRef","focusFirstItem","RIGHT_ARROW","_directionality","value","preventDefault","DOWN_ARROW","focusLastItem","_setHasFocus","hasFocus","setHasFocus","listen","toggleMenus","_ngZone","run","_closeSiblingTriggers","toggle","isParentMenuBar","closeAll","OverlayConfig","_getOverlayPositionStrategy","scrollStrategy","direction","undefined","createFlexibleConnectedPositionStrategy","_injector","withLockedPosition","withFlexibleDimensions","withPositions","_getOverlayPositions","STANDARD_DROPDOWN_BELOW_POSITIONS","STANDARD_DROPDOWN_ADJACENT_POSITIONS","_registerCloseHandler","pipe","takeUntil","subscribe","_subscribeToOutsideClicks","outsidePointerEvents","selector","name","alias","useExisting","CdkMenuTrigger","ctorParameters","CdkMenuItem","_menuStack","_menuTrigger","self","typeaheadLabel","hasMenu","_setupMouseEnter","_setType","_tabindex","_cleanupMouseEnter","focus","getMenu","stopPropagation","_onKeydown","nodeName","keepOpen","closeOnSpacebarTrigger","_dir","_forwardArrowPressed","_backArrowPressed","_isParentVertical","parentMenu","hasInlineMenu","currentItem","inlineMenuOrientation","propDecorators","disabled","transform","booleanAttribute","PointerFocusTracker","_items","_eventCleanups","exited","activeElement","previousElement","_bindEvents","element","destroy","_cleanupEvents","_itemsSubscription","unsubscribe","changes","startWith","CdkMenuBase","FocusMonitor","menuAim","isInline","_tabIndexSignal","computed","tabindexIfInline","_menuStackHasFocus","ngAfterContentInit","_setKeyManager","_subscribeToMenuOpen","_setUpPointerTracker","stopMonitoring","focusOrigin","keyManager","setFocusOrigin","setActiveMenuItem","setActiveItem","closeOpenMenu","options","setFirstItemActive","_allItems","items","reset","filter","notifyOnChanges","FocusKeyManager","withWrap","withTypeAhead","withHomeAndEnd","skipPredicate","withHorizontalOrientation","dir","withVerticalOrientation","exitCondition","merge","triggerItem","getMenuTrigger","descendants","_parentTrigger","LEFT_ARROW","ESCAPE","onKeydown","_toggleMenuFocus","focusNext","nextItem","previousItem","setPreviousItemActive","activeItem","exportAs","host","CdkMenu","PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER","_subscribeToMenuStackEmptied","_handleKeyEvent","horizontalArrows","prevIsOpen","TAB","_toggleOpenMenu","CdkMenuBar","CdkMenuItemSelectable","Directive","CdkMenuItemRadio","_removeDispatcherListener","_registerDispatcherListener","_selectionDispatcher","id","checked","_id","CdkMenuItemCheckbox","dir","ngDeclareDirective","isStandalone","attributes","properties","usesInheritance","CONTEXT_MENU_POSITIONS","map","position","offsetX","overlayX","offsetY","overlayY","Directionality","coordinates","_open","_openOnContextMenu","clientX","clientY","button","_setMenuStackCloseListener","detach","nonAuxClicks","skipWhile","index","userEvent","ctrlKey","auxClicks","skip","stopOutsideClicksListener","isElementInsideMenuStack","_getEventTarget","inputs","Input","CdkTargetMenuAim","ngDeclareNgModule","CdkMenuModule","imports","OverlayModule","exports","ngDeclareInjector","MENU_DIRECTIVES"],"mappings":"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"}