{"version":3,"file":"_list-key-manager-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/a11y/key-manager/list-key-manager.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  DOWN_ARROW,\n  END,\n  HOME,\n  LEFT_ARROW,\n  PAGE_DOWN,\n  PAGE_UP,\n  RIGHT_ARROW,\n  TAB,\n  UP_ARROW,\n  hasModifierKey,\n} from '../../keycodes';\nimport {EffectRef, Injector, QueryList, Signal, effect, isSignal, signal} from '@angular/core';\nimport {Subject, Subscription} from 'rxjs';\nimport {Typeahead} from './typeahead';\n\n/** This interface is for items that can be passed to a ListKeyManager. */\nexport interface ListKeyManagerOption {\n  /** Whether the option is disabled. */\n  disabled?: boolean;\n\n  /** Gets the label for this option. */\n  getLabel?(): string;\n}\n\n/** Modifier keys handled by the ListKeyManager. */\nexport type ListKeyManagerModifierKey = 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey';\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nexport class ListKeyManager<T extends ListKeyManagerOption> {\n  private _activeItemIndex = signal(-1);\n  private _activeItem = signal<T | null>(null);\n  private _wrap = false;\n  private _typeaheadSubscription = Subscription.EMPTY;\n  private _itemChangesSubscription?: Subscription;\n  private _vertical = true;\n  private _horizontal: 'ltr' | 'rtl' | null;\n  private _allowedModifierKeys: ListKeyManagerModifierKey[] = [];\n  private _homeAndEnd = false;\n  private _pageUpAndDown = {enabled: false, delta: 10};\n  private _effectRef: EffectRef | undefined;\n  private _typeahead?: Typeahead<T>;\n\n  /**\n   * Predicate function that can be used to check whether an item should be skipped\n   * by the key manager. By default, disabled items are skipped.\n   */\n  private _skipPredicateFn = (item: T) => item.disabled;\n\n  constructor(items: QueryList<T> | T[] | readonly T[]);\n  constructor(items: Signal<T[]> | Signal<readonly T[]>, injector: Injector);\n  constructor(\n    private _items: QueryList<T> | T[] | readonly T[] | Signal<T[]> | Signal<readonly T[]>,\n    injector?: Injector,\n  ) {\n    // We allow for the items to be an array because, in some cases, the consumer may\n    // not have access to a QueryList of the items they want to manage (e.g. when the\n    // items aren't being collected via `ViewChildren` or `ContentChildren`).\n    if (_items instanceof QueryList) {\n      this._itemChangesSubscription = _items.changes.subscribe((newItems: QueryList<T>) =>\n        this._itemsChanged(newItems.toArray()),\n      );\n    } else if (isSignal(_items)) {\n      if (!injector && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw new Error('ListKeyManager constructed with a signal must receive an injector');\n      }\n\n      this._effectRef = effect(() => this._itemsChanged(_items()), {injector});\n    }\n  }\n\n  /**\n   * Stream that emits any time the TAB key is pressed, so components can react\n   * when focus is shifted off of the list.\n   */\n  readonly tabOut = new Subject<void>();\n\n  /** Stream that emits whenever the active item of the list manager changes. */\n  readonly change = new Subject<number>();\n\n  /**\n   * Sets the predicate function that determines which items should be skipped by the\n   * list key manager.\n   * @param predicate Function that determines whether the given item should be skipped.\n   */\n  skipPredicate(predicate: (item: T) => boolean): this {\n    this._skipPredicateFn = predicate;\n    return this;\n  }\n\n  /**\n   * Configures wrapping mode, which determines whether the active item will wrap to\n   * the other end of list when there are no more items in the given direction.\n   * @param shouldWrap Whether the list should wrap when reaching the end.\n   */\n  withWrap(shouldWrap = true): this {\n    this._wrap = shouldWrap;\n    return this;\n  }\n\n  /**\n   * Configures whether the key manager should be able to move the selection vertically.\n   * @param enabled Whether vertical selection should be enabled.\n   */\n  withVerticalOrientation(enabled: boolean = true): this {\n    this._vertical = enabled;\n    return this;\n  }\n\n  /**\n   * Configures the key manager to move the selection horizontally.\n   * Passing in `null` will disable horizontal movement.\n   * @param direction Direction in which the selection can be moved.\n   */\n  withHorizontalOrientation(direction: 'ltr' | 'rtl' | null): this {\n    this._horizontal = direction;\n    return this;\n  }\n\n  /**\n   * Modifier keys which are allowed to be held down and whose default actions will be prevented\n   * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n   */\n  withAllowedModifierKeys(keys: ListKeyManagerModifierKey[]): this {\n    this._allowedModifierKeys = keys;\n    return this;\n  }\n\n  /**\n   * Turns on typeahead mode which allows users to set the active item by typing.\n   * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n   */\n  withTypeAhead(debounceInterval: number = 200): this {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const items = this._getItemsArray();\n      if (items.length > 0 && items.some(item => typeof item.getLabel !== 'function')) {\n        throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n      }\n    }\n\n    this._typeaheadSubscription.unsubscribe();\n\n    const items = this._getItemsArray();\n    this._typeahead = new Typeahead(items, {\n      debounceInterval: typeof debounceInterval === 'number' ? debounceInterval : undefined,\n      skipPredicate: item => this._skipPredicateFn(item),\n    });\n\n    this._typeaheadSubscription = this._typeahead.selectedItem.subscribe(item => {\n      this.setActiveItem(item);\n    });\n\n    return this;\n  }\n\n  /** Cancels the current typeahead sequence. */\n  cancelTypeahead(): this {\n    this._typeahead?.reset();\n    return this;\n  }\n\n  /**\n   * Configures the key manager to activate the first and last items\n   * respectively when the Home or End key is pressed.\n   * @param enabled Whether pressing the Home or End key activates the first/last item.\n   */\n  withHomeAndEnd(enabled: boolean = true): this {\n    this._homeAndEnd = enabled;\n    return this;\n  }\n\n  /**\n   * Configures the key manager to activate every 10th, configured or first/last element in up/down direction\n   * respectively when the Page-Up or Page-Down key is pressed.\n   * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.\n   * @param delta Whether pressing the Home or End key activates the first/last item.\n   */\n  withPageUpDown(enabled: boolean = true, delta: number = 10): this {\n    this._pageUpAndDown = {enabled, delta};\n    return this;\n  }\n\n  /**\n   * Sets the active item to the item at the index specified.\n   * @param index The index of the item to be set as active.\n   */\n  setActiveItem(index: number): void;\n\n  /**\n   * Sets the active item to the specified item.\n   * @param item The item to be set as active.\n   */\n  setActiveItem(item: T): void;\n\n  /**\n   * Sets the active item to the specified item.\n   * @param item The item to be set as active.\n   */\n  setActiveItem(item: T | number): void;\n\n  setActiveItem(item: any): void {\n    const previousActiveItem = this._activeItem();\n\n    this.updateActiveItem(item);\n\n    if (this._activeItem() !== previousActiveItem) {\n      this.change.next(this._activeItemIndex());\n    }\n  }\n\n  /**\n   * Sets the active item depending on the key event passed in.\n   * @param event Keyboard event to be used for determining which element should be active.\n   */\n  onKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n    const modifiers: ListKeyManagerModifierKey[] = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n    const isModifierAllowed = modifiers.every(modifier => {\n      return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n    });\n\n    switch (keyCode) {\n      case TAB:\n        this.tabOut.next();\n        return;\n\n      case DOWN_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case UP_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case RIGHT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case LEFT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case HOME:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setFirstItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case END:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setLastItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case PAGE_UP:\n        if (this._pageUpAndDown.enabled && isModifierAllowed) {\n          const targetIndex = this._activeItemIndex() - this._pageUpAndDown.delta;\n          this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);\n          break;\n        } else {\n          return;\n        }\n\n      case PAGE_DOWN:\n        if (this._pageUpAndDown.enabled && isModifierAllowed) {\n          const targetIndex = this._activeItemIndex() + this._pageUpAndDown.delta;\n          const itemsLength = this._getItemsArray().length;\n          this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);\n          break;\n        } else {\n          return;\n        }\n\n      default:\n        if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n          this._typeahead?.handleKey(event);\n        }\n\n        // Note that we return here, in order to avoid preventing\n        // the default action of non-navigational keys.\n        return;\n    }\n\n    this._typeahead?.reset();\n    event.preventDefault();\n  }\n\n  /** Index of the currently active item. */\n  get activeItemIndex(): number | null {\n    return this._activeItemIndex();\n  }\n\n  /** The active item. */\n  get activeItem(): T | null {\n    return this._activeItem();\n  }\n\n  /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n  isTyping(): boolean {\n    return !!this._typeahead && this._typeahead.isTyping();\n  }\n\n  /** Sets the active item to the first enabled item in the list. */\n  setFirstItemActive(): void {\n    this._setActiveItemByIndex(0, 1);\n  }\n\n  /** Sets the active item to the last enabled item in the list. */\n  setLastItemActive(): void {\n    this._setActiveItemByIndex(this._getItemsArray().length - 1, -1);\n  }\n\n  /** Sets the active item to the next enabled item in the list. */\n  setNextItemActive(): void {\n    this._activeItemIndex() < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n  }\n\n  /** Sets the active item to a previous enabled item in the list. */\n  setPreviousItemActive(): void {\n    this._activeItemIndex() < 0 && this._wrap\n      ? this.setLastItemActive()\n      : this._setActiveItemByDelta(-1);\n  }\n\n  /**\n   * Allows setting the active without any other effects.\n   * @param index Index of the item to be set as active.\n   */\n  updateActiveItem(index: number): void;\n\n  /**\n   * Allows setting the active item without any other effects.\n   * @param item Item to be set as active.\n   */\n  updateActiveItem(item: T): void;\n\n  updateActiveItem(item: any): void {\n    const itemArray = this._getItemsArray();\n    const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n    const activeItem = itemArray[index];\n\n    // Explicitly check for `null` and `undefined` because other falsy values are valid.\n    this._activeItem.set(activeItem == null ? null : activeItem);\n    this._activeItemIndex.set(index);\n    this._typeahead?.setCurrentSelectedItemIndex(index);\n  }\n\n  /** Cleans up the key manager. */\n  destroy() {\n    this._typeaheadSubscription.unsubscribe();\n    this._itemChangesSubscription?.unsubscribe();\n    this._effectRef?.destroy();\n    this._typeahead?.destroy();\n    this.tabOut.complete();\n    this.change.complete();\n  }\n\n  /**\n   * This method sets the active item, given a list of items and the delta between the\n   * currently active item and the new active item. It will calculate differently\n   * depending on whether wrap mode is turned on.\n   */\n  private _setActiveItemByDelta(delta: -1 | 1): void {\n    this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n  }\n\n  /**\n   * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n   * down the list until it finds an item that is not disabled, and it will wrap if it\n   * encounters either end of the list.\n   */\n  private _setActiveInWrapMode(delta: -1 | 1): void {\n    const items = this._getItemsArray();\n\n    for (let i = 1; i <= items.length; i++) {\n      const index = (this._activeItemIndex() + delta * i + items.length) % items.length;\n      const item = items[index];\n\n      if (!this._skipPredicateFn(item)) {\n        this.setActiveItem(index);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Sets the active item properly given the default mode. In other words, it will\n   * continue to move down the list until it finds an item that is not disabled. If\n   * it encounters either end of the list, it will stop and not wrap.\n   */\n  private _setActiveInDefaultMode(delta: -1 | 1): void {\n    this._setActiveItemByIndex(this._activeItemIndex() + delta, delta);\n  }\n\n  /**\n   * Sets the active item to the first enabled item starting at the index specified. If the\n   * item is disabled, it will move in the fallbackDelta direction until it either\n   * finds an enabled item or encounters the end of the list.\n   */\n  private _setActiveItemByIndex(index: number, fallbackDelta: -1 | 1): void {\n    const items = this._getItemsArray();\n\n    if (!items[index]) {\n      return;\n    }\n\n    while (this._skipPredicateFn(items[index])) {\n      index += fallbackDelta;\n\n      if (!items[index]) {\n        return;\n      }\n    }\n\n    this.setActiveItem(index);\n  }\n\n  /** Returns the items as an array. */\n  private _getItemsArray(): T[] | readonly T[] {\n    if (isSignal(this._items)) {\n      return this._items();\n    }\n\n    return this._items instanceof QueryList ? this._items.toArray() : this._items;\n  }\n\n  /** Callback for when the items have changed. */\n  private _itemsChanged(newItems: T[] | readonly T[]) {\n    this._typeahead?.setItems(newItems);\n    const activeItem = this._activeItem();\n    if (activeItem) {\n      const newIndex = newItems.indexOf(activeItem);\n\n      if (newIndex > -1 && newIndex !== this._activeItemIndex()) {\n        this._activeItemIndex.set(newIndex);\n        this._typeahead?.setCurrentSelectedItemIndex(newIndex);\n      }\n    }\n  }\n}\n"],"names":["ListKeyManager","_items","_activeItemIndex","signal","ngDevMode","debugName","_activeItem","_horizontal","_allowedModifierKeys","_homeAndEnd","_typeahead","QueryList","_itemChangesSubscription","changes","subscribe","newItems","_itemsChanged","toArray","isSignal","injector","Error","change","Subject","skipPredicate","predicate","_skipPredicateFn","withWrap","shouldWrap","withVerticalOrientation","enabled","_vertical","withAllowedModifierKeys","keys","withTypeAhead","debounceInterval","items","length","some","item","getLabel","unsubscribe","_getItemsArray","Typeahead","_typeaheadSubscription","selectedItem","setActiveItem","cancelTypeahead","reset","previousActiveItem","keyCode","event","tabOut","next","DOWN_ARROW","isModifierAllowed","UP_ARROW","setPreviousItemActive","RIGHT_ARROW","setNextItemActive","LEFT_ARROW","HOME","setFirstItemActive","END","setLastItemActive","PAGE_UP","_pageUpAndDown","targetIndex","delta","_setActiveItemByIndex","itemsLength","hasModifierKey","activeItem","isTyping","_setActiveItemByDelta","itemArray","index","indexOf","set"],"mappings":"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"}