{"version":3,"file":"listbox.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/listbox/listbox.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/listbox/listbox-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  _IdGenerator,\n  ActiveDescendantKeyManager,\n  Highlightable,\n  ListKeyManagerOption,\n} from '../a11y';\nimport {Directionality} from '../bidi';\nimport {coerceArray} from '../coercion';\nimport {SelectionModel} from '../collections';\nimport {\n  A,\n  DOWN_ARROW,\n  END,\n  ENTER,\n  hasModifierKey,\n  HOME,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n  SPACE,\n  UP_ARROW,\n} from '../keycodes';\nimport {Platform} from '../platform';\nimport {\n  AfterContentInit,\n  booleanAttribute,\n  ChangeDetectorRef,\n  ContentChildren,\n  Directive,\n  ElementRef,\n  forwardRef,\n  inject,\n  Input,\n  NgZone,\n  numberAttribute,\n  OnDestroy,\n  Output,\n  QueryList,\n  Renderer2,\n  signal,\n} from '@angular/core';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {defer, merge, Observable, Subject} from 'rxjs';\nimport {filter, map, startWith, switchMap, takeUntil} from 'rxjs/operators';\n\n/**\n * An implementation of SelectionModel that internally always represents the selection as a\n * multi-selection. This is necessary so that we can recover the full selection if the user\n * switches the listbox from single-selection to multi-selection after initialization.\n *\n * This selection model may report multiple selected values, even if it is in single-selection\n * mode. It is up to the user (CdkListbox) to check for invalid selections.\n */\nclass ListboxSelectionModel<T> extends SelectionModel<T> {\n  constructor(\n    public multiple = false,\n    initiallySelectedValues?: T[],\n    emitChanges = true,\n    compareWith?: (o1: T, o2: T) => boolean,\n  ) {\n    super(true, initiallySelectedValues, emitChanges, compareWith);\n  }\n\n  override isMultipleSelection(): boolean {\n    return this.multiple;\n  }\n\n  override select(...values: T[]) {\n    // The super class is always in multi-selection mode, so we need to override the behavior if\n    // this selection model actually belongs to a single-selection listbox.\n    if (this.multiple) {\n      return super.select(...values);\n    } else {\n      return super.setSelection(...values);\n    }\n  }\n}\n\n/** A selectable option in a listbox. */\n@Directive({\n  selector: '[cdkOption]',\n  exportAs: 'cdkOption',\n  host: {\n    'role': 'option',\n    'class': 'cdk-option',\n    '[id]': 'id',\n    '[attr.aria-selected]': 'isSelected()',\n    '[attr.tabindex]': '_getTabIndex()',\n    '[attr.aria-disabled]': 'disabled',\n    '[class.cdk-option-active]': 'isActive()',\n    '(click)': '_clicked.next($event)',\n    '(focus)': '_handleFocus()',\n  },\n})\nexport class CdkOption<T = unknown> implements ListKeyManagerOption, Highlightable, OnDestroy {\n  /** The id of the option's host element. */\n  @Input()\n  get id() {\n    return this._id || this._generatedId;\n  }\n  set id(value) {\n    this._id = value;\n  }\n  private _id: string;\n  private _generatedId = inject(_IdGenerator).getId('cdk-option-');\n\n  /** The value of this option. */\n  @Input('cdkOption') value: T;\n\n  /**\n   * The text used to locate this item during listbox typeahead. If not specified,\n   * the `textContent` of the item will be used.\n   */\n  @Input('cdkOptionTypeaheadLabel') typeaheadLabel: string | null;\n\n  /** Whether this option is disabled. */\n  @Input({alias: 'cdkOptionDisabled', transform: booleanAttribute})\n  get disabled(): boolean {\n    return this.listbox.disabled || this._disabled();\n  }\n  set disabled(value: boolean) {\n    this._disabled.set(value);\n  }\n  private _disabled = signal(false);\n\n  /** The tabindex of the option when it is enabled. */\n  @Input({\n    alias: 'tabindex',\n    transform: (value: unknown) => (value == null ? undefined : numberAttribute(value)),\n  })\n  get enabledTabIndex() {\n    return this._enabledTabIndex() === undefined\n      ? this.listbox.enabledTabIndex\n      : this._enabledTabIndex();\n  }\n  set enabledTabIndex(value) {\n    this._enabledTabIndex.set(value);\n  }\n  private _enabledTabIndex = signal<number | null | undefined>(undefined);\n\n  /** The option's host element */\n  readonly element: HTMLElement = inject(ElementRef).nativeElement;\n\n  /** The parent listbox this option belongs to. */\n  protected readonly listbox: CdkListbox<T> = inject(CdkListbox);\n\n  /** Emits when the option is destroyed. */\n  protected destroyed = new Subject<void>();\n\n  /** Emits when the option is clicked. */\n  readonly _clicked = new Subject<MouseEvent>();\n\n  ngOnDestroy() {\n    this.destroyed.next();\n    this.destroyed.complete();\n  }\n\n  /** Whether this option is selected. */\n  isSelected() {\n    return this.listbox.isSelected(this);\n  }\n\n  /** Whether this option is active. */\n  isActive() {\n    return this.listbox.isActive(this);\n  }\n\n  /** Toggle the selected state of this option. */\n  toggle() {\n    this.listbox.toggle(this);\n  }\n\n  /** Select this option if it is not selected. */\n  select() {\n    this.listbox.select(this);\n  }\n\n  /** Deselect this option if it is selected. */\n  deselect() {\n    this.listbox.deselect(this);\n  }\n\n  /** Focus this option. */\n  focus() {\n    this.element.focus();\n  }\n\n  /** Get the label for this element which is required by the FocusableOption interface. */\n  getLabel() {\n    return (this.typeaheadLabel ?? this.element.textContent?.trim()) || '';\n  }\n\n  /**\n   * No-op implemented as a part of `Highlightable`.\n   * @docs-private\n   */\n  setActiveStyles() {\n    // If the listbox is using `aria-activedescendant` the option won't have focus so the\n    // browser won't scroll them into view automatically so we need to do it ourselves.\n    if (this.listbox.useActiveDescendant) {\n      this.element.scrollIntoView({block: 'nearest', inline: 'nearest'});\n    }\n  }\n\n  /**\n   * No-op implemented as a part of `Highlightable`.\n   * @docs-private\n   */\n  setInactiveStyles() {}\n\n  /** Handle focus events on the option. */\n  protected _handleFocus() {\n    // Options can wind up getting focused in active descendant mode if the user clicks on them.\n    // In this case, we push focus back to the parent listbox to prevent an extra tab stop when\n    // the user performs a shift+tab.\n    if (this.listbox.useActiveDescendant) {\n      this.listbox._setActiveOption(this);\n      this.listbox.focus();\n    }\n  }\n\n  /** Get the tabindex for this option. */\n  protected _getTabIndex() {\n    if (this.listbox.useActiveDescendant || this.disabled) {\n      return -1;\n    }\n    return this.isActive() ? this.enabledTabIndex : -1;\n  }\n}\n\n@Directive({\n  selector: '[cdkListbox]',\n  exportAs: 'cdkListbox',\n  host: {\n    'role': 'listbox',\n    'class': 'cdk-listbox',\n    '[id]': 'id',\n    '[attr.tabindex]': '_getTabIndex()',\n    '[attr.aria-disabled]': 'disabled',\n    '[attr.aria-multiselectable]': 'multiple',\n    '[attr.aria-activedescendant]': '_getAriaActiveDescendant()',\n    '[attr.aria-orientation]': 'orientation',\n    '(focus)': '_handleFocus()',\n    '(keydown)': '_handleKeydown($event)',\n    '(focusout)': '_handleFocusOut($event)',\n    '(focusin)': '_handleFocusIn()',\n  },\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => CdkListbox),\n      multi: true,\n    },\n  ],\n})\nexport class CdkListbox<T = unknown> implements AfterContentInit, OnDestroy, ControlValueAccessor {\n  private _cleanupWindowBlur: (() => void) | undefined;\n\n  /** The id of the option's host element. */\n  @Input()\n  get id() {\n    return this._id || this._generatedId;\n  }\n  set id(value) {\n    this._id = value;\n  }\n  private _id: string;\n  private _generatedId = inject(_IdGenerator).getId('cdk-listbox-');\n\n  /** The tabindex to use when the listbox is enabled. */\n  @Input('tabindex')\n  get enabledTabIndex() {\n    return this._enabledTabIndex() === undefined ? 0 : this._enabledTabIndex();\n  }\n  set enabledTabIndex(value) {\n    this._enabledTabIndex.set(value);\n  }\n  private _enabledTabIndex = signal<number | null | undefined>(undefined);\n\n  /** The value selected in the listbox, represented as an array of option values. */\n  @Input('cdkListboxValue')\n  get value(): readonly T[] {\n    return this._invalid ? [] : this.selectionModel.selected;\n  }\n  set value(value: readonly T[]) {\n    this._setSelection(value);\n  }\n\n  /**\n   * Whether the listbox allows multiple options to be selected. If the value switches from `true`\n   * to `false`, and more than one option is selected, all options are deselected.\n   */\n  @Input({alias: 'cdkListboxMultiple', transform: booleanAttribute})\n  get multiple(): boolean {\n    return this.selectionModel.multiple;\n  }\n  set multiple(value: boolean) {\n    this.selectionModel.multiple = value;\n\n    if (this.options) {\n      this._updateInternalValue();\n    }\n  }\n\n  /** Whether the listbox is disabled. */\n  @Input({alias: 'cdkListboxDisabled', transform: booleanAttribute})\n  get disabled() {\n    return this._disabled();\n  }\n  set disabled(value: boolean) {\n    this._disabled.set(value);\n  }\n  private _disabled = signal(false);\n\n  /** Whether the listbox will use active descendant or will move focus onto the options. */\n  @Input({alias: 'cdkListboxUseActiveDescendant', transform: booleanAttribute})\n  get useActiveDescendant() {\n    return this._useActiveDescendant();\n  }\n  set useActiveDescendant(value: boolean) {\n    this._useActiveDescendant.set(value);\n  }\n  private _useActiveDescendant = signal(false);\n\n  /** The orientation of the listbox. Only affects keyboard interaction, not visual layout. */\n  @Input('cdkListboxOrientation')\n  get orientation() {\n    return this._orientation;\n  }\n  set orientation(value: 'horizontal' | 'vertical') {\n    this._orientation = value === 'horizontal' ? 'horizontal' : 'vertical';\n    if (value === 'horizontal') {\n      this.listKeyManager?.withHorizontalOrientation(this._dir?.value || 'ltr');\n    } else {\n      this.listKeyManager?.withVerticalOrientation();\n    }\n  }\n  private _orientation: 'horizontal' | 'vertical' = 'vertical';\n\n  /** The function used to compare option values. */\n  @Input('cdkListboxCompareWith')\n  get compareWith(): undefined | ((o1: T, o2: T) => boolean) {\n    return this.selectionModel.compareWith;\n  }\n  set compareWith(fn: undefined | ((o1: T, o2: T) => boolean)) {\n    this.selectionModel.compareWith = fn;\n  }\n\n  /**\n   * Whether the keyboard navigation should wrap when the user presses arrow down on the last item\n   * or arrow up on the first item.\n   */\n  @Input({alias: 'cdkListboxNavigationWrapDisabled', transform: booleanAttribute})\n  get navigationWrapDisabled() {\n    return this._navigationWrapDisabled;\n  }\n  set navigationWrapDisabled(wrap: boolean) {\n    this._navigationWrapDisabled = wrap;\n    this.listKeyManager?.withWrap(!this._navigationWrapDisabled);\n  }\n  private _navigationWrapDisabled = false;\n\n  /** Whether keyboard navigation should skip over disabled items. */\n  @Input({alias: 'cdkListboxNavigatesDisabledOptions', transform: booleanAttribute})\n  get navigateDisabledOptions() {\n    return this._navigateDisabledOptions;\n  }\n  set navigateDisabledOptions(skip: boolean) {\n    this._navigateDisabledOptions = skip;\n    this.listKeyManager?.skipPredicate(\n      this._navigateDisabledOptions ? this._skipNonePredicate : this._skipDisabledPredicate,\n    );\n  }\n  private _navigateDisabledOptions = false;\n\n  /** Emits when the selected value(s) in the listbox change. */\n  @Output('cdkListboxValueChange') readonly valueChange = new Subject<ListboxValueChangeEvent<T>>();\n\n  /** The child options in this listbox. */\n  @ContentChildren(CdkOption, {descendants: true}) protected options: QueryList<CdkOption<T>>;\n\n  /** The selection model used by the listbox. */\n  protected selectionModel = new ListboxSelectionModel<T>();\n\n  /** The key manager that manages keyboard navigation for this listbox. */\n  protected listKeyManager: ActiveDescendantKeyManager<CdkOption<T>>;\n\n  /** Emits when the listbox is destroyed. */\n  protected readonly destroyed = new Subject<void>();\n\n  /** The host element of the listbox. */\n  protected readonly element: HTMLElement = inject(ElementRef).nativeElement;\n\n  /** The Angular zone. */\n  protected readonly ngZone = inject(NgZone);\n\n  /** The change detector for this listbox. */\n  protected readonly changeDetectorRef = inject(ChangeDetectorRef);\n\n  /** Whether the currently selected value in the selection model is invalid. */\n  private _invalid = false;\n\n  /** The last user-triggered option. */\n  private _lastTriggered: CdkOption<T> | null = null;\n\n  /** Callback called when the listbox has been touched */\n  private _onTouched = () => {};\n\n  /** Callback called when the listbox value changes */\n  private _onChange: (value: readonly T[]) => void = () => {};\n\n  /** Emits when an option has been clicked. */\n  private _optionClicked = defer(() =>\n    (this.options.changes as Observable<CdkOption<T>[]>).pipe(\n      startWith(this.options),\n      switchMap(options =>\n        merge(...options.map(option => option._clicked.pipe(map(event => ({option, event}))))),\n      ),\n    ),\n  );\n\n  /** The directionality of the page. */\n  private readonly _dir = inject(Directionality, {optional: true});\n\n  /** Whether the component is being rendered in the browser. */\n  private readonly _isBrowser: boolean = inject(Platform).isBrowser;\n\n  /** A predicate that skips disabled options. */\n  private readonly _skipDisabledPredicate = (option: CdkOption<T>) => option.disabled;\n\n  /** A predicate that does not skip any options. */\n  private readonly _skipNonePredicate = () => false;\n\n  /** Whether the listbox currently has focus. */\n  private _hasFocus = false;\n\n  /** A reference to the option that was active before the listbox lost focus. */\n  private _previousActiveOption: CdkOption<T> | null = null;\n\n  constructor() {\n    if (this._isBrowser) {\n      const renderer = inject(Renderer2);\n\n      this._cleanupWindowBlur = this.ngZone.runOutsideAngular(() => {\n        return renderer.listen('window', 'blur', () => {\n          if (this.element.contains(document.activeElement) && this._previousActiveOption) {\n            this._setActiveOption(this._previousActiveOption);\n            this._previousActiveOption = null;\n          }\n        });\n      });\n    }\n  }\n\n  ngAfterContentInit() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      this._verifyNoOptionValueCollisions();\n      this._verifyOptionValues();\n    }\n\n    this._initKeyManager();\n\n    // Update the internal value whenever the options or the model value changes.\n    merge(this.selectionModel.changed, this.options.changes)\n      .pipe(startWith(null), takeUntil(this.destroyed))\n      .subscribe(() => this._updateInternalValue());\n\n    this._optionClicked\n      .pipe(\n        filter(({option}) => !option.disabled),\n        takeUntil(this.destroyed),\n      )\n      .subscribe(({option, event}) => this._handleOptionClicked(option, event));\n  }\n\n  ngOnDestroy() {\n    this._cleanupWindowBlur?.();\n    this.listKeyManager?.destroy();\n    this.destroyed.next();\n    this.destroyed.complete();\n  }\n\n  /**\n   * Toggle the selected state of the given option.\n   * @param option The option to toggle\n   */\n  toggle(option: CdkOption<T>) {\n    this.toggleValue(option.value);\n  }\n\n  /**\n   * Toggle the selected state of the given value.\n   * @param value The value to toggle\n   */\n  toggleValue(value: T) {\n    if (this._invalid) {\n      this.selectionModel.clear(false);\n    }\n    this.selectionModel.toggle(value);\n  }\n\n  /**\n   * Select the given option.\n   * @param option The option to select\n   */\n  select(option: CdkOption<T>) {\n    this.selectValue(option.value);\n  }\n\n  /**\n   * Select the given value.\n   * @param value The value to select\n   */\n  selectValue(value: T) {\n    if (this._invalid) {\n      this.selectionModel.clear(false);\n    }\n    this.selectionModel.select(value);\n  }\n\n  /**\n   * Deselect the given option.\n   * @param option The option to deselect\n   */\n  deselect(option: CdkOption<T>) {\n    this.deselectValue(option.value);\n  }\n\n  /**\n   * Deselect the given value.\n   * @param value The value to deselect\n   */\n  deselectValue(value: T) {\n    if (this._invalid) {\n      this.selectionModel.clear(false);\n    }\n    this.selectionModel.deselect(value);\n  }\n\n  /**\n   * Set the selected state of all options.\n   * @param isSelected The new selected state to set\n   */\n  setAllSelected(isSelected: boolean) {\n    if (!isSelected) {\n      this.selectionModel.clear();\n    } else {\n      if (this._invalid) {\n        this.selectionModel.clear(false);\n      }\n      this.selectionModel.select(...this.options.map(option => option.value));\n    }\n  }\n\n  /**\n   * Get whether the given option is selected.\n   * @param option The option to get the selected state of\n   */\n  isSelected(option: CdkOption<T>) {\n    return this.isValueSelected(option.value);\n  }\n\n  /**\n   * Get whether the given option is active.\n   * @param option The option to get the active state of\n   */\n  isActive(option: CdkOption<T>): boolean {\n    return !!(this.listKeyManager?.activeItem === option);\n  }\n\n  /**\n   * Get whether the given value is selected.\n   * @param value The value to get the selected state of\n   */\n  isValueSelected(value: T) {\n    if (this._invalid) {\n      return false;\n    }\n    return this.selectionModel.isSelected(value);\n  }\n\n  /**\n   * Registers a callback to be invoked when the listbox's value changes from user input.\n   * @param fn The callback to register\n   * @docs-private\n   */\n  registerOnChange(fn: (value: readonly T[]) => void): void {\n    this._onChange = fn;\n  }\n\n  /**\n   * Registers a callback to be invoked when the listbox is blurred by the user.\n   * @param fn The callback to register\n   * @docs-private\n   */\n  registerOnTouched(fn: () => {}): void {\n    this._onTouched = fn;\n  }\n\n  /**\n   * Sets the listbox's value.\n   * @param value The new value of the listbox\n   * @docs-private\n   */\n  writeValue(value: readonly T[]): void {\n    this._setSelection(value);\n    this._verifyOptionValues();\n  }\n\n  /**\n   * Sets the disabled state of the listbox.\n   * @param isDisabled The new disabled state\n   * @docs-private\n   */\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n    this.changeDetectorRef.markForCheck();\n  }\n\n  /** Focus the listbox's host element. */\n  focus() {\n    this.element.focus();\n  }\n\n  /**\n   * Triggers the given option in response to user interaction.\n   * - In single selection mode: selects the option and deselects any other selected option.\n   * - In multi selection mode: toggles the selected state of the option.\n   * @param option The option to trigger\n   */\n  protected triggerOption(option: CdkOption<T> | null) {\n    if (option && !option.disabled) {\n      this._lastTriggered = option;\n      const changed = this.multiple\n        ? this.selectionModel.toggle(option.value)\n        : this.selectionModel.select(option.value);\n      if (changed) {\n        this._onChange(this.value);\n        this.valueChange.next({\n          value: this.value,\n          listbox: this,\n          option: option,\n        });\n      }\n    }\n  }\n\n  /**\n   * Trigger the given range of options in response to user interaction.\n   * Should only be called in multi-selection mode.\n   * @param trigger The option that was triggered\n   * @param from The start index of the options to toggle\n   * @param to The end index of the options to toggle\n   * @param on Whether to toggle the option range on\n   */\n  protected triggerRange(trigger: CdkOption<T> | null, from: number, to: number, on: boolean) {\n    if (this.disabled || (trigger && trigger.disabled)) {\n      return;\n    }\n    this._lastTriggered = trigger;\n    const isEqual = this.compareWith ?? Object.is;\n    const updateValues = [...this.options]\n      .slice(Math.max(0, Math.min(from, to)), Math.min(this.options.length, Math.max(from, to) + 1))\n      .filter(option => !option.disabled)\n      .map(option => option.value);\n    const selected = [...this.value];\n    for (const updateValue of updateValues) {\n      const selectedIndex = selected.findIndex(selectedValue =>\n        isEqual(selectedValue, updateValue),\n      );\n      if (on && selectedIndex === -1) {\n        selected.push(updateValue);\n      } else if (!on && selectedIndex !== -1) {\n        selected.splice(selectedIndex, 1);\n      }\n    }\n    let changed = this.selectionModel.setSelection(...selected);\n    if (changed) {\n      this._onChange(this.value);\n      this.valueChange.next({\n        value: this.value,\n        listbox: this,\n        option: trigger,\n      });\n    }\n  }\n\n  /**\n   * Sets the given option as active.\n   * @param option The option to make active\n   */\n  _setActiveOption(option: CdkOption<T>) {\n    this.listKeyManager.setActiveItem(option);\n  }\n\n  /** Called when the listbox receives focus. */\n  protected _handleFocus() {\n    if (!this.useActiveDescendant) {\n      if (this.selectionModel.selected.length > 0) {\n        this._setNextFocusToSelectedOption();\n      } else {\n        this.listKeyManager.setNextItemActive();\n      }\n\n      this._focusActiveOption();\n    }\n  }\n\n  /** Called when the user presses keydown on the listbox. */\n  protected _handleKeydown(event: KeyboardEvent) {\n    if (this.disabled) {\n      return;\n    }\n\n    const {keyCode} = event;\n    const previousActiveIndex = this.listKeyManager.activeItemIndex;\n    const ctrlKeys = ['ctrlKey', 'metaKey'] as const;\n\n    if (this.multiple && keyCode === A && hasModifierKey(event, ...ctrlKeys)) {\n      // Toggle all options off if they're all selected, otherwise toggle them all on.\n      this.triggerRange(\n        null,\n        0,\n        this.options.length - 1,\n        this.options.length !== this.value.length,\n      );\n      event.preventDefault();\n      return;\n    }\n\n    if (\n      this.multiple &&\n      (keyCode === SPACE || keyCode === ENTER) &&\n      hasModifierKey(event, 'shiftKey')\n    ) {\n      if (this.listKeyManager.activeItem && this.listKeyManager.activeItemIndex != null) {\n        this.triggerRange(\n          this.listKeyManager.activeItem,\n          this._getLastTriggeredIndex() ?? this.listKeyManager.activeItemIndex,\n          this.listKeyManager.activeItemIndex,\n          !this.listKeyManager.activeItem.isSelected(),\n        );\n      }\n      event.preventDefault();\n      return;\n    }\n\n    if (\n      this.multiple &&\n      keyCode === HOME &&\n      hasModifierKey(event, ...ctrlKeys) &&\n      hasModifierKey(event, 'shiftKey')\n    ) {\n      const trigger = this.listKeyManager.activeItem;\n      if (trigger) {\n        const from = this.listKeyManager.activeItemIndex!;\n        this.listKeyManager.setFirstItemActive();\n        this.triggerRange(\n          trigger,\n          from,\n          this.listKeyManager.activeItemIndex!,\n          !trigger.isSelected(),\n        );\n      }\n      event.preventDefault();\n      return;\n    }\n\n    if (\n      this.multiple &&\n      keyCode === END &&\n      hasModifierKey(event, ...ctrlKeys) &&\n      hasModifierKey(event, 'shiftKey')\n    ) {\n      const trigger = this.listKeyManager.activeItem;\n      if (trigger) {\n        const from = this.listKeyManager.activeItemIndex!;\n        this.listKeyManager.setLastItemActive();\n        this.triggerRange(\n          trigger,\n          from,\n          this.listKeyManager.activeItemIndex!,\n          !trigger.isSelected(),\n        );\n      }\n      event.preventDefault();\n      return;\n    }\n\n    if (keyCode === SPACE || keyCode === ENTER) {\n      this.triggerOption(this.listKeyManager.activeItem);\n      event.preventDefault();\n      return;\n    }\n\n    const isNavKey =\n      keyCode === UP_ARROW ||\n      keyCode === DOWN_ARROW ||\n      keyCode === LEFT_ARROW ||\n      keyCode === RIGHT_ARROW ||\n      keyCode === HOME ||\n      keyCode === END;\n    this.listKeyManager.onKeydown(event);\n    // Will select an option if shift was pressed while navigating to the option\n    if (isNavKey && event.shiftKey && previousActiveIndex !== this.listKeyManager.activeItemIndex) {\n      this.triggerOption(this.listKeyManager.activeItem);\n    }\n  }\n\n  /** Called when a focus moves into the listbox. */\n  protected _handleFocusIn() {\n    // Note that we use a `focusin` handler for this instead of the existing `focus` handler,\n    // because focus won't land on the listbox if `useActiveDescendant` is enabled.\n    this._hasFocus = true;\n  }\n\n  /**\n   * Called when the focus leaves an element in the listbox.\n   * @param event The focusout event\n   */\n  protected _handleFocusOut(event: FocusEvent) {\n    // Some browsers (e.g. Chrome and Firefox) trigger the focusout event when the user returns back to the document.\n    // To prevent losing the active option in this case, we store it in `_previousActiveOption` and restore it on the window `blur` event\n    // This ensures that the `activeItem` matches the actual focused element when the user returns to the document.\n    this._previousActiveOption = this.listKeyManager.activeItem;\n\n    const otherElement = event.relatedTarget as Element;\n    if (this.element !== otherElement && !this.element.contains(otherElement)) {\n      this._onTouched();\n      this._hasFocus = false;\n      this._setNextFocusToSelectedOption();\n    }\n  }\n\n  /** Get the id of the active option if active descendant is being used. */\n  protected _getAriaActiveDescendant(): string | null | undefined {\n    return this.useActiveDescendant ? this.listKeyManager?.activeItem?.id : null;\n  }\n\n  /** Get the tabindex for the listbox. */\n  protected _getTabIndex() {\n    if (this.disabled) {\n      return -1;\n    }\n    return this.useActiveDescendant || !this.listKeyManager.activeItem ? this.enabledTabIndex : -1;\n  }\n\n  /** Initialize the key manager. */\n  private _initKeyManager() {\n    this.listKeyManager = new ActiveDescendantKeyManager(this.options)\n      .withWrap(!this._navigationWrapDisabled)\n      .withTypeAhead()\n      .withHomeAndEnd()\n      .withAllowedModifierKeys(['shiftKey'])\n      .skipPredicate(\n        this._navigateDisabledOptions ? this._skipNonePredicate : this._skipDisabledPredicate,\n      );\n\n    if (this.orientation === 'vertical') {\n      this.listKeyManager.withVerticalOrientation();\n    } else {\n      this.listKeyManager.withHorizontalOrientation(this._dir?.value || 'ltr');\n    }\n\n    if (this.selectionModel.selected.length) {\n      Promise.resolve().then(() => this._setNextFocusToSelectedOption());\n    }\n\n    this.listKeyManager.change.subscribe(() => this._focusActiveOption());\n\n    this.options.changes.pipe(takeUntil(this.destroyed)).subscribe(() => {\n      const activeOption = this.listKeyManager.activeItem;\n\n      // If the active option was deleted, we need to reset\n      // the key manager so it can allow focus back in.\n      if (activeOption && !this.options.find(option => option === activeOption)) {\n        this.listKeyManager.setActiveItem(-1);\n        this.changeDetectorRef.markForCheck();\n      }\n    });\n  }\n\n  /** Focus the active option. */\n  private _focusActiveOption() {\n    if (!this.useActiveDescendant) {\n      this.listKeyManager.activeItem?.focus();\n    }\n    this.changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Set the selected values.\n   * @param value The list of new selected values.\n   */\n  private _setSelection(value: readonly T[]) {\n    if (this._invalid) {\n      this.selectionModel.clear(false);\n    }\n    this.selectionModel.setSelection(...this._coerceValue(value));\n\n    if (!this._hasFocus) {\n      this._setNextFocusToSelectedOption();\n    }\n  }\n\n  /** Sets the first selected option as first in the keyboard focus order. */\n  private _setNextFocusToSelectedOption() {\n    // Null check the options since they only get defined after `ngAfterContentInit`.\n    const selected = this.options?.find(option => option.isSelected());\n\n    if (selected) {\n      this.listKeyManager.updateActiveItem(selected);\n    }\n  }\n\n  /** Update the internal value of the listbox based on the selection model. */\n  private _updateInternalValue() {\n    const indexCache = new Map<T, number>();\n    this.selectionModel.sort((a: T, b: T) => {\n      const aIndex = this._getIndexForValue(indexCache, a);\n      const bIndex = this._getIndexForValue(indexCache, b);\n      return aIndex - bIndex;\n    });\n    const selected = this.selectionModel.selected;\n    this._invalid =\n      (!this.multiple && selected.length > 1) || !!this._getInvalidOptionValues(selected).length;\n    this.changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Gets the index of the given value in the given list of options.\n   * @param cache The cache of indices found so far\n   * @param value The value to find\n   * @return The index of the value in the options list\n   */\n  private _getIndexForValue(cache: Map<T, number>, value: T) {\n    const isEqual = this.compareWith || Object.is;\n    if (!cache.has(value)) {\n      let index = -1;\n      for (let i = 0; i < this.options.length; i++) {\n        if (isEqual(value, this.options.get(i)!.value)) {\n          index = i;\n          break;\n        }\n      }\n      cache.set(value, index);\n    }\n    return cache.get(value)!;\n  }\n\n  /**\n   * Handle the user clicking an option.\n   * @param option The option that was clicked.\n   */\n  private _handleOptionClicked(option: CdkOption<T>, event: MouseEvent) {\n    event.preventDefault();\n    this.listKeyManager.setActiveItem(option);\n    if (event.shiftKey && this.multiple) {\n      this.triggerRange(\n        option,\n        this._getLastTriggeredIndex() ?? this.listKeyManager.activeItemIndex!,\n        this.listKeyManager.activeItemIndex!,\n        !option.isSelected(),\n      );\n    } else {\n      this.triggerOption(option);\n    }\n  }\n\n  /** Verifies that no two options represent the same value under the compareWith function. */\n  private _verifyNoOptionValueCollisions() {\n    this.options.changes.pipe(startWith(this.options), takeUntil(this.destroyed)).subscribe(() => {\n      const isEqual = this.compareWith ?? Object.is;\n      for (let i = 0; i < this.options.length; i++) {\n        const option = this.options.get(i)!;\n        let duplicate: CdkOption<T> | null = null;\n        for (let j = i + 1; j < this.options.length; j++) {\n          const other = this.options.get(j)!;\n          if (isEqual(option.value, other.value)) {\n            duplicate = other;\n            break;\n          }\n        }\n        if (duplicate) {\n          // TODO(mmalerba): Link to docs about this.\n          if (this.compareWith) {\n            console.warn(\n              `Found multiple CdkOption representing the same value under the given compareWith function`,\n              {\n                option1: option.element,\n                option2: duplicate.element,\n                compareWith: this.compareWith,\n              },\n            );\n          } else {\n            console.warn(`Found multiple CdkOption with the same value`, {\n              option1: option.element,\n              option2: duplicate.element,\n            });\n          }\n          return;\n        }\n      }\n    });\n  }\n\n  /** Verifies that the option values are valid. */\n  private _verifyOptionValues() {\n    if (this.options && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      const selected = this.selectionModel.selected;\n      const invalidValues = this._getInvalidOptionValues(selected);\n\n      if (!this.multiple && selected.length > 1) {\n        throw Error('Listbox cannot have more than one selected value in multi-selection mode.');\n      }\n\n      if (invalidValues.length) {\n        throw Error('Listbox has selected values that do not match any of its options.');\n      }\n    }\n  }\n\n  /**\n   * Coerces a value into an array representing a listbox selection.\n   * @param value The value to coerce\n   * @return An array\n   */\n  private _coerceValue(value: readonly T[]) {\n    return value == null ? [] : coerceArray(value);\n  }\n\n  /**\n   * Get the sublist of values that do not represent valid option values in this listbox.\n   * @param values The list of values\n   * @return The sublist of values that are not valid option values\n   */\n  private _getInvalidOptionValues(values: readonly T[]) {\n    const isEqual = this.compareWith || Object.is;\n    const validValues = (this.options || []).map(option => option.value);\n    return values.filter(value => !validValues.some(validValue => isEqual(value, validValue)));\n  }\n\n  /** Get the index of the last triggered option. */\n  private _getLastTriggeredIndex() {\n    const index = this.options.toArray().indexOf(this._lastTriggered!);\n    return index === -1 ? null : index;\n  }\n}\n\n/** Change event that is fired whenever the value of the listbox changes. */\nexport interface ListboxValueChangeEvent<T> {\n  /** The new value of the listbox. */\n  readonly value: readonly T[];\n\n  /** Reference to the listbox that emitted the event. */\n  readonly listbox: CdkListbox<T>;\n\n  /** Reference to the option that was triggered. */\n  readonly option: CdkOption<T> | null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {CdkListbox, CdkOption} from './listbox';\n\nconst EXPORTED_DECLARATIONS = [CdkListbox, CdkOption];\n\n@NgModule({\n  imports: [...EXPORTED_DECLARATIONS],\n  exports: [...EXPORTED_DECLARATIONS],\n})\nexport class CdkListboxModule {}\n"],"names":["multiple","select","values","setSelection","CdkOption","_id","_generatedId","value","inject","_IdGenerator","getId","typeaheadLabel","disabled","_disabled","set","signal","ngDevMode","debugName","enabledTabIndex","_enabledTabIndex","undefined","ElementRef","nativeElement","CdkListbox","isSelected","listbox","isActive","toggle","focus","element","textContent","trim","setActiveStyles","useActiveDescendant","setInactiveStyles","_setActiveOption","_getTabIndex","version","ngImport","i0","type","deps","target","ɵɵFactoryTarget","Directive","ɵdir","ɵɵngDeclareDirective","minVersion","isStandalone","selector","inputs","id","booleanAttribute","numberAttribute","host","attributes","listeners","properties","classAttribute","exportAs","decorators","args","Input","transform","alias","selectionModel","_updateInternalValue","_useActiveDescendant","orientation","_orientation","listKeyManager","withHorizontalOrientation","_dir","withVerticalOrientation","compareWith","fn","navigationWrapDisabled","_navigationWrapDisabled","navigateDisabledOptions","skip","_navigateDisabledOptions","_skipNonePredicate","_skipDisabledPredicate","ngZone","NgZone","_lastTriggered","_onTouched","_optionClicked","defer","options","changes","pipe","startWith","switchMap","merge","map","option","_clicked","event","_isBrowser","Platform","isBrowser","_hasFocus","_previousActiveOption","renderer","Renderer2","_cleanupWindowBlur","runOutsideAngular","listen","_verifyOptionValues","_initKeyManager","filter","takeUntil","destroyed","subscribe","_handleOptionClicked","next","complete","clear","selectValue","_invalid","deselect","deselectValue","setAllSelected","isValueSelected","registerOnChange","_onChange","writeValue","_setSelection","changeDetectorRef","markForCheck","changed","valueChange","updateValues","slice","Math","min","from","to","length","max","selected","updateValue","selectedIndex","findIndex","selectedValue","isEqual","on","push","splice","trigger","setActiveItem","_setNextFocusToSelectedOption","_focusActiveOption","_handleKeydown","previousActiveIndex","activeItemIndex","keyCode","A","hasModifierKey","ctrlKeys","triggerRange","SPACE","ENTER","activeItem","preventDefault","setFirstItemActive","END","setLastItemActive","triggerOption","LEFT_ARROW","RIGHT_ARROW","HOME","onKeydown","shiftKey","_handleFocusIn","ActiveDescendantKeyManager","withWrap","withTypeAhead","withHomeAndEnd","withAllowedModifierKeys","skipPredicate","Promise","resolve","then","change","activeOption","find","NG_VALUE_ACCESSOR","forwardRef","multi","ctorParameters","propDecorators","Output","ContentChildren","descendants","ɵmod","ɵɵngDeclareNgModule","CdkListboxModule","imports","exports","NgModule"],"mappings":"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"}