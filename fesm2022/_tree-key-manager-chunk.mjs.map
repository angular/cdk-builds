{"version":3,"file":"_tree-key-manager-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/a11y/key-manager/tree-key-manager.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken, QueryList} from '@angular/core';\nimport {coerceObservable} from '../../coercion/private';\nimport {Observable, Subject, Subscription, isObservable, of as observableOf} from 'rxjs';\nimport {take} from 'rxjs/operators';\nimport {\n  TreeKeyManagerFactory,\n  TreeKeyManagerItem,\n  TreeKeyManagerOptions,\n  TreeKeyManagerStrategy,\n} from './tree-key-manager-strategy';\nimport {Typeahead} from './typeahead';\n\n/**\n * This class manages keyboard events for trees. If you pass it a QueryList or other list of tree\n * items, it will set the active item, focus, handle expansion and typeahead correctly when\n * keyboard events occur.\n */\nexport class TreeKeyManager<T extends TreeKeyManagerItem> implements TreeKeyManagerStrategy<T> {\n  /** The index of the currently active (focused) item. */\n  private _activeItemIndex = -1;\n  /** The currently active (focused) item. */\n  private _activeItem: T | null = null;\n  /** Whether or not we activate the item when it's focused. */\n  private _shouldActivationFollowFocus = false;\n  /**\n   * The orientation that the tree is laid out in. In `rtl` mode, the behavior of Left and\n   * Right arrow are switched.\n   */\n  private _horizontalOrientation: 'ltr' | 'rtl' = 'ltr';\n\n  /**\n   * Predicate function that can be used to check whether an item should be skipped\n   * by the key manager.\n   *\n   * The default value for this doesn't skip any elements in order to keep tree items focusable\n   * when disabled. This aligns with ARIA guidelines:\n   * https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#focusabilityofdisabledcontrols.\n   */\n  private _skipPredicateFn = (_item: T) => false;\n\n  /** Function to determine equivalent items. */\n  private _trackByFn: (item: T) => unknown = (item: T) => item;\n\n  /** Synchronous cache of the items to manage. */\n  private _items: T[] = [];\n\n  private _typeahead?: Typeahead<T>;\n  private _typeaheadSubscription = Subscription.EMPTY;\n\n  private _hasInitialFocused = false;\n\n  private _initializeFocus(): void {\n    if (this._hasInitialFocused || this._items.length === 0) {\n      return;\n    }\n\n    let activeIndex = 0;\n    for (let i = 0; i < this._items.length; i++) {\n      if (!this._skipPredicateFn(this._items[i]) && !this._isItemDisabled(this._items[i])) {\n        activeIndex = i;\n        break;\n      }\n    }\n\n    const activeItem = this._items[activeIndex];\n\n    // Use `makeFocusable` here, because we want the item to just be focusable, not actually\n    // capture the focus since the user isn't interacting with it. See #29628.\n    if (activeItem.makeFocusable) {\n      this._activeItem?.unfocus();\n      this._activeItemIndex = activeIndex;\n      this._activeItem = activeItem;\n      this._typeahead?.setCurrentSelectedItemIndex(activeIndex);\n      activeItem.makeFocusable();\n    } else {\n      // Backwards compatibility for items that don't implement `makeFocusable`.\n      this.focusItem(activeIndex);\n    }\n\n    this._hasInitialFocused = true;\n  }\n\n  /**\n   *\n   * @param items List of TreeKeyManager options. Can be synchronous or asynchronous.\n   * @param config Optional configuration options. By default, use 'ltr' horizontal orientation. By\n   * default, do not skip any nodes. By default, key manager only calls `focus` method when items\n   * are focused and does not call `activate`. If `typeaheadDefaultInterval` is `true`, use a\n   * default interval of 200ms.\n   */\n  constructor(items: Observable<T[]> | QueryList<T> | T[], config: TreeKeyManagerOptions<T>) {\n    // We allow for the items to be an array or Observable because, in some cases, the consumer may\n    // not have access to a QueryList of the items they want to manage (e.g. when the\n    // items aren't being collected via `ViewChildren` or `ContentChildren`).\n    if (items instanceof QueryList) {\n      this._items = items.toArray();\n      items.changes.subscribe((newItems: QueryList<T>) => {\n        this._items = newItems.toArray();\n        this._typeahead?.setItems(this._items);\n        this._updateActiveItemIndex(this._items);\n        this._initializeFocus();\n      });\n    } else if (isObservable(items)) {\n      items.subscribe(newItems => {\n        this._items = newItems;\n        this._typeahead?.setItems(newItems);\n        this._updateActiveItemIndex(newItems);\n        this._initializeFocus();\n      });\n    } else {\n      this._items = items;\n      this._initializeFocus();\n    }\n\n    if (typeof config.shouldActivationFollowFocus === 'boolean') {\n      this._shouldActivationFollowFocus = config.shouldActivationFollowFocus;\n    }\n    if (config.horizontalOrientation) {\n      this._horizontalOrientation = config.horizontalOrientation;\n    }\n    if (config.skipPredicate) {\n      this._skipPredicateFn = config.skipPredicate;\n    }\n    if (config.trackBy) {\n      this._trackByFn = config.trackBy;\n    }\n    if (typeof config.typeAheadDebounceInterval !== 'undefined') {\n      this._setTypeAhead(config.typeAheadDebounceInterval);\n    }\n  }\n\n  /** Stream that emits any time the focused item changes. */\n  readonly change = new Subject<T | null>();\n\n  /** Cleans up the key manager. */\n  destroy() {\n    this._typeaheadSubscription.unsubscribe();\n    this._typeahead?.destroy();\n    this.change.complete();\n  }\n\n  /**\n   * Handles a keyboard event on the tree.\n   * @param event Keyboard event that represents the user interaction with the tree.\n   */\n  onKeydown(event: KeyboardEvent) {\n    const key = event.key;\n\n    switch (key) {\n      case 'Tab':\n        // Return early here, in order to allow Tab to actually tab out of the tree\n        return;\n\n      case 'ArrowDown':\n        this._focusNextItem();\n        break;\n\n      case 'ArrowUp':\n        this._focusPreviousItem();\n        break;\n\n      case 'ArrowRight':\n        this._horizontalOrientation === 'rtl'\n          ? this._collapseCurrentItem()\n          : this._expandCurrentItem();\n        break;\n\n      case 'ArrowLeft':\n        this._horizontalOrientation === 'rtl'\n          ? this._expandCurrentItem()\n          : this._collapseCurrentItem();\n        break;\n\n      case 'Home':\n        this._focusFirstItem();\n        break;\n\n      case 'End':\n        this._focusLastItem();\n        break;\n\n      case 'Enter':\n      case ' ':\n        this._activateCurrentItem();\n        break;\n\n      default:\n        if (event.key === '*') {\n          this._expandAllItemsAtCurrentItemLevel();\n          break;\n        }\n\n        this._typeahead?.handleKey(event);\n        // Return here, in order to avoid preventing the default action of non-navigational\n        // keys or resetting the buffer of pressed letters.\n        return;\n    }\n\n    // Reset the typeahead since the user has used a navigational key.\n    this._typeahead?.reset();\n    event.preventDefault();\n  }\n\n  /** Index of the currently active item. */\n  getActiveItemIndex(): number | null {\n    return this._activeItemIndex;\n  }\n\n  /** The currently active item. */\n  getActiveItem(): T | null {\n    return this._activeItem;\n  }\n\n  /** Focus the first available item. */\n  private _focusFirstItem(): void {\n    this.focusItem(this._findNextAvailableItemIndex(-1));\n  }\n\n  /** Focus the last available item. */\n  private _focusLastItem(): void {\n    this.focusItem(this._findPreviousAvailableItemIndex(this._items.length));\n  }\n\n  /** Focus the next available item. */\n  private _focusNextItem(): void {\n    this.focusItem(this._findNextAvailableItemIndex(this._activeItemIndex));\n  }\n\n  /** Focus the previous available item. */\n  private _focusPreviousItem(): void {\n    this.focusItem(this._findPreviousAvailableItemIndex(this._activeItemIndex));\n  }\n\n  /**\n   * Focus the provided item by index.\n   * @param index The index of the item to focus.\n   * @param options Additional focusing options.\n   */\n  focusItem(index: number, options?: {emitChangeEvent?: boolean}): void;\n  focusItem(item: T, options?: {emitChangeEvent?: boolean}): void;\n  focusItem(itemOrIndex: number | T, options?: {emitChangeEvent?: boolean}): void;\n  focusItem(itemOrIndex: number | T, options: {emitChangeEvent?: boolean} = {}) {\n    // Set default options\n    options.emitChangeEvent ??= true;\n\n    let index =\n      typeof itemOrIndex === 'number'\n        ? itemOrIndex\n        : this._items.findIndex(item => this._trackByFn(item) === this._trackByFn(itemOrIndex));\n    if (index < 0 || index >= this._items.length) {\n      return;\n    }\n    const activeItem = this._items[index];\n\n    // If we're just setting the same item, don't re-call activate or focus\n    if (\n      this._activeItem !== null &&\n      this._trackByFn(activeItem) === this._trackByFn(this._activeItem)\n    ) {\n      return;\n    }\n\n    const previousActiveItem = this._activeItem;\n    this._activeItem = activeItem ?? null;\n    this._activeItemIndex = index;\n    this._typeahead?.setCurrentSelectedItemIndex(index);\n\n    this._activeItem?.focus();\n    previousActiveItem?.unfocus();\n\n    if (options.emitChangeEvent) {\n      this.change.next(this._activeItem);\n    }\n\n    if (this._shouldActivationFollowFocus) {\n      this._activateCurrentItem();\n    }\n  }\n\n  private _updateActiveItemIndex(newItems: T[]) {\n    const activeItem = this._activeItem;\n    if (!activeItem) {\n      return;\n    }\n\n    const newIndex = newItems.findIndex(\n      item => this._trackByFn(item) === this._trackByFn(activeItem),\n    );\n\n    if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n      this._activeItemIndex = newIndex;\n      this._typeahead?.setCurrentSelectedItemIndex(newIndex);\n    }\n  }\n\n  private _setTypeAhead(debounceInterval: number | boolean) {\n    this._typeahead = new Typeahead(this._items, {\n      debounceInterval: typeof debounceInterval === 'number' ? debounceInterval : undefined,\n      skipPredicate: item => this._skipPredicateFn(item),\n    });\n\n    this._typeaheadSubscription = this._typeahead.selectedItem.subscribe(item => {\n      this.focusItem(item);\n    });\n  }\n\n  private _findNextAvailableItemIndex(startingIndex: number) {\n    for (let i = startingIndex + 1; i < this._items.length; i++) {\n      if (!this._skipPredicateFn(this._items[i])) {\n        return i;\n      }\n    }\n    return startingIndex;\n  }\n\n  private _findPreviousAvailableItemIndex(startingIndex: number) {\n    for (let i = startingIndex - 1; i >= 0; i--) {\n      if (!this._skipPredicateFn(this._items[i])) {\n        return i;\n      }\n    }\n    return startingIndex;\n  }\n\n  /**\n   * If the item is already expanded, we collapse the item. Otherwise, we will focus the parent.\n   */\n  private _collapseCurrentItem() {\n    if (!this._activeItem) {\n      return;\n    }\n\n    if (this._isCurrentItemExpanded()) {\n      this._activeItem.collapse();\n    } else {\n      const parent = this._activeItem.getParent();\n      if (!parent || this._skipPredicateFn(parent as T)) {\n        return;\n      }\n      this.focusItem(parent as T);\n    }\n  }\n\n  /**\n   * If the item is already collapsed, we expand the item. Otherwise, we will focus the first child.\n   */\n  private _expandCurrentItem() {\n    if (!this._activeItem) {\n      return;\n    }\n\n    if (!this._isCurrentItemExpanded()) {\n      this._activeItem.expand();\n    } else {\n      coerceObservable(this._activeItem.getChildren())\n        .pipe(take(1))\n        .subscribe(children => {\n          const firstChild = children.find(child => !this._skipPredicateFn(child as T));\n          if (!firstChild) {\n            return;\n          }\n          this.focusItem(firstChild as T);\n        });\n    }\n  }\n\n  private _isCurrentItemExpanded() {\n    if (!this._activeItem) {\n      return false;\n    }\n    return typeof this._activeItem.isExpanded === 'boolean'\n      ? this._activeItem.isExpanded\n      : this._activeItem.isExpanded();\n  }\n\n  private _isItemDisabled(item: TreeKeyManagerItem) {\n    return typeof item.isDisabled === 'boolean' ? item.isDisabled : item.isDisabled?.();\n  }\n\n  /** For all items that are the same level as the current item, we expand those items. */\n  private _expandAllItemsAtCurrentItemLevel() {\n    if (!this._activeItem) {\n      return;\n    }\n\n    const parent = this._activeItem.getParent();\n    let itemsToExpand;\n    if (!parent) {\n      itemsToExpand = observableOf(this._items.filter(item => item.getParent() === null));\n    } else {\n      itemsToExpand = coerceObservable(parent.getChildren());\n    }\n\n    itemsToExpand.pipe(take(1)).subscribe(items => {\n      for (const item of items) {\n        item.expand();\n      }\n    });\n  }\n\n  private _activateCurrentItem() {\n    this._activeItem?.activate();\n  }\n}\n\n/** Injection token that determines the key manager to use. */\nexport const TREE_KEY_MANAGER = new InjectionToken<TreeKeyManagerFactory<any>>('tree-key-manager', {\n  providedIn: 'root',\n  factory: () => (items, options) => new TreeKeyManager(items, options),\n});\n"],"names":["TreeKeyManager","_activeItemIndex","_horizontalOrientation","_hasInitialFocused","_items","length","activeIndex","i","_skipPredicateFn","_isItemDisabled","activeItem","_typeahead","setCurrentSelectedItemIndex","focusItem","newItems","toArray","setItems","_initializeFocus","isObservable","items","subscribe","_updateActiveItemIndex","config","shouldActivationFollowFocus","_shouldActivationFollowFocus","horizontalOrientation","skipPredicate","_trackByFn","trackBy","typeAheadDebounceInterval","_setTypeAhead","Subject","_typeaheadSubscription","unsubscribe","onKeydown","event","key","_focusNextItem","_expandCurrentItem","_collapseCurrentItem","_focusFirstItem","_focusLastItem","_activateCurrentItem","_expandAllItemsAtCurrentItemLevel","handleKey","reset","getActiveItem","_findNextAvailableItemIndex","_focusPreviousItem","itemOrIndex","options","findIndex","item","index","_activeItem","previousActiveItem","unfocus","emitChangeEvent","newIndex","Typeahead","debounceInterval","undefined","selectedItem","startingIndex","_findPreviousAvailableItemIndex","parent","getParent"],"mappings":"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"}