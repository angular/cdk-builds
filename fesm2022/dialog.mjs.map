{"version":3,"file":"dialog.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/dialog/dialog-config.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/dialog/dialog-container.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/dialog/dialog-ref.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/dialog/dialog-injectors.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/dialog/dialog.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/dialog/dialog-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ViewContainerRef, Injector, StaticProvider, Type} from '@angular/core';\nimport {Direction} from '../bidi';\nimport {PositionStrategy, ScrollStrategy} from '../overlay';\nimport {Observable} from 'rxjs';\nimport {BasePortalOutlet} from '../portal';\nimport {FocusOrigin} from '../a11y';\n\n/** Options for where to set focus to automatically on dialog open */\nexport type AutoFocusTarget = 'dialog' | 'first-tabbable' | 'first-heading';\n\n/** Valid ARIA roles for a dialog. */\nexport type DialogRole = 'dialog' | 'alertdialog';\n\n/** Component that can be used as the container for the dialog. */\nexport type DialogContainer = BasePortalOutlet & {\n  _focusTrapped?: Observable<void>;\n  _closeInteractionType?: FocusOrigin;\n  _recaptureFocus?: () => void;\n};\n\n/** Configuration for opening a modal dialog. */\nexport class DialogConfig<D = unknown, R = unknown, C extends DialogContainer = BasePortalOutlet> {\n  /**\n   * Where the attached component should live in Angular's *logical* component tree.\n   * This affects what is available for injection and the change detection order for the\n   * component instantiated inside of the dialog. This does not affect where the dialog\n   * content will be rendered.\n   */\n  viewContainerRef?: ViewContainerRef;\n\n  /**\n   * Injector used for the instantiation of the component to be attached. If provided,\n   * takes precedence over the injector indirectly provided by `ViewContainerRef`.\n   */\n  injector?: Injector;\n\n  /** ID for the dialog. If omitted, a unique one will be generated. */\n  id?: string;\n\n  /** The ARIA role of the dialog element. */\n  role?: DialogRole = 'dialog';\n\n  /** Optional CSS class or classes applied to the overlay panel. */\n  panelClass?: string | string[] = '';\n\n  /** Whether the dialog has a backdrop. */\n  hasBackdrop?: boolean = true;\n\n  /** Optional CSS class or classes applied to the overlay backdrop. */\n  backdropClass?: string | string[] = '';\n\n  /** Whether the dialog closes with the escape key or pointer events outside the panel element. */\n  disableClose?: boolean = false;\n\n  /** Function used to determine whether the dialog is allowed to close. */\n  closePredicate?: <\n    Result = unknown,\n    Component = unknown,\n    Config extends DialogConfig = DialogConfig,\n  >(\n    result: Result | undefined,\n    config: Config,\n    componentInstance: Component | null,\n  ) => boolean;\n\n  /** Width of the dialog. */\n  width?: string = '';\n\n  /** Height of the dialog. */\n  height?: string = '';\n\n  /** Min-width of the dialog. If a number is provided, assumes pixel units. */\n  minWidth?: number | string;\n\n  /** Min-height of the dialog. If a number is provided, assumes pixel units. */\n  minHeight?: number | string;\n\n  /** Max-width of the dialog. If a number is provided, assumes pixel units. */\n  maxWidth?: number | string;\n\n  /** Max-height of the dialog. If a number is provided, assumes pixel units. */\n  maxHeight?: number | string;\n\n  /** Strategy to use when positioning the dialog. Defaults to centering it on the page. */\n  positionStrategy?: PositionStrategy;\n\n  /** Data being injected into the child component. */\n  data?: D | null = null;\n\n  /** Layout direction for the dialog's content. */\n  direction?: Direction;\n\n  /** ID of the element that describes the dialog. */\n  ariaDescribedBy?: string | null = null;\n\n  /** ID of the element that labels the dialog. */\n  ariaLabelledBy?: string | null = null;\n\n  /** Dialog label applied via `aria-label` */\n  ariaLabel?: string | null = null;\n\n  /**\n   * Whether this is a modal dialog. Used to set the `aria-modal` attribute. Off by default,\n   * because it can interfere with other overlay-based components (e.g. `mat-select`) and because\n   * it is redundant since the dialog marks all outside content as `aria-hidden` anyway.\n   */\n  ariaModal?: boolean = false;\n\n  /**\n   * Where the dialog should focus on open.\n   * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or\n   * AutoFocusTarget instead.\n   */\n  autoFocus?: AutoFocusTarget | string | boolean = 'first-tabbable';\n\n  /**\n   * Whether the dialog should restore focus to the previously-focused element upon closing.\n   * Has the following behavior based on the type that is passed in:\n   * - `boolean` - when true, will return focus to the element that was focused before the dialog\n   *    was opened, otherwise won't restore focus at all.\n   * - `string` - focus will be restored to the first element that matches the CSS selector.\n   * - `HTMLElement` - focus will be restored to the specific element.\n   */\n  restoreFocus?: boolean | string | HTMLElement = true;\n\n  /**\n   * Scroll strategy to be used for the dialog. This determines how\n   * the dialog responds to scrolling underneath the panel element.\n   */\n  scrollStrategy?: ScrollStrategy;\n\n  /**\n   * Whether the dialog should close when the user navigates backwards or forwards through browser\n   * history. This does not apply to navigation via anchor element unless using URL-hash based\n   * routing (`HashLocationStrategy` in the Angular router).\n   */\n  closeOnNavigation?: boolean = true;\n\n  /**\n   * Whether the dialog should close when the dialog service is destroyed. This is useful if\n   * another service is wrapping the dialog and is managing the destruction instead.\n   */\n  closeOnDestroy?: boolean = true;\n\n  /**\n   * Whether the dialog should close when the underlying overlay is detached. This is useful if\n   * another service is wrapping the dialog and is managing the destruction instead. E.g. an\n   * external detachment can happen as a result of a scroll strategy triggering it or when the\n   * browser location changes.\n   */\n  closeOnOverlayDetachments?: boolean = true;\n\n  /**\n   * Whether the built-in overlay animations should be disabled.\n   */\n  disableAnimations?: boolean = false;\n\n  /**\n   * Providers that will be exposed to the contents of the dialog. Can also\n   * be provided as a function in order to generate the providers lazily.\n   */\n  providers?:\n    | StaticProvider[]\n    | ((dialogRef: R, config: DialogConfig<D, R, C>, container: C) => StaticProvider[]);\n\n  /**\n   * Component into which the dialog content will be rendered. Defaults to `CdkDialogContainer`.\n   * A configuration object can be passed in to customize the providers that will be exposed\n   * to the dialog container.\n   */\n  container?:\n    | Type<C>\n    | {\n        type: Type<C>;\n        providers: (config: DialogConfig<D, R, C>) => StaticProvider[];\n      };\n\n  /**\n   * Context that will be passed to template-based dialogs.\n   * A function can be passed in to resolve the context lazily.\n   */\n  templateContext?: Record<string, any> | (() => Record<string, any>);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  FocusMonitor,\n  FocusOrigin,\n  FocusTrap,\n  FocusTrapFactory,\n  InteractivityChecker,\n} from '../a11y';\nimport {Platform, _getFocusedElementPierceShadowDom} from '../platform';\nimport {\n  BasePortalOutlet,\n  CdkPortalOutlet,\n  ComponentPortal,\n  DomPortal,\n  TemplatePortal,\n} from '../portal';\n\nimport {\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ComponentRef,\n  ElementRef,\n  EmbeddedViewRef,\n  Injector,\n  NgZone,\n  OnDestroy,\n  Renderer2,\n  ViewChild,\n  ViewEncapsulation,\n  afterNextRender,\n  inject,\n  DOCUMENT,\n} from '@angular/core';\nimport {DialogConfig, DialogContainer} from './dialog-config';\nimport {Observable, Subject} from 'rxjs';\n\nexport function throwDialogContentAlreadyAttachedError() {\n  throw Error('Attempting to attach dialog content after content is already attached');\n}\n\n/**\n * Internal component that wraps user-provided dialog content.\n * @docs-private\n */\n@Component({\n  selector: 'cdk-dialog-container',\n  templateUrl: './dialog-container.html',\n  styleUrl: 'dialog-container.css',\n  encapsulation: ViewEncapsulation.None,\n  // Using OnPush for dialogs caused some G3 sync issues. Disabled until we can track them down.\n  // tslint:disable-next-line:validate-decorators\n  changeDetection: ChangeDetectionStrategy.Default,\n  imports: [CdkPortalOutlet],\n  host: {\n    'class': 'cdk-dialog-container',\n    'tabindex': '-1',\n    '[attr.id]': '_config.id || null',\n    '[attr.role]': '_config.role',\n    '[attr.aria-modal]': '_config.ariaModal',\n    '[attr.aria-labelledby]': '_config.ariaLabel ? null : _ariaLabelledByQueue[0]',\n    '[attr.aria-label]': '_config.ariaLabel',\n    '[attr.aria-describedby]': '_config.ariaDescribedBy || null',\n  },\n})\nexport class CdkDialogContainer<C extends DialogConfig = DialogConfig>\n  extends BasePortalOutlet\n  implements DialogContainer, OnDestroy\n{\n  protected _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  protected _focusTrapFactory = inject(FocusTrapFactory);\n  readonly _config: C;\n  private _interactivityChecker = inject(InteractivityChecker);\n  protected _ngZone = inject(NgZone);\n  private _focusMonitor = inject(FocusMonitor);\n  private _renderer = inject(Renderer2);\n  protected readonly _changeDetectorRef = inject(ChangeDetectorRef);\n  private _injector = inject(Injector);\n  private _platform = inject(Platform);\n  protected _document = inject(DOCUMENT);\n\n  /** The portal outlet inside of this container into which the dialog content will be loaded. */\n  @ViewChild(CdkPortalOutlet, {static: true}) _portalOutlet: CdkPortalOutlet;\n\n  _focusTrapped: Observable<void> = new Subject<void>();\n\n  /** The class that traps and manages focus within the dialog. */\n  private _focusTrap: FocusTrap | null = null;\n\n  /** Element that was focused before the dialog was opened. Save this to restore upon close. */\n  private _elementFocusedBeforeDialogWasOpened: HTMLElement | null = null;\n\n  /**\n   * Type of interaction that led to the dialog being closed. This is used to determine\n   * whether the focus style will be applied when returning focus to its original location\n   * after the dialog is closed.\n   */\n  _closeInteractionType: FocusOrigin | null = null;\n\n  /**\n   * Queue of the IDs of the dialog's label element, based on their definition order. The first\n   * ID will be used as the `aria-labelledby` value. We use a queue here to handle the case\n   * where there are two or more titles in the DOM at a time and the first one is destroyed while\n   * the rest are present.\n   */\n  _ariaLabelledByQueue: string[] = [];\n\n  private _isDestroyed = false;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    super();\n\n    // Callback is primarily for some internal tests\n    // that were instantiating the dialog container manually.\n    this._config = (inject(DialogConfig, {optional: true}) || new DialogConfig()) as C;\n\n    if (this._config.ariaLabelledBy) {\n      this._ariaLabelledByQueue.push(this._config.ariaLabelledBy);\n    }\n  }\n\n  _addAriaLabelledBy(id: string) {\n    this._ariaLabelledByQueue.push(id);\n    this._changeDetectorRef.markForCheck();\n  }\n\n  _removeAriaLabelledBy(id: string) {\n    const index = this._ariaLabelledByQueue.indexOf(id);\n\n    if (index > -1) {\n      this._ariaLabelledByQueue.splice(index, 1);\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  protected _contentAttached() {\n    this._initializeFocusTrap();\n    this._captureInitialFocus();\n  }\n\n  /**\n   * Can be used by child classes to customize the initial focus\n   * capturing behavior (e.g. if it's tied to an animation).\n   */\n  protected _captureInitialFocus() {\n    this._trapFocus();\n  }\n\n  ngOnDestroy() {\n    (this._focusTrapped as Subject<void>).complete();\n    this._isDestroyed = true;\n    this._restoreFocus();\n  }\n\n  /**\n   * Attach a ComponentPortal as content to this dialog container.\n   * @param portal Portal to be attached as the dialog content.\n   */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throwDialogContentAlreadyAttachedError();\n    }\n\n    const result = this._portalOutlet.attachComponentPortal(portal);\n    this._contentAttached();\n    return result;\n  }\n\n  /**\n   * Attach a TemplatePortal as content to this dialog container.\n   * @param portal Portal to be attached as the dialog content.\n   */\n  attachTemplatePortal<T>(portal: TemplatePortal<T>): EmbeddedViewRef<T> {\n    if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throwDialogContentAlreadyAttachedError();\n    }\n\n    const result = this._portalOutlet.attachTemplatePortal(portal);\n    this._contentAttached();\n    return result;\n  }\n\n  /**\n   * Attaches a DOM portal to the dialog container.\n   * @param portal Portal to be attached.\n   * @deprecated To be turned into a method.\n   * @breaking-change 10.0.0\n   */\n  override attachDomPortal = (portal: DomPortal) => {\n    if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throwDialogContentAlreadyAttachedError();\n    }\n\n    const result = this._portalOutlet.attachDomPortal(portal);\n    this._contentAttached();\n    return result;\n  };\n\n  // TODO(crisbeto): this shouldn't be exposed, but there are internal references to it.\n  /** Captures focus if it isn't already inside the dialog. */\n  _recaptureFocus() {\n    if (!this._containsFocus()) {\n      this._trapFocus();\n    }\n  }\n\n  /**\n   * Focuses the provided element. If the element is not focusable, it will add a tabIndex\n   * attribute to forcefully focus it. The attribute is removed after focus is moved.\n   * @param element The element to focus.\n   */\n  private _forceFocus(element: HTMLElement, options?: FocusOptions) {\n    if (!this._interactivityChecker.isFocusable(element)) {\n      element.tabIndex = -1;\n      // The tabindex attribute should be removed to avoid navigating to that element again\n      this._ngZone.runOutsideAngular(() => {\n        const callback = () => {\n          deregisterBlur();\n          deregisterMousedown();\n          element.removeAttribute('tabindex');\n        };\n\n        const deregisterBlur = this._renderer.listen(element, 'blur', callback);\n        const deregisterMousedown = this._renderer.listen(element, 'mousedown', callback);\n      });\n    }\n    element.focus(options);\n  }\n\n  /**\n   * Focuses the first element that matches the given selector within the focus trap.\n   * @param selector The CSS selector for the element to set focus to.\n   */\n  private _focusByCssSelector(selector: string, options?: FocusOptions) {\n    let elementToFocus = this._elementRef.nativeElement.querySelector(\n      selector,\n    ) as HTMLElement | null;\n    if (elementToFocus) {\n      this._forceFocus(elementToFocus, options);\n    }\n  }\n\n  /**\n   * Moves the focus inside the focus trap. When autoFocus is not set to 'dialog', if focus\n   * cannot be moved then focus will go to the dialog container.\n   */\n  protected _trapFocus(options?: FocusOptions) {\n    if (this._isDestroyed) {\n      return;\n    }\n\n    // If were to attempt to focus immediately, then the content of the dialog would not yet be\n    // ready in instances where change detection has to run first. To deal with this, we simply\n    // wait until after the next render.\n    afterNextRender(\n      () => {\n        const element = this._elementRef.nativeElement;\n        switch (this._config.autoFocus) {\n          case false:\n          case 'dialog':\n            // Ensure that focus is on the dialog container. It's possible that a different\n            // component tried to move focus while the open animation was running. See:\n            // https://github.com/angular/components/issues/16215. Note that we only want to do this\n            // if the focus isn't inside the dialog already, because it's possible that the consumer\n            // turned off `autoFocus` in order to move focus themselves.\n            if (!this._containsFocus()) {\n              element.focus(options);\n            }\n            break;\n          case true:\n          case 'first-tabbable':\n            const focusedSuccessfully = this._focusTrap?.focusInitialElement(options);\n            // If we weren't able to find a focusable element in the dialog, then focus the dialog\n            // container instead.\n            if (!focusedSuccessfully) {\n              this._focusDialogContainer(options);\n            }\n            break;\n          case 'first-heading':\n            this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role=\"heading\"]', options);\n            break;\n          default:\n            this._focusByCssSelector(this._config.autoFocus!, options);\n            break;\n        }\n        (this._focusTrapped as Subject<void>).next();\n      },\n      {injector: this._injector},\n    );\n  }\n\n  /** Restores focus to the element that was focused before the dialog opened. */\n  private _restoreFocus() {\n    const focusConfig = this._config.restoreFocus;\n    let focusTargetElement: HTMLElement | null = null;\n\n    if (typeof focusConfig === 'string') {\n      focusTargetElement = this._document.querySelector(focusConfig);\n    } else if (typeof focusConfig === 'boolean') {\n      focusTargetElement = focusConfig ? this._elementFocusedBeforeDialogWasOpened : null;\n    } else if (focusConfig) {\n      focusTargetElement = focusConfig;\n    }\n\n    // We need the extra check, because IE can set the `activeElement` to null in some cases.\n    if (\n      this._config.restoreFocus &&\n      focusTargetElement &&\n      typeof focusTargetElement.focus === 'function'\n    ) {\n      const activeElement = _getFocusedElementPierceShadowDom();\n      const element = this._elementRef.nativeElement;\n\n      // Make sure that focus is still inside the dialog or is on the body (usually because a\n      // non-focusable element like the backdrop was clicked) before moving it. It's possible that\n      // the consumer moved it themselves before the animation was done, in which case we shouldn't\n      // do anything.\n      if (\n        !activeElement ||\n        activeElement === this._document.body ||\n        activeElement === element ||\n        element.contains(activeElement)\n      ) {\n        if (this._focusMonitor) {\n          this._focusMonitor.focusVia(focusTargetElement, this._closeInteractionType);\n          this._closeInteractionType = null;\n        } else {\n          focusTargetElement.focus();\n        }\n      }\n    }\n\n    if (this._focusTrap) {\n      this._focusTrap.destroy();\n    }\n  }\n\n  /** Focuses the dialog container. */\n  private _focusDialogContainer(options?: FocusOptions) {\n    // Note that there is no focus method when rendering on the server.\n    this._elementRef.nativeElement.focus?.(options);\n  }\n\n  /** Returns whether focus is inside the dialog. */\n  private _containsFocus() {\n    const element = this._elementRef.nativeElement;\n    const activeElement = _getFocusedElementPierceShadowDom();\n    return element === activeElement || element.contains(activeElement);\n  }\n\n  /** Sets up the focus trap. */\n  private _initializeFocusTrap() {\n    if (this._platform.isBrowser) {\n      this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n\n      // Save the previously focused element. This element will be re-focused\n      // when the dialog closes.\n      if (this._document) {\n        this._elementFocusedBeforeDialogWasOpened = _getFocusedElementPierceShadowDom();\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {OverlayRef} from '../overlay';\nimport {ESCAPE, hasModifierKey} from '../keycodes';\nimport {Observable, Subject, Subscription} from 'rxjs';\nimport {DialogConfig, DialogContainer} from './dialog-config';\nimport {FocusOrigin} from '../a11y';\nimport {ComponentRef} from '@angular/core';\n\n/** Additional options that can be passed in when closing a dialog. */\nexport interface DialogCloseOptions {\n  /** Focus original to use when restoring focus. */\n  focusOrigin?: FocusOrigin;\n}\n\n/**\n * Reference to a dialog opened via the Dialog service.\n */\nexport class DialogRef<R = unknown, C = unknown> {\n  /**\n   * Instance of component opened into the dialog. Will be\n   * null when the dialog is opened using a `TemplateRef`.\n   */\n  readonly componentInstance: C | null;\n\n  /**\n   * `ComponentRef` of the component opened into the dialog. Will be\n   * null when the dialog is opened using a `TemplateRef`.\n   */\n  readonly componentRef: ComponentRef<C> | null;\n\n  /** Instance of the container that is rendering out the dialog content. */\n  readonly containerInstance: DialogContainer;\n\n  /** Whether the user is allowed to close the dialog. */\n  disableClose: boolean | undefined;\n\n  /** Emits when the dialog has been closed. */\n  readonly closed: Observable<R | undefined> = new Subject<R | undefined>();\n\n  /** Emits when the backdrop of the dialog is clicked. */\n  readonly backdropClick: Observable<MouseEvent>;\n\n  /** Emits when on keyboard events within the dialog. */\n  readonly keydownEvents: Observable<KeyboardEvent>;\n\n  /** Emits on pointer events that happen outside of the dialog. */\n  readonly outsidePointerEvents: Observable<MouseEvent>;\n\n  /** Unique ID for the dialog. */\n  readonly id: string;\n\n  /** Subscription to external detachments of the dialog. */\n  private _detachSubscription: Subscription;\n\n  constructor(\n    readonly overlayRef: OverlayRef,\n    readonly config: DialogConfig<any, DialogRef<R, C>, DialogContainer>,\n  ) {\n    this.disableClose = config.disableClose;\n    this.backdropClick = overlayRef.backdropClick();\n    this.keydownEvents = overlayRef.keydownEvents();\n    this.outsidePointerEvents = overlayRef.outsidePointerEvents();\n    this.id = config.id!; // By the time the dialog is created we are guaranteed to have an ID.\n\n    this.keydownEvents.subscribe(event => {\n      if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {\n        event.preventDefault();\n        this.close(undefined, {focusOrigin: 'keyboard'});\n      }\n    });\n\n    this.backdropClick.subscribe(() => {\n      if (!this.disableClose && this._canClose()) {\n        this.close(undefined, {focusOrigin: 'mouse'});\n      } else {\n        // Clicking on the backdrop will move focus out of dialog.\n        // Recapture it if closing via the backdrop is disabled.\n        this.containerInstance._recaptureFocus?.();\n      }\n    });\n\n    this._detachSubscription = overlayRef.detachments().subscribe(() => {\n      // Check specifically for `false`, because we want `undefined` to be treated like `true`.\n      if (config.closeOnOverlayDetachments !== false) {\n        this.close();\n      }\n    });\n  }\n\n  /**\n   * Close the dialog.\n   * @param result Optional result to return to the dialog opener.\n   * @param options Additional options to customize the closing behavior.\n   */\n  close(result?: R, options?: DialogCloseOptions): void {\n    if (this._canClose(result)) {\n      const closedSubject = this.closed as Subject<R | undefined>;\n      this.containerInstance._closeInteractionType = options?.focusOrigin || 'program';\n      // Drop the detach subscription first since it can be triggered by the\n      // `dispose` call and override the result of this closing sequence.\n      this._detachSubscription.unsubscribe();\n      this.overlayRef.dispose();\n      closedSubject.next(result);\n      closedSubject.complete();\n      (this as {componentInstance: C}).componentInstance = (\n        this as {containerInstance: DialogContainer}\n      ).containerInstance = null!;\n    }\n  }\n\n  /** Updates the position of the dialog based on the current position strategy. */\n  updatePosition(): this {\n    this.overlayRef.updatePosition();\n    return this;\n  }\n\n  /**\n   * Updates the dialog's width and height.\n   * @param width New width of the dialog.\n   * @param height New height of the dialog.\n   */\n  updateSize(width: string | number = '', height: string | number = ''): this {\n    this.overlayRef.updateSize({width, height});\n    return this;\n  }\n\n  /** Add a CSS class or an array of classes to the overlay pane. */\n  addPanelClass(classes: string | string[]): this {\n    this.overlayRef.addPanelClass(classes);\n    return this;\n  }\n\n  /** Remove a CSS class or an array of classes from the overlay pane. */\n  removePanelClass(classes: string | string[]): this {\n    this.overlayRef.removePanelClass(classes);\n    return this;\n  }\n\n  /** Whether the dialog is allowed to close. */\n  private _canClose(result?: R): boolean {\n    const config = this.config as DialogConfig<unknown, unknown, DialogContainer>;\n\n    return (\n      !!this.containerInstance &&\n      (!config.closePredicate || config.closePredicate(result, config, this.componentInstance))\n    );\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken, Injector, inject} from '@angular/core';\nimport {createBlockScrollStrategy, ScrollStrategy} from '../overlay';\nimport {DialogConfig} from './dialog-config';\n\n/** Injection token for the Dialog's ScrollStrategy. */\nexport const DIALOG_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'DialogScrollStrategy',\n  {\n    providedIn: 'root',\n    factory: () => {\n      const injector = inject(Injector);\n      return () => createBlockScrollStrategy(injector);\n    },\n  },\n);\n\n/** Injection token for the Dialog's Data. */\nexport const DIALOG_DATA = new InjectionToken<any>('DialogData');\n\n/** Injection token that can be used to provide default options for the dialog module. */\nexport const DEFAULT_DIALOG_CONFIG = new InjectionToken<DialogConfig>('DefaultDialogConfig');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ComponentRef,\n  EventEmitter,\n  Injectable,\n  Injector,\n  OnDestroy,\n  StaticProvider,\n  TemplateRef,\n  Type,\n  inject,\n  signal,\n} from '@angular/core';\nimport {Observable, Subject, defer} from 'rxjs';\nimport {startWith, take} from 'rxjs/operators';\nimport {_IdGenerator} from '../a11y';\nimport {Direction, Directionality} from '../bidi';\nimport {\n  ComponentType,\n  createGlobalPositionStrategy,\n  createOverlayRef,\n  OverlayConfig,\n  OverlayContainer,\n  OverlayRef,\n} from '../overlay';\nimport {ComponentPortal, TemplatePortal} from '../portal';\nimport {DialogConfig, DialogContainer} from './dialog-config';\nimport {DialogRef} from './dialog-ref';\n\nimport {CdkDialogContainer} from './dialog-container';\nimport {DEFAULT_DIALOG_CONFIG, DIALOG_DATA, DIALOG_SCROLL_STRATEGY} from './dialog-injectors';\n\nfunction getDirectionality(value: Direction): Directionality {\n  const valueSignal = signal(value);\n  const change = new EventEmitter<Direction>();\n  return {\n    valueSignal,\n    get value() {\n      return valueSignal();\n    },\n    change,\n    ngOnDestroy() {\n      change.complete();\n    },\n  };\n}\n\n@Injectable({providedIn: 'root'})\nexport class Dialog implements OnDestroy {\n  private _injector = inject(Injector);\n  private _defaultOptions = inject<DialogConfig>(DEFAULT_DIALOG_CONFIG, {optional: true});\n  private _parentDialog = inject(Dialog, {optional: true, skipSelf: true});\n  private _overlayContainer = inject(OverlayContainer);\n  private _idGenerator = inject(_IdGenerator);\n\n  private _openDialogsAtThisLevel: DialogRef<any, any>[] = [];\n  private readonly _afterAllClosedAtThisLevel = new Subject<void>();\n  private readonly _afterOpenedAtThisLevel = new Subject<DialogRef>();\n  private _ariaHiddenElements = new Map<Element, string | null>();\n  private _scrollStrategy = inject(DIALOG_SCROLL_STRATEGY);\n\n  /** Keeps track of the currently-open dialogs. */\n  get openDialogs(): readonly DialogRef<any, any>[] {\n    return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;\n  }\n\n  /** Stream that emits when a dialog has been opened. */\n  get afterOpened(): Subject<DialogRef<any, any>> {\n    return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;\n  }\n\n  /**\n   * Stream that emits when all open dialog have finished closing.\n   * Will emit on subscribe if there are no open dialogs to begin with.\n   */\n  readonly afterAllClosed: Observable<void> = defer(() =>\n    this.openDialogs.length\n      ? this._getAfterAllClosed()\n      : this._getAfterAllClosed().pipe(startWith(undefined)),\n  );\n\n  constructor(...args: unknown[]);\n\n  constructor() {}\n\n  /**\n   * Opens a modal dialog containing the given component.\n   * @param component Type of the component to load into the dialog.\n   * @param config Extra configuration options.\n   * @returns Reference to the newly-opened dialog.\n   */\n  open<R = unknown, D = unknown, C = unknown>(\n    component: ComponentType<C>,\n    config?: DialogConfig<D, DialogRef<R, C>>,\n  ): DialogRef<R, C>;\n\n  /**\n   * Opens a modal dialog containing the given template.\n   * @param template TemplateRef to instantiate as the dialog content.\n   * @param config Extra configuration options.\n   * @returns Reference to the newly-opened dialog.\n   */\n  open<R = unknown, D = unknown, C = unknown>(\n    template: TemplateRef<C>,\n    config?: DialogConfig<D, DialogRef<R, C>>,\n  ): DialogRef<R, C>;\n\n  open<R = unknown, D = unknown, C = unknown>(\n    componentOrTemplateRef: ComponentType<C> | TemplateRef<C>,\n    config?: DialogConfig<D, DialogRef<R, C>>,\n  ): DialogRef<R, C>;\n\n  open<R = unknown, D = unknown, C = unknown>(\n    componentOrTemplateRef: ComponentType<C> | TemplateRef<C>,\n    config?: DialogConfig<D, DialogRef<R, C>>,\n  ): DialogRef<R, C> {\n    const defaults = (this._defaultOptions || new DialogConfig()) as DialogConfig<\n      D,\n      DialogRef<R, C>\n    >;\n    config = {...defaults, ...config};\n    config.id = config.id || this._idGenerator.getId('cdk-dialog-');\n\n    if (\n      config.id &&\n      this.getDialogById(config.id) &&\n      (typeof ngDevMode === 'undefined' || ngDevMode)\n    ) {\n      throw Error(`Dialog with id \"${config.id}\" exists already. The dialog id must be unique.`);\n    }\n\n    const overlayConfig = this._getOverlayConfig(config);\n    const overlayRef = createOverlayRef(this._injector, overlayConfig);\n    const dialogRef = new DialogRef(overlayRef, config);\n    const dialogContainer = this._attachContainer(overlayRef, dialogRef, config);\n\n    (dialogRef as {containerInstance: DialogContainer}).containerInstance = dialogContainer;\n\n    // If this is the first dialog that we're opening, hide all the non-overlay content.\n    if (!this.openDialogs.length) {\n      // Resolve this ahead of time, because some internal apps\n      // mock it out and depend on it being synchronous.\n      const overlayContainer = this._overlayContainer.getContainerElement();\n\n      if (dialogContainer._focusTrapped) {\n        dialogContainer._focusTrapped.pipe(take(1)).subscribe(() => {\n          this._hideNonDialogContentFromAssistiveTechnology(overlayContainer);\n        });\n      } else {\n        this._hideNonDialogContentFromAssistiveTechnology(overlayContainer);\n      }\n    }\n\n    this._attachDialogContent(componentOrTemplateRef, dialogRef, dialogContainer, config);\n    (this.openDialogs as DialogRef<R, C>[]).push(dialogRef);\n    dialogRef.closed.subscribe(() => this._removeOpenDialog(dialogRef, true));\n    this.afterOpened.next(dialogRef);\n\n    return dialogRef;\n  }\n\n  /**\n   * Closes all of the currently-open dialogs.\n   */\n  closeAll(): void {\n    reverseForEach(this.openDialogs, dialog => dialog.close());\n  }\n\n  /**\n   * Finds an open dialog by its id.\n   * @param id ID to use when looking up the dialog.\n   */\n  getDialogById<R, C>(id: string): DialogRef<R, C> | undefined {\n    return this.openDialogs.find(dialog => dialog.id === id);\n  }\n\n  ngOnDestroy() {\n    // Make one pass over all the dialogs that need to be untracked, but should not be closed. We\n    // want to stop tracking the open dialog even if it hasn't been closed, because the tracking\n    // determines when `aria-hidden` is removed from elements outside the dialog.\n    reverseForEach(this._openDialogsAtThisLevel, dialog => {\n      // Check for `false` specifically since we want `undefined` to be interpreted as `true`.\n      if (dialog.config.closeOnDestroy === false) {\n        this._removeOpenDialog(dialog, false);\n      }\n    });\n\n    // Make a second pass and close the remaining dialogs. We do this second pass in order to\n    // correctly dispatch the `afterAllClosed` event in case we have a mixed array of dialogs\n    // that should be closed and dialogs that should not.\n    reverseForEach(this._openDialogsAtThisLevel, dialog => dialog.close());\n\n    this._afterAllClosedAtThisLevel.complete();\n    this._afterOpenedAtThisLevel.complete();\n    this._openDialogsAtThisLevel = [];\n  }\n\n  /**\n   * Creates an overlay config from a dialog config.\n   * @param config The dialog configuration.\n   * @returns The overlay configuration.\n   */\n  private _getOverlayConfig<D, R>(config: DialogConfig<D, R>): OverlayConfig {\n    const state = new OverlayConfig({\n      positionStrategy:\n        config.positionStrategy ||\n        createGlobalPositionStrategy(this._injector).centerHorizontally().centerVertically(),\n      scrollStrategy: config.scrollStrategy || this._scrollStrategy(),\n      panelClass: config.panelClass,\n      hasBackdrop: config.hasBackdrop,\n      direction: config.direction,\n      minWidth: config.minWidth,\n      minHeight: config.minHeight,\n      maxWidth: config.maxWidth,\n      maxHeight: config.maxHeight,\n      width: config.width,\n      height: config.height,\n      disposeOnNavigation: config.closeOnNavigation,\n      disableAnimations: config.disableAnimations,\n    });\n\n    if (config.backdropClass) {\n      state.backdropClass = config.backdropClass;\n    }\n\n    return state;\n  }\n\n  /**\n   * Attaches a dialog container to a dialog's already-created overlay.\n   * @param overlay Reference to the dialog's underlying overlay.\n   * @param config The dialog configuration.\n   * @returns A promise resolving to a ComponentRef for the attached container.\n   */\n  private _attachContainer<R, D, C>(\n    overlay: OverlayRef,\n    dialogRef: DialogRef<R, C>,\n    config: DialogConfig<D, DialogRef<R, C>>,\n  ): DialogContainer {\n    const userInjector = config.injector || config.viewContainerRef?.injector;\n    const providers: StaticProvider[] = [\n      {provide: DialogConfig, useValue: config},\n      {provide: DialogRef, useValue: dialogRef},\n      {provide: OverlayRef, useValue: overlay},\n    ];\n    let containerType: Type<DialogContainer>;\n\n    if (config.container) {\n      if (typeof config.container === 'function') {\n        containerType = config.container;\n      } else {\n        containerType = config.container.type;\n        providers.push(...config.container.providers(config));\n      }\n    } else {\n      containerType = CdkDialogContainer;\n    }\n\n    const containerPortal = new ComponentPortal(\n      containerType,\n      config.viewContainerRef,\n      Injector.create({parent: userInjector || this._injector, providers}),\n    );\n    const containerRef = overlay.attach(containerPortal);\n\n    return containerRef.instance;\n  }\n\n  /**\n   * Attaches the user-provided component to the already-created dialog container.\n   * @param componentOrTemplateRef The type of component being loaded into the dialog,\n   *     or a TemplateRef to instantiate as the content.\n   * @param dialogRef Reference to the dialog being opened.\n   * @param dialogContainer Component that is going to wrap the dialog content.\n   * @param config Configuration used to open the dialog.\n   */\n  private _attachDialogContent<R, D, C>(\n    componentOrTemplateRef: ComponentType<C> | TemplateRef<C>,\n    dialogRef: DialogRef<R, C>,\n    dialogContainer: DialogContainer,\n    config: DialogConfig<D, DialogRef<R, C>>,\n  ) {\n    if (componentOrTemplateRef instanceof TemplateRef) {\n      const injector = this._createInjector(config, dialogRef, dialogContainer, undefined);\n      let context: any = {$implicit: config.data, dialogRef};\n\n      if (config.templateContext) {\n        context = {\n          ...context,\n          ...(typeof config.templateContext === 'function'\n            ? config.templateContext()\n            : config.templateContext),\n        };\n      }\n\n      dialogContainer.attachTemplatePortal(\n        new TemplatePortal<C>(componentOrTemplateRef, null!, context, injector),\n      );\n    } else {\n      const injector = this._createInjector(config, dialogRef, dialogContainer, this._injector);\n      const contentRef = dialogContainer.attachComponentPortal<C>(\n        new ComponentPortal(componentOrTemplateRef, config.viewContainerRef, injector),\n      );\n      (dialogRef as {componentRef: ComponentRef<C>}).componentRef = contentRef;\n      (dialogRef as {componentInstance: C}).componentInstance = contentRef.instance;\n    }\n  }\n\n  /**\n   * Creates a custom injector to be used inside the dialog. This allows a component loaded inside\n   * of a dialog to close itself and, optionally, to return a value.\n   * @param config Config object that is used to construct the dialog.\n   * @param dialogRef Reference to the dialog being opened.\n   * @param dialogContainer Component that is going to wrap the dialog content.\n   * @param fallbackInjector Injector to use as a fallback when a lookup fails in the custom\n   * dialog injector, if the user didn't provide a custom one.\n   * @returns The custom injector that can be used inside the dialog.\n   */\n  private _createInjector<R, D, C>(\n    config: DialogConfig<D, DialogRef<R, C>>,\n    dialogRef: DialogRef<R, C>,\n    dialogContainer: DialogContainer,\n    fallbackInjector: Injector | undefined,\n  ): Injector {\n    const userInjector = config.injector || config.viewContainerRef?.injector;\n    const providers: StaticProvider[] = [\n      {provide: DIALOG_DATA, useValue: config.data},\n      {provide: DialogRef, useValue: dialogRef},\n    ];\n\n    if (config.providers) {\n      if (typeof config.providers === 'function') {\n        providers.push(...config.providers(dialogRef, config, dialogContainer));\n      } else {\n        providers.push(...config.providers);\n      }\n    }\n\n    if (\n      config.direction &&\n      (!userInjector ||\n        !userInjector.get<Directionality | null>(Directionality, null, {optional: true}))\n    ) {\n      providers.push({\n        provide: Directionality,\n        useValue: getDirectionality(config.direction),\n      });\n    }\n\n    return Injector.create({parent: userInjector || fallbackInjector, providers});\n  }\n\n  /**\n   * Removes a dialog from the array of open dialogs.\n   * @param dialogRef Dialog to be removed.\n   * @param emitEvent Whether to emit an event if this is the last dialog.\n   */\n  private _removeOpenDialog<R, C>(dialogRef: DialogRef<R, C>, emitEvent: boolean) {\n    const index = this.openDialogs.indexOf(dialogRef);\n\n    if (index > -1) {\n      (this.openDialogs as DialogRef<R, C>[]).splice(index, 1);\n\n      // If all the dialogs were closed, remove/restore the `aria-hidden`\n      // to a the siblings and emit to the `afterAllClosed` stream.\n      if (!this.openDialogs.length) {\n        this._ariaHiddenElements.forEach((previousValue, element) => {\n          if (previousValue) {\n            element.setAttribute('aria-hidden', previousValue);\n          } else {\n            element.removeAttribute('aria-hidden');\n          }\n        });\n\n        this._ariaHiddenElements.clear();\n\n        if (emitEvent) {\n          this._getAfterAllClosed().next();\n        }\n      }\n    }\n  }\n\n  /** Hides all of the content that isn't an overlay from assistive technology. */\n  private _hideNonDialogContentFromAssistiveTechnology(overlayContainer: HTMLElement) {\n    // Ensure that the overlay container is attached to the DOM.\n    if (overlayContainer.parentElement) {\n      const siblings = overlayContainer.parentElement.children;\n\n      for (let i = siblings.length - 1; i > -1; i--) {\n        const sibling = siblings[i];\n\n        if (\n          sibling !== overlayContainer &&\n          sibling.nodeName !== 'SCRIPT' &&\n          sibling.nodeName !== 'STYLE' &&\n          !sibling.hasAttribute('aria-live') &&\n          !sibling.hasAttribute('popover')\n        ) {\n          this._ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));\n          sibling.setAttribute('aria-hidden', 'true');\n        }\n      }\n    }\n  }\n\n  private _getAfterAllClosed(): Subject<void> {\n    const parent = this._parentDialog;\n    return parent ? parent._getAfterAllClosed() : this._afterAllClosedAtThisLevel;\n  }\n}\n\n/**\n * Executes a callback against all elements in an array while iterating in reverse.\n * Useful if the array is being modified as it is being iterated.\n */\nfunction reverseForEach<T>(items: T[] | readonly T[], callback: (current: T) => void) {\n  let i = items.length;\n\n  while (i--) {\n    callback(items[i]);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {OverlayModule} from '../overlay';\nimport {PortalModule} from '../portal';\nimport {A11yModule} from '../a11y';\nimport {Dialog} from './dialog';\nimport {CdkDialogContainer} from './dialog-container';\n\n@NgModule({\n  imports: [OverlayModule, PortalModule, A11yModule, CdkDialogContainer],\n  exports: [\n    // Re-export the PortalModule so that people extending the `CdkDialogContainer`\n    // don't have to remember to import it or be faced with an unhelpful error.\n    PortalModule,\n    CdkDialogContainer,\n  ],\n  providers: [Dialog],\n})\nexport class DialogModule {}\n\n// Re-export needed by the Angular compiler.\n// See: https://github.com/angular/components/issues/30663.\n// Note: These exports need to be stable and shouldn't be renamed unnecessarily because\n// consuming libraries might have references to them in their own partial compilation output.\nexport {CdkPortal as ɵɵCdkPortal, CdkPortalOutlet as ɵɵCdkPortalOutlet} from '../portal';\n"],"names":["width","minWidth","minHeight","maxWidth","positionStrategy","ariaLabelledBy","throwDialogContentAlreadyAttachedError","Error","CdkDialogContainer","BasePortalOutlet","inject","ElementRef","_config","_focusMonitor","FocusMonitor","_changeDetectorRef","ChangeDetectorRef","_injector","Injector","_platform","Platform","_document","DOCUMENT","_portalOutlet","_focusTrapped","Subject","_elementFocusedBeforeDialogWasOpened","_ariaLabelledByQueue","push","_addAriaLabelledBy","id","markForCheck","_removeAriaLabelledBy","index","indexOf","_contentAttached","_captureInitialFocus","_trapFocus","ngOnDestroy","_restoreFocus","attachComponentPortal","portal","attachTemplatePortal","hasAttached","ngDevMode","result","_recaptureFocus","_containsFocus","deregisterBlur","deregisterMousedown","element","removeAttribute","_renderer","listen","callback","options","_elementRef","nativeElement","querySelector","selector","_isDestroyed","afterNextRender","autoFocus","focusedSuccessfully","_focusTrap","focusInitialElement","_focusDialogContainer","ctorParameters","propDecorators","static","overlayRef","containerInstance","backdropClick","keydownEvents","outsidePointerEvents","config","disableClose","subscribe","event","keyCode","ESCAPE","hasModifierKey","preventDefault","_canClose","close","undefined","focusOrigin","closeOnOverlayDetachments","_detachSubscription","unsubscribe","dispose","closedSubject","next","complete","componentInstance","updatePosition","injector","createBlockScrollStrategy","getDirectionality","value","valueSignal","signal","debugName","change","EventEmitter","DEFAULT_DIALOG_CONFIG","optional","Dialog","skipSelf","OverlayContainer","_IdGenerator","_openDialogsAtThisLevel","_afterOpenedAtThisLevel","_ariaHiddenElements","Map","_scrollStrategy","DIALOG_SCROLL_STRATEGY","openDialogs","_parentDialog","afterOpened","afterAllClosed","defer","length","_getAfterAllClosed","constructor","_idGenerator","getId","getDialogById","createOverlayRef","overlayConfig","DialogRef","_attachContainer","dialogRef","dialogContainer","overlayContainer","_overlayContainer","getContainerElement","pipe","take","_hideNonDialogContentFromAssistiveTechnology","closed","_removeOpenDialog","dialog","find","_getOverlayConfig","maxHeight","height","closeOnNavigation","disableAnimations","backdropClass","state","overlay","container","providers","containerType","ComponentPortal","viewContainerRef","create","parent","userInjector","attach","containerPortal","containerRef","instance","context","templateContext","TemplatePortal","componentOrTemplateRef","_createInjector","componentRef","contentRef","ɵfac","i0","ɵɵngDeclareFactory","minVersion","version","ngImport","type","DialogModule","deps","target","ɵɵFactoryTarget","NgModule","ɵɵngDeclareNgModule","imports","OverlayModule","PortalModule","A11yModule","exports"],"mappings":"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"}