{"version":3,"file":"testing-selenium-webdriver.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/testing/selenium-webdriver/selenium-webdriver-keys.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/testing/selenium-webdriver/selenium-web-driver-element.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/testing/selenium-webdriver/selenium-web-driver-harness-environment.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ModifierKeys, TestKey} from '../../testing';\nimport * as webdriver from 'selenium-webdriver';\n\n/**\n * Maps the `TestKey` constants to WebDriver's `webdriver.Key` constants.\n * See https://github.com/SeleniumHQ/selenium/blob/trunk/javascript/webdriver/key.js#L29\n */\nexport const seleniumWebDriverKeyMap = {\n  [TestKey.BACKSPACE]: webdriver.Key.BACK_SPACE,\n  [TestKey.TAB]: webdriver.Key.TAB,\n  [TestKey.ENTER]: webdriver.Key.ENTER,\n  [TestKey.SHIFT]: webdriver.Key.SHIFT,\n  [TestKey.CONTROL]: webdriver.Key.CONTROL,\n  [TestKey.ALT]: webdriver.Key.ALT,\n  [TestKey.ESCAPE]: webdriver.Key.ESCAPE,\n  [TestKey.PAGE_UP]: webdriver.Key.PAGE_UP,\n  [TestKey.PAGE_DOWN]: webdriver.Key.PAGE_DOWN,\n  [TestKey.END]: webdriver.Key.END,\n  [TestKey.HOME]: webdriver.Key.HOME,\n  [TestKey.LEFT_ARROW]: webdriver.Key.ARROW_LEFT,\n  [TestKey.UP_ARROW]: webdriver.Key.ARROW_UP,\n  [TestKey.RIGHT_ARROW]: webdriver.Key.ARROW_RIGHT,\n  [TestKey.DOWN_ARROW]: webdriver.Key.ARROW_DOWN,\n  [TestKey.INSERT]: webdriver.Key.INSERT,\n  [TestKey.DELETE]: webdriver.Key.DELETE,\n  [TestKey.F1]: webdriver.Key.F1,\n  [TestKey.F2]: webdriver.Key.F2,\n  [TestKey.F3]: webdriver.Key.F3,\n  [TestKey.F4]: webdriver.Key.F4,\n  [TestKey.F5]: webdriver.Key.F5,\n  [TestKey.F6]: webdriver.Key.F6,\n  [TestKey.F7]: webdriver.Key.F7,\n  [TestKey.F8]: webdriver.Key.F8,\n  [TestKey.F9]: webdriver.Key.F9,\n  [TestKey.F10]: webdriver.Key.F10,\n  [TestKey.F11]: webdriver.Key.F11,\n  [TestKey.F12]: webdriver.Key.F12,\n  [TestKey.META]: webdriver.Key.META,\n  [TestKey.COMMA]: ',',\n};\n\n/** Gets a list of WebDriver `Key`s for the given `ModifierKeys`. */\nexport function getSeleniumWebDriverModifierKeys(modifiers: ModifierKeys): string[] {\n  const result: string[] = [];\n  if (modifiers.control) {\n    result.push(webdriver.Key.CONTROL);\n  }\n  if (modifiers.alt) {\n    result.push(webdriver.Key.ALT);\n  }\n  if (modifiers.shift) {\n    result.push(webdriver.Key.SHIFT);\n  }\n  if (modifiers.meta) {\n    result.push(webdriver.Key.META);\n  }\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport * as webdriver from 'selenium-webdriver';\nimport {ElementDimensions} from '../element-dimensions';\nimport {EventData, ModifierKeys, TestElement, TestKey, TextOptions} from '../test-element';\nimport {getNoKeysSpecifiedError} from '../test-element-errors';\nimport {_getTextWithExcludedElements} from '../text-filtering';\nimport {getSeleniumWebDriverModifierKeys, seleniumWebDriverKeyMap} from './selenium-webdriver-keys';\n\n/** A `TestElement` implementation for WebDriver. */\nexport class SeleniumWebDriverElement implements TestElement {\n  constructor(\n    readonly element: () => webdriver.WebElement,\n    private _stabilize: () => Promise<void>,\n  ) {}\n\n  /** Blur the element. */\n  async blur(): Promise<void> {\n    await this._executeScript((element: HTMLElement) => element.blur(), this.element());\n    await this._stabilize();\n  }\n\n  /** Clear the element's input (for input and textarea elements only). */\n  async clear(): Promise<void> {\n    await this.element().clear();\n    await this._stabilize();\n  }\n\n  /**\n   * Click the element at the default location for the current environment. If you need to guarantee\n   * the element is clicked at a specific location, consider using `click('center')` or\n   * `click(x, y)` instead.\n   */\n  click(modifiers?: ModifierKeys): Promise<void>;\n  /** Click the element at the element's center. */\n  click(location: 'center', modifiers?: ModifierKeys): Promise<void>;\n  /**\n   * Click the element at the specified coordinates relative to the top-left of the element.\n   * @param relativeX Coordinate within the element, along the X-axis at which to click.\n   * @param relativeY Coordinate within the element, along the Y-axis at which to click.\n   * @param modifiers Modifier keys held while clicking\n   */\n  click(relativeX: number, relativeY: number, modifiers?: ModifierKeys): Promise<void>;\n  async click(\n    ...args: [ModifierKeys?] | ['center', ModifierKeys?] | [number, number, ModifierKeys?]\n  ): Promise<void> {\n    await this._dispatchClickEventSequence(args, webdriver.Button.LEFT);\n    await this._stabilize();\n  }\n\n  /**\n   * Right clicks on the element at the specified coordinates relative to the top-left of it.\n   * @param relativeX Coordinate within the element, along the X-axis at which to click.\n   * @param relativeY Coordinate within the element, along the Y-axis at which to click.\n   * @param modifiers Modifier keys held while clicking\n   */\n  rightClick(relativeX: number, relativeY: number, modifiers?: ModifierKeys): Promise<void>;\n  async rightClick(\n    ...args: [ModifierKeys?] | ['center', ModifierKeys?] | [number, number, ModifierKeys?]\n  ): Promise<void> {\n    await this._dispatchClickEventSequence(args, webdriver.Button.RIGHT);\n    await this._stabilize();\n  }\n\n  /** Focus the element. */\n  async focus(): Promise<void> {\n    await this._executeScript((element: HTMLElement) => element.focus(), this.element());\n    await this._stabilize();\n  }\n\n  /** Get the computed value of the given CSS property for the element. */\n  async getCssValue(property: string): Promise<string> {\n    await this._stabilize();\n    return this.element().getCssValue(property);\n  }\n\n  /** Hovers the mouse over the element. */\n  async hover(): Promise<void> {\n    await this._actions().mouseMove(this.element()).perform();\n    await this._stabilize();\n  }\n\n  /** Moves the mouse away from the element. */\n  async mouseAway(): Promise<void> {\n    await this._actions().mouseMove(this.element(), {x: -1, y: -1}).perform();\n    await this._stabilize();\n  }\n\n  /**\n   * Sends the given string to the input as a series of key presses. Also fires input events\n   * and attempts to add the string to the Element's value.\n   */\n  async sendKeys(...keys: (string | TestKey)[]): Promise<void>;\n  /**\n   * Sends the given string to the input as a series of key presses. Also fires input events\n   * and attempts to add the string to the Element's value.\n   */\n  async sendKeys(modifiers: ModifierKeys, ...keys: (string | TestKey)[]): Promise<void>;\n  async sendKeys(...modifiersAndKeys: any[]): Promise<void> {\n    const first = modifiersAndKeys[0];\n    let modifiers: ModifierKeys;\n    let rest: (string | TestKey)[];\n    if (first !== undefined && typeof first !== 'string' && typeof first !== 'number') {\n      modifiers = first;\n      rest = modifiersAndKeys.slice(1);\n    } else {\n      modifiers = {};\n      rest = modifiersAndKeys;\n    }\n\n    const modifierKeys = getSeleniumWebDriverModifierKeys(modifiers);\n    const keys = rest\n      .map(k => (typeof k === 'string' ? k.split('') : [seleniumWebDriverKeyMap[k]]))\n      .reduce((arr, k) => arr.concat(k), [])\n      // webdriver.Key.chord doesn't work well with geckodriver (mozilla/geckodriver#1502),\n      // so avoid it if no modifier keys are required.\n      .map(k => (modifierKeys.length > 0 ? webdriver.Key.chord(...modifierKeys, k) : k));\n\n    // Throw an error if no keys have been specified. Calling this function with no\n    // keys should not result in a focus event being dispatched unexpectedly.\n    if (keys.length === 0) {\n      throw getNoKeysSpecifiedError();\n    }\n\n    await this.element().sendKeys(...keys);\n    await this._stabilize();\n  }\n\n  /**\n   * Gets the text from the element.\n   * @param options Options that affect what text is included.\n   */\n  async text(options?: TextOptions): Promise<string> {\n    await this._stabilize();\n    if (options?.exclude) {\n      return this._executeScript(_getTextWithExcludedElements, this.element(), options.exclude);\n    }\n    // We don't go through the WebDriver `getText`, because it excludes text from hidden elements.\n    return this._executeScript(\n      (element: Element) => (element.textContent || '').trim(),\n      this.element(),\n    );\n  }\n\n  /**\n   * Sets the value of a `contenteditable` element.\n   * @param value Value to be set on the element.\n   */\n  async setContenteditableValue(value: string): Promise<void> {\n    const contenteditableAttr = await this.getAttribute('contenteditable');\n\n    if (\n      contenteditableAttr !== '' &&\n      contenteditableAttr !== 'true' &&\n      contenteditableAttr !== 'plaintext-only'\n    ) {\n      throw new Error('setContenteditableValue can only be called on a `contenteditable` element.');\n    }\n\n    await this._stabilize();\n    return this._executeScript(\n      (element: Element, valueToSet: string) => (element.textContent = valueToSet),\n      this.element(),\n      value,\n    );\n  }\n\n  /** Gets the value for the given attribute from the element. */\n  async getAttribute(name: string): Promise<string | null> {\n    await this._stabilize();\n    return this._executeScript(\n      (element: Element, attribute: string) => element.getAttribute(attribute),\n      this.element(),\n      name,\n    );\n  }\n\n  /** Checks whether the element has the given class. */\n  async hasClass(name: string): Promise<boolean> {\n    await this._stabilize();\n    const classes = (await this.getAttribute('class')) || '';\n    return new Set(classes.split(/\\s+/).filter(c => c)).has(name);\n  }\n\n  /** Gets the dimensions of the element. */\n  async getDimensions(): Promise<ElementDimensions> {\n    await this._stabilize();\n    const {width, height} = await this.element().getSize();\n    const {x: left, y: top} = await this.element().getLocation();\n    return {width, height, left, top};\n  }\n\n  /** Gets the value of a property of an element. */\n  async getProperty<T = any>(name: string): Promise<T> {\n    await this._stabilize();\n    return this._executeScript(\n      (element: Element, property: keyof Element) => element[property],\n      this.element(),\n      name,\n    );\n  }\n\n  /** Sets the value of a property of an input. */\n  async setInputValue(newValue: string): Promise<void> {\n    await this._executeScript(\n      (element: HTMLInputElement, value: string) => (element.value = value),\n      this.element(),\n      newValue,\n    );\n    await this._stabilize();\n  }\n\n  /** Selects the options at the specified indexes inside of a native `select` element. */\n  async selectOptions(...optionIndexes: number[]): Promise<void> {\n    await this._stabilize();\n    const options = await this.element().findElements(webdriver.By.css('option'));\n    const indexes = new Set(optionIndexes); // Convert to a set to remove duplicates.\n\n    if (options.length && indexes.size) {\n      // Reset the value so all the selected states are cleared. We can\n      // reuse the input-specific method since the logic is the same.\n      await this.setInputValue('');\n\n      for (let i = 0; i < options.length; i++) {\n        if (indexes.has(i)) {\n          // We have to hold the control key while clicking on options so that multiple can be\n          // selected in multi-selection mode. The key doesn't do anything for single selection.\n          await this._actions().keyDown(webdriver.Key.CONTROL).perform();\n          await options[i].click();\n          await this._actions().keyUp(webdriver.Key.CONTROL).perform();\n        }\n      }\n\n      await this._stabilize();\n    }\n  }\n\n  /** Checks whether this element matches the given selector. */\n  async matchesSelector(selector: string): Promise<boolean> {\n    await this._stabilize();\n    return this._executeScript(\n      (element: Element, s: string) =>\n        (Element.prototype.matches || (Element.prototype as any).msMatchesSelector).call(\n          element,\n          s,\n        ),\n      this.element(),\n      selector,\n    );\n  }\n\n  /** Checks whether the element is focused. */\n  async isFocused(): Promise<boolean> {\n    await this._stabilize();\n    return webdriver.WebElement.equals(\n      this.element(),\n      this.element().getDriver().switchTo().activeElement(),\n    );\n  }\n\n  /**\n   * Dispatches an event with a particular name.\n   * @param name Name of the event to be dispatched.\n   */\n  async dispatchEvent(name: string, data?: Record<string, EventData>): Promise<void> {\n    await this._executeScript(dispatchEvent, name, this.element(), data);\n    await this._stabilize();\n  }\n\n  /** Gets the webdriver action sequence. */\n  private _actions() {\n    return this.element().getDriver().actions();\n  }\n\n  /** Executes a function in the browser. */\n  private async _executeScript<T>(script: Function, ...var_args: any[]): Promise<T> {\n    return this.element()\n      .getDriver()\n      .executeScript(script, ...var_args);\n  }\n\n  /** Dispatches all the events that are part of a click event sequence. */\n  private async _dispatchClickEventSequence(\n    args: [ModifierKeys?] | ['center', ModifierKeys?] | [number, number, ModifierKeys?],\n    button: string,\n  ) {\n    let modifiers: ModifierKeys = {};\n    if (args.length && typeof args[args.length - 1] === 'object') {\n      modifiers = args.pop() as ModifierKeys;\n    }\n    const modifierKeys = getSeleniumWebDriverModifierKeys(modifiers);\n\n    // Omitting the offset argument to mouseMove results in clicking the center.\n    // This is the default behavior we want, so we use an empty array of offsetArgs if\n    // no args remain after popping the modifiers from the args passed to this function.\n    const offsetArgs = (args.length === 2 ? [{x: args[0], y: args[1]}] : []) as [\n      {x: number; y: number},\n    ];\n\n    let actions = this._actions().mouseMove(this.element(), ...offsetArgs);\n\n    for (const modifierKey of modifierKeys) {\n      actions = actions.keyDown(modifierKey);\n    }\n    actions = actions.click(button);\n    for (const modifierKey of modifierKeys) {\n      actions = actions.keyUp(modifierKey);\n    }\n\n    await actions.perform();\n  }\n}\n\n/**\n * Dispatches an event with a particular name and data to an element. Note that this needs to be a\n * pure function, because it gets stringified by WebDriver and is executed inside the browser.\n */\nfunction dispatchEvent(name: string, element: Element, data?: Record<string, EventData>) {\n  const event = document.createEvent('Event');\n  event.initEvent(name);\n  // tslint:disable-next-line:ban Have to use `Object.assign` to preserve the original object.\n  Object.assign(event, data || {});\n  element.dispatchEvent(event);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {HarnessEnvironment, HarnessLoader, TestElement} from '../../testing';\nimport * as webdriver from 'selenium-webdriver';\nimport {SeleniumWebDriverElement} from './selenium-web-driver-element';\n\n/**\n * An Angular framework stabilizer function that takes a callback and calls it when the application\n * is stable, passing a boolean indicating if any work was done.\n */\ndeclare interface FrameworkStabilizer {\n  (callback: (didWork: boolean) => void): void;\n}\n\ndeclare global {\n  interface Window {\n    /**\n     * These hooks are exposed by Angular to register a callback for when the application is stable\n     * (no more pending tasks).\n     *\n     * For the implementation, see: https://github.com/\n     *  angular/angular/blob/main/packages/platform-browser/src/browser/testability.ts#L30-L49\n     */\n    frameworkStabilizers: FrameworkStabilizer[];\n  }\n}\n\n/** Options to configure the environment. */\nexport interface WebDriverHarnessEnvironmentOptions {\n  /** The query function used to find DOM elements. */\n  queryFn: (selector: string, root: () => webdriver.WebElement) => Promise<webdriver.WebElement[]>;\n}\n\n/** The default environment options. */\nconst defaultEnvironmentOptions: WebDriverHarnessEnvironmentOptions = {\n  queryFn: async (selector: string, root: () => webdriver.WebElement) =>\n    root().findElements(webdriver.By.css(selector)),\n};\n\n/**\n * This function is meant to be executed in the browser. It taps into the hooks exposed by Angular\n * and invokes the specified `callback` when the application is stable (no more pending tasks).\n */\nfunction whenStable(callback: (didWork: boolean[]) => void): void {\n  Promise.all(window.frameworkStabilizers.map(stabilizer => new Promise(stabilizer))).then(\n    callback,\n  );\n}\n\n/**\n * This function is meant to be executed in the browser. It checks whether the Angular framework has\n * bootstrapped yet.\n */\nfunction isBootstrapped() {\n  return !!window.frameworkStabilizers;\n}\n\n/** Waits for angular to be ready after the page load. */\nexport async function waitForAngularReady(wd: webdriver.WebDriver) {\n  await wd.wait(() => wd.executeScript(isBootstrapped));\n  await wd.executeAsyncScript(whenStable);\n}\n\n/** A `HarnessEnvironment` implementation for WebDriver. */\nexport class SeleniumWebDriverHarnessEnvironment extends HarnessEnvironment<\n  () => webdriver.WebElement\n> {\n  /** The options for this environment. */\n  private _options: WebDriverHarnessEnvironmentOptions;\n\n  /** Environment stabilization callback passed to the created test elements. */\n  private _stabilizeCallback: () => Promise<void>;\n\n  protected constructor(\n    rawRootElement: () => webdriver.WebElement,\n    options?: WebDriverHarnessEnvironmentOptions,\n  ) {\n    super(rawRootElement);\n    this._options = {...defaultEnvironmentOptions, ...options};\n    this._stabilizeCallback = () => this.forceStabilize();\n  }\n\n  /** Gets the ElementFinder corresponding to the given TestElement. */\n  static getNativeElement(el: TestElement): webdriver.WebElement {\n    if (el instanceof SeleniumWebDriverElement) {\n      return el.element();\n    }\n    throw Error('This TestElement was not created by the WebDriverHarnessEnvironment');\n  }\n\n  /** Creates a `HarnessLoader` rooted at the document root. */\n  static loader(\n    driver: webdriver.WebDriver,\n    options?: WebDriverHarnessEnvironmentOptions,\n  ): HarnessLoader {\n    return new SeleniumWebDriverHarnessEnvironment(\n      () => driver.findElement(webdriver.By.css('body')),\n      options,\n    );\n  }\n\n  /**\n   * Flushes change detection and async tasks captured in the Angular zone.\n   * In most cases it should not be necessary to call this manually. However, there may be some edge\n   * cases where it is needed to fully flush animation events.\n   */\n  async forceStabilize(): Promise<void> {\n    await this.rawRootElement().getDriver().executeAsyncScript(whenStable);\n  }\n\n  /** @docs-private */\n  async waitForTasksOutsideAngular(): Promise<void> {\n    // TODO: figure out how we can do this for the webdriver environment.\n    //  https://github.com/angular/components/issues/17412\n  }\n\n  /** Gets the root element for the document. */\n  protected getDocumentRoot(): () => webdriver.WebElement {\n    return () => this.rawRootElement().getDriver().findElement(webdriver.By.css('body'));\n  }\n\n  /** Creates a `TestElement` from a raw element. */\n  protected createTestElement(element: () => webdriver.WebElement): TestElement {\n    return new SeleniumWebDriverElement(element, this._stabilizeCallback);\n  }\n\n  /** Creates a `HarnessLoader` rooted at the given raw element. */\n  protected createEnvironment(\n    element: () => webdriver.WebElement,\n  ): HarnessEnvironment<() => webdriver.WebElement> {\n    return new SeleniumWebDriverHarnessEnvironment(element, this._options);\n  }\n\n  // Note: This seems to be working, though we may need to re-evaluate if we encounter issues with\n  // stale element references. `() => Promise<webdriver.WebElement[]>` seems like a more correct\n  // return type, though supporting it would require changes to the public harness API.\n  /**\n   * Gets a list of all elements matching the given selector under this environment's root element.\n   */\n  protected async getAllRawElements(selector: string): Promise<(() => webdriver.WebElement)[]> {\n    const els = await this._options.queryFn(selector, this.rawRootElement);\n    return els.map((x: webdriver.WebElement) => () => x);\n  }\n}\n"],"names":["seleniumWebDriverKeyMap","BACKSPACE","webdriver","Key","BACK_SPACE","TAB","ESCAPE","PAGE_UP","PAGE_DOWN","END","HOME","LEFT_ARROW","ARROW_LEFT","UP_ARROW","ARROW_UP","RIGHT_ARROW","ARROW_RIGHT","DOWN_ARROW","ARROW_DOWN","INSERT","DELETE","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","TestKey","F12","META","COMMA","getSeleniumWebDriverModifierKeys","modifiers","control","result","push","CONTROL","shift","SHIFT","meta","element","constructor","_stabilize","blur","_executeScript","clear","click","args","_dispatchClickEventSequence","Button","LEFT","rightClick","RIGHT","focus","getCssValue","property","mouseAway","_actions","mouseMove","x","y","perform","sendKeys","modifiersAndKeys","rest","slice","modifierKeys","keys","map","k","split","reduce","arr","concat","length","chord","text","options","exclude","_getTextWithExcludedElements","contenteditableAttr","textContent","classes","getAttribute","Set","filter","c","has","name","getDimensions","width","height","getSize","left","getLocation","top","getProperty","setInputValue","newValue","value","selectOptions","optionIndexes","findElements","By","css","indexes","whenStable","callback","all","window","frameworkStabilizers","stabilizer","Promise","then","_stabilizeCallback","_options","defaultEnvironmentOptions","forceStabilize","SeleniumWebDriverElement","el"],"mappings":"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"}