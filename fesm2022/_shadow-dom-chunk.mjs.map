{"version":3,"file":"_shadow-dom-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/cdk/platform/features/shadow-dom.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nlet shadowDomIsSupported: boolean;\n\n/** Checks whether the user's browser support Shadow DOM. */\nexport function _supportsShadowDom(): boolean {\n  if (shadowDomIsSupported == null) {\n    const head = typeof document !== 'undefined' ? document.head : null;\n    shadowDomIsSupported = !!(head && ((head as any).createShadowRoot || head.attachShadow));\n  }\n\n  return shadowDomIsSupported;\n}\n\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\nexport function _getShadowRoot(element: HTMLElement): ShadowRoot | null {\n  if (_supportsShadowDom()) {\n    const rootNode = element.getRootNode ? element.getRootNode() : null;\n\n    // Note that this should be caught by `_supportsShadowDom`, but some\n    // teams have been able to hit this code path on unsupported browsers.\n    if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\n      return rootNode;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Gets the currently-focused element on the page while\n * also piercing through Shadow DOM boundaries.\n */\nexport function _getFocusedElementPierceShadowDom(): HTMLElement | null {\n  let activeElement =\n    typeof document !== 'undefined' && document\n      ? (document.activeElement as HTMLElement | null)\n      : null;\n\n  while (activeElement && activeElement.shadowRoot) {\n    const newActiveElement = activeElement.shadowRoot.activeElement as HTMLElement | null;\n    if (newActiveElement === activeElement) {\n      break;\n    } else {\n      activeElement = newActiveElement;\n    }\n  }\n\n  return activeElement;\n}\n\n/** Gets the target of an event while accounting for Shadow DOM. */\nexport function _getEventTarget<T extends EventTarget>(event: Event): T | null {\n  // If an event is bound outside the Shadow DOM, the `event.target` will\n  // point to the shadow root so we have to use `composedPath` instead.\n  return (event.composedPath ? event.composedPath()[0] : event.target) as T | null;\n}\n"],"names":["shadowDomIsSupported","_getShadowRoot","element","getRootNode","rootNode","_getFocusedElementPierceShadowDom","document","newActiveElement","activeElement"],"mappings":"AAQA,IAAAA,oBAAA;;;;;;AAUA,EAAA,OAAAA,oBAAA;AAGA;AAEI,SAAAC,cAAiBA,CAAAC,OAAQ,EAAA;wBAE2C,EAAA,EAAA;4BACE,CAAAC,WAAA,GAAAD,OAAA,CAAAC,WAAA,EAAA,GAAA,IAAA;;AAO1E,MAAA,OAAAC,QAAA;AAEA;;;;AAWI,SAAAC,iCAAA,GAAA;mBAEQ,UAAAC,QAAA,KAAA,WAAA,IAAAA,QAAA;;;IAMV,IAAAC,gBAAA,KAAAC,aAAA,EAAA;AACF,MAAA;KAIyE,MAAA;AACFA,MAAAA,aAAA,GAAAD,gBAAA;AAEvE;;;;;;;;;;"}