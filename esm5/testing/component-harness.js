/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as tslib_1 from "tslib";
/**
 * Base class for component harnesses that all component harness authors should extend. This base
 * component harness provides the basic ability to locate element and sub-component harness. It
 * should be inherited when defining user's own harness.
 */
var ComponentHarness = /** @class */ (function () {
    function ComponentHarness(locatorFactory) {
        this.locatorFactory = locatorFactory;
    }
    /** Gets a `Promise` for the `TestElement` representing the host element of the component. */
    ComponentHarness.prototype.host = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.locatorFactory.rootElement];
            });
        });
    };
    /**
     * Gets a `LocatorFactory` for the document root element. This factory can be used to create
     * locators for elements that a component creates outside of its own root element. (e.g. by
     * appending to document.body).
     */
    ComponentHarness.prototype.documentRootLocatorFactory = function () {
        return this.locatorFactory.documentRootLocatorFactory();
    };
    ComponentHarness.prototype.locatorFor = function (arg) {
        return this.locatorFactory.locatorFor(arg);
    };
    ComponentHarness.prototype.locatorForOptional = function (arg) {
        return this.locatorFactory.locatorForOptional(arg);
    };
    ComponentHarness.prototype.locatorForAll = function (arg) {
        return this.locatorFactory.locatorForAll(arg);
    };
    /**
     * Flushes change detection and async tasks in the Angular zone.
     * In most cases it should not be necessary to call this manually. However, there may be some edge
     * cases where it is needed to fully flush animation events.
     */
    ComponentHarness.prototype.forceStabilize = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.locatorFactory.forceStabilize()];
            });
        });
    };
    /**
     * Waits for all scheduled or running async tasks to complete. This allows harness
     * authors to wait for async tasks outside of the Angular zone.
     */
    ComponentHarness.prototype.waitForTasksOutsideAngular = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.locatorFactory.waitForTasksOutsideAngular()];
            });
        });
    };
    return ComponentHarness;
}());
export { ComponentHarness };
/**
 * A class used to associate a ComponentHarness class with predicates functions that can be used to
 * filter instances of the class.
 */
var HarnessPredicate = /** @class */ (function () {
    function HarnessPredicate(harnessType, options) {
        this.harnessType = harnessType;
        this._predicates = [];
        this._descriptions = [];
        this._addBaseOptions(options);
    }
    /**
     * Checks if a string matches the given pattern.
     * @param s The string to check, or a Promise for the string to check.
     * @param pattern The pattern the string is expected to match. If `pattern` is a string, `s` is
     *   expected to match exactly. If `pattern` is a regex, a partial match is allowed.
     * @return A Promise that resolves to whether the string matches the pattern.
     */
    HarnessPredicate.stringMatches = function (s, pattern) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, s];
                    case 1:
                        s = _a.sent();
                        return [2 /*return*/, typeof pattern === 'string' ? s === pattern : pattern.test(s)];
                }
            });
        });
    };
    /**
     * Adds a predicate function to be run against candidate harnesses.
     * @param description A description of this predicate that may be used in error messages.
     * @param predicate An async predicate function.
     * @return this (for method chaining).
     */
    HarnessPredicate.prototype.add = function (description, predicate) {
        this._descriptions.push(description);
        this._predicates.push(predicate);
        return this;
    };
    /**
     * Adds a predicate function that depends on an option value to be run against candidate
     * harnesses. If the option value is undefined, the predicate will be ignored.
     * @param name The name of the option (may be used in error messages).
     * @param option The option value.
     * @param predicate The predicate function to run if the option value is not undefined.
     * @return this (for method chaining).
     */
    HarnessPredicate.prototype.addOption = function (name, option, predicate) {
        // Add quotes around strings to differentiate them from other values
        var value = typeof option === 'string' ? "\"" + option + "\"" : "" + option;
        if (option !== undefined) {
            this.add(name + " = " + value, function (item) { return predicate(item, option); });
        }
        return this;
    };
    /**
     * Filters a list of harnesses on this predicate.
     * @param harnesses The list of harnesses to filter.
     * @return A list of harnesses that satisfy this predicate.
     */
    HarnessPredicate.prototype.filter = function (harnesses) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var results;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.all(harnesses.map(function (h) { return _this.evaluate(h); }))];
                    case 1:
                        results = _a.sent();
                        return [2 /*return*/, harnesses.filter(function (_, i) { return results[i]; })];
                }
            });
        });
    };
    /**
     * Evaluates whether the given harness satisfies this predicate.
     * @param harness The harness to check
     * @return A promise that resolves to true if the harness satisfies this predicate,
     *   and resolves to false otherwise.
     */
    HarnessPredicate.prototype.evaluate = function (harness) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var results;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.all(this._predicates.map(function (p) { return p(harness); }))];
                    case 1:
                        results = _a.sent();
                        return [2 /*return*/, results.reduce(function (combined, current) { return combined && current; }, true)];
                }
            });
        });
    };
    /** Gets a description of this predicate for use in error messages. */
    HarnessPredicate.prototype.getDescription = function () {
        return this._descriptions.join(', ');
    };
    /** Gets the selector used to find candidate elements. */
    HarnessPredicate.prototype.getSelector = function () {
        var _this = this;
        return this._ancestor.split(',')
            .map(function (part) { return (part.trim() + " " + _this.harnessType.hostSelector).trim(); })
            .join(',');
    };
    /** Adds base options common to all harness types. */
    HarnessPredicate.prototype._addBaseOptions = function (options) {
        var _this = this;
        this._ancestor = options.ancestor || '';
        if (this._ancestor) {
            this._descriptions.push("has ancestor matching selector \"" + this._ancestor + "\"");
        }
        var selector = options.selector;
        if (selector !== undefined) {
            this.add("host matches selector \"" + selector + "\"", function (item) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, item.host()];
                        case 1: return [2 /*return*/, (_a.sent()).matchesSelector(selector)];
                    }
                });
            }); });
        }
    };
    return HarnessPredicate;
}());
export { HarnessPredicate };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcG9uZW50LWhhcm5lc3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvY2RrL3Rlc3RpbmcvY29tcG9uZW50LWhhcm5lc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOztBQWdMSDs7OztHQUlHO0FBQ0g7SUFDRSwwQkFBK0IsY0FBOEI7UUFBOUIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO0lBQUcsQ0FBQztJQUVqRSw2RkFBNkY7SUFDdkYsK0JBQUksR0FBVjs7O2dCQUNFLHNCQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsV0FBVyxFQUFDOzs7S0FDeEM7SUFFRDs7OztPQUlHO0lBQ08scURBQTBCLEdBQXBDO1FBQ0UsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLDBCQUEwQixFQUFFLENBQUM7SUFDMUQsQ0FBQztJQXlCUyxxQ0FBVSxHQUFwQixVQUFxQixHQUFRO1FBQzNCLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQXlCUyw2Q0FBa0IsR0FBNUIsVUFBNkIsR0FBUTtRQUNuQyxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDckQsQ0FBQztJQXdCUyx3Q0FBYSxHQUF2QixVQUF3QixHQUFRO1FBQzlCLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVEOzs7O09BSUc7SUFDYSx5Q0FBYyxHQUE5Qjs7O2dCQUNFLHNCQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxFQUFFLEVBQUM7OztLQUM3QztJQUVEOzs7T0FHRztJQUNhLHFEQUEwQixHQUExQzs7O2dCQUNFLHNCQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsMEJBQTBCLEVBQUUsRUFBQzs7O0tBQ3pEO0lBQ0gsdUJB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QUFHLENBQUMsVUFBQSxJQUFJLElBQUksT0FBQSxDQUFHLElBQUksQ0FBQyxJQUFJLEVBQUUsU0FBSSxLQUFJLENBQUMsV0FBVyxDQUFDLFlBQWMsQ0FBQSxDQUFDLElBQUksRUFBRSxFQUF4RCxDQUF3RCxDQUFDO2FBQ3JFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQixDQUFDO0lBRUQscURBQXFEO0lBQzdDLDBDQUFlLEdBQXZCLFVBQXdCLE9BQTJCO1FBQW5ELGlCQVdDO1FBVkMsSUFBSSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsUUFBUSxJQUFJLEVBQUUsQ0FBQztRQUN4QyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsc0NBQW1DLElBQUksQ0FBQyxTQUFTLE9BQUcsQ0FBQyxDQUFDO1NBQy9FO1FBQ0QsSUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQztRQUNsQyxJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7WUFDMUIsSUFBSSxDQUFDLEdBQUcsQ0FBQyw2QkFBMEIsUUFBUSxPQUFHLEVBQUUsVUFBTSxJQUFJOzs7Z0NBQ2hELHFCQUFNLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBQTtnQ0FBekIsc0JBQU8sQ0FBQyxTQUFpQixDQUFDLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxFQUFDOzs7aUJBQ3RELENBQUMsQ0FBQztTQUNKO0lBQ0gsQ0FBQztJQUNILHVCQUFDO0FBQUQsQ0FBQyxBQWpHRCxJQWlHQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge1Rlc3RFbGVtZW50fSBmcm9tICcuL3Rlc3QtZWxlbWVudCc7XG5cbi8qKiBBbiBhc3luYyBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlIHdoZW4gY2FsbGVkLiAqL1xuZXhwb3J0IHR5cGUgQXN5bmNGYWN0b3J5Rm48VD4gPSAoKSA9PiBQcm9taXNlPFQ+O1xuXG4vKiogQW4gYXN5bmMgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBpdGVtIGFuZCByZXR1cm5zIGEgYm9vbGVhbiBwcm9taXNlICovXG5leHBvcnQgdHlwZSBBc3luY1ByZWRpY2F0ZTxUPiA9IChpdGVtOiBUKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuXG4vKiogQW4gYXN5bmMgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBpdGVtIGFuZCBhbiBvcHRpb24gdmFsdWUgYW5kIHJldHVybnMgYSBib29sZWFuIHByb21pc2UuICovXG5leHBvcnQgdHlwZSBBc3luY09wdGlvblByZWRpY2F0ZTxULCBPPiA9IChpdGVtOiBULCBvcHRpb246IE8pID0+IFByb21pc2U8Ym9vbGVhbj47XG5cbi8qKlxuICogSW50ZXJmYWNlIHVzZWQgdG8gbG9hZCBDb21wb25lbnRIYXJuZXNzIG9iamVjdHMuIFRoaXMgaW50ZXJmYWNlIGlzIHVzZWQgYnkgdGVzdCBhdXRob3JzIHRvXG4gKiBpbnN0YW50aWF0ZSBgQ29tcG9uZW50SGFybmVzc2Blcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIYXJuZXNzTG9hZGVyIHtcbiAgLyoqXG4gICAqIFNlYXJjaGVzIGZvciBhbiBlbGVtZW50IHdpdGggdGhlIGdpdmVuIHNlbGVjdG9yIHVuZGVyIHRoZSBjdXJyZW50IGluc3RhbmNlcydzIHJvb3QgZWxlbWVudCxcbiAgICogYW5kIHJldHVybnMgYSBgSGFybmVzc0xvYWRlcmAgcm9vdGVkIGF0IHRoZSBtYXRjaGluZyBlbGVtZW50LiBJZiBtdWx0aXBsZSBlbGVtZW50cyBtYXRjaCB0aGVcbiAgICogc2VsZWN0b3IsIHRoZSBmaXJzdCBpcyB1c2VkLiBJZiBubyBlbGVtZW50cyBtYXRjaCwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIGZvciB0aGUgcm9vdCBlbGVtZW50IG9mIHRoZSBuZXcgYEhhcm5lc3NMb2FkZXJgXG4gICAqIEByZXR1cm4gQSBgSGFybmVzc0xvYWRlcmAgcm9vdGVkIGF0IHRoZSBlbGVtZW50IG1hdGNoaW5nIHRoZSBnaXZlbiBzZWxlY3Rvci5cbiAgICogQHRocm93cyBJZiBhIG1hdGNoaW5nIGVsZW1lbnQgY2FuJ3QgYmUgZm91bmQuXG4gICAqL1xuICBnZXRDaGlsZExvYWRlcihzZWxlY3Rvcjogc3RyaW5nKTogUHJvbWlzZTxIYXJuZXNzTG9hZGVyPjtcblxuICAvKipcbiAgICogU2VhcmNoZXMgZm9yIGFsbCBlbGVtZW50cyB3aXRoIHRoZSBnaXZlbiBzZWxlY3RvciB1bmRlciB0aGUgY3VycmVudCBpbnN0YW5jZXMncyByb290IGVsZW1lbnQsXG4gICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGBIYXJuZXNzTG9hZGVyYHMsIG9uZSBmb3IgZWFjaCBtYXRjaGluZyBlbGVtZW50LCByb290ZWQgYXQgdGhhdFxuICAgKiBlbGVtZW50LlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIGZvciB0aGUgcm9vdCBlbGVtZW50IG9mIHRoZSBuZXcgYEhhcm5lc3NMb2FkZXJgXG4gICAqIEByZXR1cm4gQSBsaXN0IG9mIGBIYXJuZXNzTG9hZGVyYHMsIG9uZSBmb3IgZWFjaCBtYXRjaGluZyBlbGVtZW50LCByb290ZWQgYXQgdGhhdCBlbGVtZW50LlxuICAgKi9cbiAgZ2V0QWxsQ2hpbGRMb2FkZXJzKHNlbGVjdG9yOiBzdHJpbmcpOiBQcm9taXNlPEhhcm5lc3NMb2FkZXJbXT47XG5cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGZvciBhbiBpbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGhhcm5lc3MgdHlwZSB1bmRlciB0aGVcbiAgICogYEhhcm5lc3NMb2FkZXJgJ3Mgcm9vdCBlbGVtZW50LCBhbmQgcmV0dXJucyBhIGBDb21wb25lbnRIYXJuZXNzYCBmb3IgdGhhdCBpbnN0YW5jZS4gSWYgbXVsdGlwbGVcbiAgICogbWF0Y2hpbmcgY29tcG9uZW50cyBhcmUgZm91bmQsIGEgaGFybmVzcyBmb3IgdGhlIGZpcnN0IG9uZSBpcyByZXR1cm5lZC4gSWYgbm8gbWF0Y2hpbmdcbiAgICogY29tcG9uZW50IGlzIGZvdW5kLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gICAqIEBwYXJhbSBoYXJuZXNzVHlwZSBUaGUgdHlwZSBvZiBoYXJuZXNzIHRvIGNyZWF0ZVxuICAgKiBAcmV0dXJuIEFuIGluc3RhbmNlIG9mIHRoZSBnaXZlbiBoYXJuZXNzIHR5cGVcbiAgICogQHRocm93cyBJZiBhIG1hdGNoaW5nIGNvbXBvbmVudCBpbnN0YW5jZSBjYW4ndCBiZSBmb3VuZC5cbiAgICovXG4gIGdldEhhcm5lc3M8VCBleHRlbmRzIENvbXBvbmVudEhhcm5lc3M+KFxuICAgICAgaGFybmVzc1R5cGU6IENvbXBvbmVudEhhcm5lc3NDb25zdHJ1Y3RvcjxUPiB8IEhhcm5lc3NQcmVkaWNhdGU8VD4pOiBQcm9taXNlPFQ+O1xuXG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgYWxsIGluc3RhbmNlcyBvZiB0aGUgY29tcG9uZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGhhcm5lc3MgdHlwZSB1bmRlciB0aGVcbiAgICogYEhhcm5lc3NMb2FkZXJgJ3Mgcm9vdCBlbGVtZW50LCBhbmQgcmV0dXJucyBhIGxpc3QgYENvbXBvbmVudEhhcm5lc3NgIGZvciBlYWNoIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gaGFybmVzc1R5cGUgVGhlIHR5cGUgb2YgaGFybmVzcyB0byBjcmVhdGVcbiAgICogQHJldHVybiBBIGxpc3QgaW5zdGFuY2VzIG9mIHRoZSBnaXZlbiBoYXJuZXNzIHR5cGUuXG4gICAqL1xuICBnZXRBbGxIYXJuZXNzZXM8VCBleHRlbmRzIENvbXBvbmVudEhhcm5lc3M+KFxuICAgICAgaGFybmVzc1R5cGU6IENvbXBvbmVudEhhcm5lc3NDb25zdHJ1Y3RvcjxUPiB8IEhhcm5lc3NQcmVkaWNhdGU8VD4pOiBQcm9taXNlPFRbXT47XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIHVzZWQgdG8gY3JlYXRlIGFzeW5jaHJvbm91cyBsb2NhdG9yIGZ1bmN0aW9ucyB1c2VkIGZpbmQgZWxlbWVudHMgYW5kIGNvbXBvbmVudFxuICogaGFybmVzc2VzLiBUaGlzIGludGVyZmFjZSBpcyB1c2VkIGJ5IGBDb21wb25lbnRIYXJuZXNzYCBhdXRob3JzIHRvIGNyZWF0ZSBsb2NhdG9yIGZ1bmN0aW9ucyBmb3JcbiAqIHRoZWlyIGBDb21wb25lbnRIYXJuZXNzYCBzdWJjbGFzcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2NhdG9yRmFjdG9yeSB7XG4gIC8qKiBHZXRzIGEgbG9jYXRvciBmYWN0b3J5IHJvb3RlZCBhdCB0aGUgZG9jdW1lbnQgcm9vdC4gKi9cbiAgZG9jdW1lbnRSb290TG9jYXRvckZhY3RvcnkoKTogTG9jYXRvckZhY3Rvcnk7XG5cbiAgLyoqIFRoZSByb290IGVsZW1lbnQgb2YgdGhpcyBgTG9jYXRvckZhY3RvcnlgIGFzIGEgYFRlc3RFbGVtZW50YC4gKi9cbiAgcm9vdEVsZW1lbnQ6IFRlc3RFbGVtZW50O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBsb2NhdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gc2VhcmNoIGZvciBlbGVtZW50cyB3aXRoIHRoZSBnaXZlblxuICAgKiBzZWxlY3RvciB1bmRlciB0aGUgcm9vdCBlbGVtZW50IG9mIHRoaXMgYExvY2F0b3JGYWN0b3J5YC4gV2hlbiB0aGUgcmVzdWx0aW5nIGxvY2F0b3IgZnVuY3Rpb25cbiAgICogaXMgaW52b2tlZCwgaWYgbXVsdGlwbGUgbWF0Y2hpbmcgZWxlbWVudHMgYXJlIGZvdW5kLCB0aGUgZmlyc3QgZWxlbWVudCBpcyByZXR1cm5lZC4gSWYgbm9cbiAgICogZWxlbWVudHMgYXJlIGZvdW5kLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gICAqIEBwYXJhbSBzZWxlY3RvciBUaGUgc2VsZWN0b3IgZm9yIHRoZSBlbGVtZW50IHRoYXQgdGhlIGxvY2F0b3IgZnVuY3Rpb24gc2hvdWxkIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm4gQW4gYXN5bmNocm9ub3VzIGxvY2F0b3IgZnVuY3Rpb24gdGhhdCBzZWFyY2hlcyBmb3IgZWxlbWVudHMgd2l0aCB0aGUgZ2l2ZW4gc2VsZWN0b3IsXG4gICAqICAgICBhbmQgZWl0aGVyIGZpbmRzIG9uZSBvciB0aHJvd3MgYW4gZXJyb3JcbiAgICovXG4gIGxvY2F0b3JGb3Ioc2VsZWN0b3I6IHN0cmluZyk6IEFzeW5jRmFjdG9yeUZuPFRlc3RFbGVtZW50PjtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgbG9jYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGZpbmQgYSBgQ29tcG9uZW50SGFybmVzc2AgZm9yIGFcbiAgICogY29tcG9uZW50IG1hdGNoaW5nIHRoZSBnaXZlbiBoYXJuZXNzIHR5cGUgdW5kZXIgdGhlIHJvb3QgZWxlbWVudCBvZiB0aGlzIGBMb2NhdG9yRmFjdG9yeWAuXG4gICAqIFdoZW4gdGhlIHJlc3VsdGluZyBsb2NhdG9yIGZ1bmN0aW9uIGlzIGludm9rZWQsIGlmIG11bHRpcGxlIG1hdGNoaW5nIGNvbXBvbmVudHMgYXJlIGZvdW5kLCBhXG4gICAqIGhhcm5lc3MgZm9yIHRoZSBmaXJzdCBvbmUgaXMgcmV0dXJuZWQuIElmIG5vIGNvbXBvbmVudHMgYXJlIGZvdW5kLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gICAqIEBwYXJhbSBoYXJuZXNzVHlwZSBUaGUgdHlwZSBvZiBoYXJuZXNzIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm4gQW4gYXN5bmNocm9ub3VzIGxvY2F0b3IgZnVuY3Rpb24gdGhhdCBzZWFyY2hlcyBjb21wb25lbnRzIG1hdGNoaW5nIHRoZSBnaXZlbiBoYXJuZXNzXG4gICAqICAgICB0eXBlLCBhbmQgZWl0aGVyIHJldHVybnMgYSBgQ29tcG9uZW50SGFybmVzc2AgZm9yIHRoZSBjb21wb25lbnQsIG9yIHRocm93cyBhbiBlcnJvci5cbiAgICovXG4gIGxvY2F0b3JGb3I8VCBleHRlbmRzIENvbXBvbmVudEhhcm5lc3M+KFxuICAgICAgaGFybmVzc1R5cGU6IENvbXBvbmVudEhhcm5lc3NDb25zdHJ1Y3RvcjxUPiB8IEhhcm5lc3NQcmVkaWNhdGU8VD4pOiBBc3luY0ZhY3RvcnlGbjxUPjtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgbG9jYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHNlYXJjaCBmb3IgZWxlbWVudHMgd2l0aCB0aGUgZ2l2ZW5cbiAgICogc2VsZWN0b3IgdW5kZXIgdGhlIHJvb3QgZWxlbWVudCBvZiB0aGlzIGBMb2NhdG9yRmFjdG9yeWAuIFdoZW4gdGhlIHJlc3VsdGluZyBsb2NhdG9yIGZ1bmN0aW9uXG4gICAqIGlzIGludm9rZWQsIGlmIG11bHRpcGxlIG1hdGNoaW5nIGVsZW1lbnRzIGFyZSBmb3VuZCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgcmV0dXJuZWQuIElmIG5vXG4gICAqIGVsZW1lbnRzIGFyZSBmb3VuZCwgbnVsbCBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHNlbGVjdG9yIFRoZSBzZWxlY3RvciBmb3IgdGhlIGVsZW1lbnQgdGhhdCB0aGUgbG9jYXRvciBmdW5jdGlvbiBzaG91bGQgc2VhcmNoIGZvci5cbiAgICogQHJldHVybiBBbiBhc3luY2hyb25vdXMgbG9jYXRvciBmdW5jdGlvbiB0aGF0IHNlYXJjaGVzIGZvciBlbGVtZW50cyB3aXRoIHRoZSBnaXZlbiBzZWxlY3RvcixcbiAgICogICAgIGFuZCBlaXRoZXIgZmluZHMgb25lIG9yIHJldHVybnMgbnVsbC5cbiAgICovXG4gIGxvY2F0b3JGb3JPcHRpb25hbChzZWxlY3Rvcjogc3RyaW5nKTogQXN5bmNGYWN0b3J5Rm48VGVzdEVsZW1lbnQgfCBudWxsPjtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgbG9jYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGZpbmQgYSBgQ29tcG9uZW50SGFybmVzc2AgZm9yIGFcbiAgICogY29tcG9uZW50IG1hdGNoaW5nIHRoZSBnaXZlbiBoYXJuZXNzIHR5cGUgdW5kZXIgdGhlIHJvb3QgZWxlbWVudCBvZiB0aGlzIGBMb2NhdG9yRmFjdG9yeWAuXG4gICAqIFdoZW4gdGhlIHJlc3VsdGluZyBsb2NhdG9yIGZ1bmN0aW9uIGlzIGludm9rZWQsIGlmIG11bHRpcGxlIG1hdGNoaW5nIGNvbXBvbmVudHMgYXJlIGZvdW5kLCBhXG4gICAqIGhhcm5lc3MgZm9yIHRoZSBmaXJzdCBvbmUgaXMgcmV0dXJuZWQuIElmIG5vIGNvbXBvbmVudHMgYXJlIGZvdW5kLCBudWxsIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0gaGFybmVzc1R5cGUgVGhlIHR5cGUgb2YgaGFybmVzcyB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJuIEFuIGFzeW5jaHJvbm91cyBsb2NhdG9yIGZ1bmN0aW9uIHRoYXQgc2VhcmNoZXMgY29tcG9uZW50cyBtYXRjaGluZyB0aGUgZ2l2ZW4gaGFybmVzc1xuICAgKiAgICAgdHlwZSwgYW5kIGVpdGhlciByZXR1cm5zIGEgYENvbXBvbmVudEhhcm5lc3NgIGZvciB0aGUgY29tcG9uZW50LCBvciBudWxsIGlmIG5vbmUgaXMgZm91bmQuXG4gICAqL1xuICBsb2NhdG9yRm9yT3B0aW9uYWw8VCBleHRlbmRzIENvbXBvbmVudEhhcm5lc3M+KFxuICAgICAgaGFybmVzc1R5cGU6IENvbXBvbmVudEhhcm5lc3NDb25zdHJ1Y3RvcjxUPiB8IEhhcm5lc3NQcmVkaWNhdGU8VD4pOiBBc3luY0ZhY3RvcnlGbjxUIHwgbnVsbD47XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXN5bmNocm9ub3VzIGxvY2F0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBzZWFyY2ggZm9yIGEgbGlzdCBvZiBlbGVtZW50cyB3aXRoXG4gICAqIHRoZSBnaXZlbiBzZWxlY3RvciB1bmRlciB0aGUgcm9vdCBlbGVtZW50IG9mIHRoaXMgYExvY2F0b3JGYWN0b3J5YC4gV2hlbiB0aGUgcmVzdWx0aW5nIGxvY2F0b3JcbiAgICogZnVuY3Rpb24gaXMgaW52b2tlZCwgYSBsaXN0IG9mIG1hdGNoaW5nIGVsZW1lbnRzIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIGZvciB0aGUgZWxlbWVudCB0aGF0IHRoZSBsb2NhdG9yIGZ1bmN0aW9uIHNob3VsZCBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJuIEFuIGFzeW5jaHJvbm91cyBsb2NhdG9yIGZ1bmN0aW9uIHRoYXQgc2VhcmNoZXMgZm9yIGVsZW1lbnRzIHdpdGggdGhlIGdpdmVuIHNlbGVjdG9yLFxuICAgKiAgICAgYW5kIGVpdGhlciBmaW5kcyBvbmUgb3IgdGhyb3dzIGFuIGVycm9yXG4gICAqL1xuICBsb2NhdG9yRm9yQWxsKHNlbGVjdG9yOiBzdHJpbmcpOiBBc3luY0ZhY3RvcnlGbjxUZXN0RWxlbWVudFtdPjtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgbG9jYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGZpbmQgYSBsaXN0IG9mXG4gICAqIGBDb21wb25lbnRIYXJuZXNzYGVzIGZvciBhbGwgY29tcG9uZW50cyBtYXRjaGluZyB0aGUgZ2l2ZW4gaGFybmVzcyB0eXBlIHVuZGVyIHRoZSByb290IGVsZW1lbnRcbiAgICogb2YgdGhpcyBgTG9jYXRvckZhY3RvcnlgLiBXaGVuIHRoZSByZXN1bHRpbmcgbG9jYXRvciBmdW5jdGlvbiBpcyBpbnZva2VkLCBhIGxpc3Qgb2ZcbiAgICogYENvbXBvbmVudEhhcm5lc3NgZXMgZm9yIHRoZSBtYXRjaGluZyBjb21wb25lbnRzIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0gaGFybmVzc1R5cGUgVGhlIHR5cGUgb2YgaGFybmVzcyB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJuIEFuIGFzeW5jaHJvbm91cyBsb2NhdG9yIGZ1bmN0aW9uIHRoYXQgc2VhcmNoZXMgY29tcG9uZW50cyBtYXRjaGluZyB0aGUgZ2l2ZW4gaGFybmVzc1xuICAgKiAgICAgdHlwZSwgYW5kIHJldHVybnMgYSBsaXN0IG9mIGBDb21wb25lbnRIYXJuZXNzYGVzLlxuICAgKi9cbiAgbG9jYXRvckZvckFsbDxUIGV4dGVuZHMgQ29tcG9uZW50SGFybmVzcz4oXG4gICAgICBoYXJuZXNzVHlwZTogQ29tcG9uZW50SGFybmVzc0NvbnN0cnVjdG9yPFQ+IHwgSGFybmVzc1ByZWRpY2F0ZTxUPik6IEFzeW5jRmFjdG9yeUZuPFRbXT47XG5cbiAgLyoqXG4gICAqIEdldHMgYSBgSGFybmVzc0xvYWRlcmAgaW5zdGFuY2UgZm9yIGFuIGVsZW1lbnQgdW5kZXIgdGhlIHJvb3Qgb2YgdGhpcyBgTG9jYXRvckZhY3RvcnlgLlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIGZvciB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIEEgYEhhcm5lc3NMb2FkZXJgIHJvb3RlZCBhdCB0aGUgZmlyc3QgZWxlbWVudCBtYXRjaGluZyB0aGUgZ2l2ZW4gc2VsZWN0b3IuXG4gICAqIEB0aHJvd3MgSWYgbm8gbWF0Y2hpbmcgZWxlbWVudCBpcyBmb3VuZCBmb3IgdGhlIGdpdmVuIHNlbGVjdG9yLlxuICAgKi9cbiAgaGFybmVzc0xvYWRlckZvcihzZWxlY3Rvcjogc3RyaW5nKTogUHJvbWlzZTxIYXJuZXNzTG9hZGVyPjtcblxuICAvKipcbiAgICogR2V0cyBhIGBIYXJuZXNzTG9hZGVyYCBpbnN0YW5jZSBmb3IgYW4gZWxlbWVudCB1bmRlciB0aGUgcm9vdCBvZiB0aGlzIGBMb2NhdG9yRmFjdG9yeWBcbiAgICogQHBhcmFtIHNlbGVjdG9yIFRoZSBzZWxlY3RvciBmb3IgdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHJldHVybiBBIGBIYXJuZXNzTG9hZGVyYCByb290ZWQgYXQgdGhlIGZpcnN0IGVsZW1lbnQgbWF0Y2hpbmcgdGhlIGdpdmVuIHNlbGVjdG9yLCBvciBudWxsIGlmXG4gICAqICAgICBubyBtYXRjaGluZyBlbGVtZW50IGlzIGZvdW5kLlxuICAgKi9cbiAgaGFybmVzc0xvYWRlckZvck9wdGlvbmFsKHNlbGVjdG9yOiBzdHJpbmcpOiBQcm9taXNlPEhhcm5lc3NMb2FkZXIgfCBudWxsPjtcblxuICAvKipcbiAgICogR2V0cyBhIGxpc3Qgb2YgYEhhcm5lc3NMb2FkZXJgIGluc3RhbmNlcywgb25lIGZvciBlYWNoIG1hdGNoaW5nIGVsZW1lbnQuXG4gICAqIEBwYXJhbSBzZWxlY3RvciBUaGUgc2VsZWN0b3IgZm9yIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEByZXR1cm4gQSBsaXN0IG9mIGBIYXJuZXNzTG9hZGVyYCwgb25lIHJvb3RlZCBhdCBlYWNoIGVsZW1lbnQgbWF0Y2hpbmcgdGhlIGdpdmVuIHNlbGVjdG9yLlxuICAgKi9cbiAgaGFybmVzc0xvYWRlckZvckFsbChzZWxlY3Rvcjogc3RyaW5nKTogUHJvbWlzZTxIYXJuZXNzTG9hZGVyW10+O1xuXG4gIC8qKlxuICAgKiBGbHVzaGVzIGNoYW5nZSBkZXRlY3Rpb24gYW5kIGFzeW5jIHRhc2tzIGNhcHR1cmVkIGluIHRoZSBBbmd1bGFyIHpvbmUuXG4gICAqIEluIG1vc3QgY2FzZXMgaXQgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgdG8gY2FsbCB0aGlzIG1hbnVhbGx5LiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgc29tZSBlZGdlXG4gICAqIGNhc2VzIHdoZXJlIGl0IGlzIG5lZWRlZCB0byBmdWxseSBmbHVzaCBhbmltYXRpb24gZXZlbnRzLlxuICAgKi9cbiAgZm9yY2VTdGFiaWxpemUoKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogV2FpdHMgZm9yIGFsbCBzY2hlZHVsZWQgb3IgcnVubmluZyBhc3luYyB0YXNrcyB0byBjb21wbGV0ZS4gVGhpcyBhbGxvd3MgaGFybmVzc1xuICAgKiBhdXRob3JzIHRvIHdhaXQgZm9yIGFzeW5jIHRhc2tzIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZS5cbiAgICovXG4gIHdhaXRGb3JUYXNrc091dHNpZGVBbmd1bGFyKCk6IFByb21pc2U8dm9pZD47XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY29tcG9uZW50IGhhcm5lc3NlcyB0aGF0IGFsbCBjb21wb25lbnQgaGFybmVzcyBhdXRob3JzIHNob3VsZCBleHRlbmQuIFRoaXMgYmFzZVxuICogY29tcG9uZW50IGhhcm5lc3MgcHJvdmlkZXMgdGhlIGJhc2ljIGFiaWxpdHkgdG8gbG9jYXRlIGVsZW1lbnQgYW5kIHN1Yi1jb21wb25lbnQgaGFybmVzcy4gSXRcbiAqIHNob3VsZCBiZSBpbmhlcml0ZWQgd2hlbiBkZWZpbmluZyB1c2VyJ3Mgb3duIGhhcm5lc3MuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDb21wb25lbnRIYXJuZXNzIHtcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IGxvY2F0b3JGYWN0b3J5OiBMb2NhdG9yRmFjdG9yeSkge31cblxuICAvKiogR2V0cyBhIGBQcm9taXNlYCBmb3IgdGhlIGBUZXN0RWxlbWVudGAgcmVwcmVzZW50aW5nIHRoZSBob3N0IGVsZW1lbnQgb2YgdGhlIGNvbXBvbmVudC4gKi9cbiAgYXN5bmMgaG9zdCgpOiBQcm9taXNlPFRlc3RFbGVtZW50PiB7XG4gICAgcmV0dXJuIHRoaXMubG9jYXRvckZhY3Rvcnkucm9vdEVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIGBMb2NhdG9yRmFjdG9yeWAgZm9yIHRoZSBkb2N1bWVudCByb290IGVsZW1lbnQuIFRoaXMgZmFjdG9yeSBjYW4gYmUgdXNlZCB0byBjcmVhdGVcbiAgICogbG9jYXRvcnMgZm9yIGVsZW1lbnRzIHRoYXQgYSBjb21wb25lbnQgY3JlYXRlcyBvdXRzaWRlIG9mIGl0cyBvd24gcm9vdCBlbGVtZW50LiAoZS5nLiBieVxuICAgKiBhcHBlbmRpbmcgdG8gZG9jdW1lbnQuYm9keSkuXG4gICAqL1xuICBwcm90ZWN0ZWQgZG9jdW1lbnRSb290TG9jYXRvckZhY3RvcnkoKTogTG9jYXRvckZhY3Rvcnkge1xuICAgIHJldHVybiB0aGlzLmxvY2F0b3JGYWN0b3J5LmRvY3VtZW50Um9vdExvY2F0b3JGYWN0b3J5KCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgbG9jYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHNlYXJjaCBmb3IgZWxlbWVudHMgd2l0aCB0aGUgZ2l2ZW5cbiAgICogc2VsZWN0b3IgdW5kZXIgdGhlIGhvc3QgZWxlbWVudCBvZiB0aGlzIGBDb21wb25lbnRIYXJuZXNzYC4gV2hlbiB0aGUgcmVzdWx0aW5nIGxvY2F0b3IgZnVuY3Rpb25cbiAgICogaXMgaW52b2tlZCwgaWYgbXVsdGlwbGUgbWF0Y2hpbmcgZWxlbWVudHMgYXJlIGZvdW5kLCB0aGUgZmlyc3QgZWxlbWVudCBpcyByZXR1cm5lZC4gSWYgbm9cbiAgICogZWxlbWVudHMgYXJlIGZvdW5kLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gICAqIEBwYXJhbSBzZWxlY3RvciBUaGUgc2VsZWN0b3IgZm9yIHRoZSBlbGVtZW50IHRoYXQgdGhlIGxvY2F0b3IgZnVuY3Rpb24gc2hvdWxkIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm4gQW4gYXN5bmNocm9ub3VzIGxvY2F0b3IgZnVuY3Rpb24gdGhhdCBzZWFyY2hlcyBmb3IgZWxlbWVudHMgd2l0aCB0aGUgZ2l2ZW4gc2VsZWN0b3IsXG4gICAqICAgICBhbmQgZWl0aGVyIGZpbmRzIG9uZSBvciB0aHJvd3MgYW4gZXJyb3JcbiAgICovXG4gIHByb3RlY3RlZCBsb2NhdG9yRm9yKHNlbGVjdG9yOiBzdHJpbmcpOiBBc3luY0ZhY3RvcnlGbjxUZXN0RWxlbWVudD47XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXN5bmNocm9ub3VzIGxvY2F0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBmaW5kIGEgYENvbXBvbmVudEhhcm5lc3NgIGZvciBhXG4gICAqIGNvbXBvbmVudCBtYXRjaGluZyB0aGUgZ2l2ZW4gaGFybmVzcyB0eXBlIHVuZGVyIHRoZSBob3N0IGVsZW1lbnQgb2YgdGhpcyBgQ29tcG9uZW50SGFybmVzc2AuXG4gICAqIFdoZW4gdGhlIHJlc3VsdGluZyBsb2NhdG9yIGZ1bmN0aW9uIGlzIGludm9rZWQsIGlmIG11bHRpcGxlIG1hdGNoaW5nIGNvbXBvbmVudHMgYXJlIGZvdW5kLCBhXG4gICAqIGhhcm5lc3MgZm9yIHRoZSBmaXJzdCBvbmUgaXMgcmV0dXJuZWQuIElmIG5vIGNvbXBvbmVudHMgYXJlIGZvdW5kLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gICAqIEBwYXJhbSBoYXJuZXNzVHlwZSBUaGUgdHlwZSBvZiBoYXJuZXNzIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm4gQW4gYXN5bmNocm9ub3VzIGxvY2F0b3IgZnVuY3Rpb24gdGhhdCBzZWFyY2hlcyBjb21wb25lbnRzIG1hdGNoaW5nIHRoZSBnaXZlbiBoYXJuZXNzXG4gICAqICAgICB0eXBlLCBhbmQgZWl0aGVyIHJldHVybnMgYSBgQ29tcG9uZW50SGFybmVzc2AgZm9yIHRoZSBjb21wb25lbnQsIG9yIHRocm93cyBhbiBlcnJvci5cbiAgICovXG4gIHByb3RlY3RlZCBsb2NhdG9yRm9yPFQgZXh0ZW5kcyBDb21wb25lbnRIYXJuZXNzPihcbiAgICAgIGhhcm5lc3NUeXBlOiBDb21wb25lbnRIYXJuZXNzQ29uc3RydWN0b3I8VD4gfCBIYXJuZXNzUHJlZGljYXRlPFQ+KTogQXN5bmNGYWN0b3J5Rm48VD47XG5cbiAgcHJvdGVjdGVkIGxvY2F0b3JGb3IoYXJnOiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhdG9yRmFjdG9yeS5sb2NhdG9yRm9yKGFyZyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgbG9jYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHNlYXJjaCBmb3IgZWxlbWVudHMgd2l0aCB0aGUgZ2l2ZW5cbiAgICogc2VsZWN0b3IgdW5kZXIgdGhlIGhvc3QgZWxlbWVudCBvZiB0aGlzIGBDb21wb25lbnRIYXJuZXNzYC4gV2hlbiB0aGUgcmVzdWx0aW5nIGxvY2F0b3IgZnVuY3Rpb25cbiAgICogaXMgaW52b2tlZCwgaWYgbXVsdGlwbGUgbWF0Y2hpbmcgZWxlbWVudHMgYXJlIGZvdW5kLCB0aGUgZmlyc3QgZWxlbWVudCBpcyByZXR1cm5lZC4gSWYgbm9cbiAgICogZWxlbWVudHMgYXJlIGZvdW5kLCBudWxsIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIGZvciB0aGUgZWxlbWVudCB0aGF0IHRoZSBsb2NhdG9yIGZ1bmN0aW9uIHNob3VsZCBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJuIEFuIGFzeW5jaHJvbm91cyBsb2NhdG9yIGZ1bmN0aW9uIHRoYXQgc2VhcmNoZXMgZm9yIGVsZW1lbnRzIHdpdGggdGhlIGdpdmVuIHNlbGVjdG9yLFxuICAgKiAgICAgYW5kIGVpdGhlciBmaW5kcyBvbmUgb3IgcmV0dXJucyBudWxsLlxuICAgKi9cbiAgcHJvdGVjdGVkIGxvY2F0b3JGb3JPcHRpb25hbChzZWxlY3Rvcjogc3RyaW5nKTogQXN5bmNGYWN0b3J5Rm48VGVzdEVsZW1lbnQgfCBudWxsPjtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgbG9jYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGZpbmQgYSBgQ29tcG9uZW50SGFybmVzc2AgZm9yIGFcbiAgICogY29tcG9uZW50IG1hdGNoaW5nIHRoZSBnaXZlbiBoYXJuZXNzIHR5cGUgdW5kZXIgdGhlIGhvc3QgZWxlbWVudCBvZiB0aGlzIGBDb21wb25lbnRIYXJuZXNzYC5cbiAgICogV2hlbiB0aGUgcmVzdWx0aW5nIGxvY2F0b3IgZnVuY3Rpb24gaXMgaW52b2tlZCwgaWYgbXVsdGlwbGUgbWF0Y2hpbmcgY29tcG9uZW50cyBhcmUgZm91bmQsIGFcbiAgICogaGFybmVzcyBmb3IgdGhlIGZpcnN0IG9uZSBpcyByZXR1cm5lZC4gSWYgbm8gY29tcG9uZW50cyBhcmUgZm91bmQsIG51bGwgaXMgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSBoYXJuZXNzVHlwZSBUaGUgdHlwZSBvZiBoYXJuZXNzIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm4gQW4gYXN5bmNocm9ub3VzIGxvY2F0b3IgZnVuY3Rpb24gdGhhdCBzZWFyY2hlcyBjb21wb25lbnRzIG1hdGNoaW5nIHRoZSBnaXZlbiBoYXJuZXNzXG4gICAqICAgICB0eXBlLCBhbmQgZWl0aGVyIHJldHVybnMgYSBgQ29tcG9uZW50SGFybmVzc2AgZm9yIHRoZSBjb21wb25lbnQsIG9yIG51bGwgaWYgbm9uZSBpcyBmb3VuZC5cbiAgICovXG4gIHByb3RlY3RlZCBsb2NhdG9yRm9yT3B0aW9uYWw8VCBleHRlbmRzIENvbXBvbmVudEhhcm5lc3M+KFxuICAgICAgaGFybmVzc1R5cGU6IENvbXBvbmVudEhhcm5lc3NDb25zdHJ1Y3RvcjxUPiB8IEhhcm5lc3NQcmVkaWNhdGU8VD4pOiBBc3luY0ZhY3RvcnlGbjxUIHwgbnVsbD47XG5cbiAgcHJvdGVjdGVkIGxvY2F0b3JGb3JPcHRpb25hbChhcmc6IGFueSkge1xuICAgIHJldHVybiB0aGlzLmxvY2F0b3JGYWN0b3J5LmxvY2F0b3JGb3JPcHRpb25hbChhcmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXN5bmNocm9ub3VzIGxvY2F0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBzZWFyY2ggZm9yIGEgbGlzdCBvZiBlbGVtZW50cyB3aXRoXG4gICAqIHRoZSBnaXZlbiBzZWxlY3RvciB1bmRlciB0aGUgaG9zdCBlbGVtZW50IG9mIHRoaXMgYENvbXBvbmVudEhhcm5lc3NgLiBXaGVuIHRoZSByZXN1bHRpbmdcbiAgICogbG9jYXRvciBmdW5jdGlvbiBpcyBpbnZva2VkLCBhIGxpc3Qgb2YgbWF0Y2hpbmcgZWxlbWVudHMgaXMgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSBzZWxlY3RvciBUaGUgc2VsZWN0b3IgZm9yIHRoZSBlbGVtZW50IHRoYXQgdGhlIGxvY2F0b3IgZnVuY3Rpb24gc2hvdWxkIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm4gQW4gYXN5bmNocm9ub3VzIGxvY2F0b3IgZnVuY3Rpb24gdGhhdCBzZWFyY2hlcyBmb3IgZWxlbWVudHMgd2l0aCB0aGUgZ2l2ZW4gc2VsZWN0b3IsXG4gICAqICAgICBhbmQgZWl0aGVyIGZpbmRzIG9uZSBvciB0aHJvd3MgYW4gZXJyb3JcbiAgICovXG4gIHByb3RlY3RlZCBsb2NhdG9yRm9yQWxsKHNlbGVjdG9yOiBzdHJpbmcpOiBBc3luY0ZhY3RvcnlGbjxUZXN0RWxlbWVudFtdPjtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgbG9jYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGZpbmQgYSBsaXN0IG9mXG4gICAqIGBDb21wb25lbnRIYXJuZXNzYGVzIGZvciBhbGwgY29tcG9uZW50cyBtYXRjaGluZyB0aGUgZ2l2ZW4gaGFybmVzcyB0eXBlIHVuZGVyIHRoZSBob3N0IGVsZW1lbnRcbiAgICogb2YgdGhpcyBgQ29tcG9uZW50SGFybmVzc2AuIFdoZW4gdGhlIHJlc3VsdGluZyBsb2NhdG9yIGZ1bmN0aW9uIGlzIGludm9rZWQsIGEgbGlzdCBvZlxuICAgKiBgQ29tcG9uZW50SGFybmVzc2BlcyBmb3IgdGhlIG1hdGNoaW5nIGNvbXBvbmVudHMgaXMgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSBoYXJuZXNzVHlwZSBUaGUgdHlwZSBvZiBoYXJuZXNzIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm4gQW4gYXN5bmNocm9ub3VzIGxvY2F0b3IgZnVuY3Rpb24gdGhhdCBzZWFyY2hlcyBjb21wb25lbnRzIG1hdGNoaW5nIHRoZSBnaXZlbiBoYXJuZXNzXG4gICAqICAgICB0eXBlLCBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgYENvbXBvbmVudEhhcm5lc3NgZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgbG9jYXRvckZvckFsbDxUIGV4dGVuZHMgQ29tcG9uZW50SGFybmVzcz4oXG4gICAgICBoYXJuZXNzVHlwZTogQ29tcG9uZW50SGFybmVzc0NvbnN0cnVjdG9yPFQ+IHwgSGFybmVzc1ByZWRpY2F0ZTxUPik6IEFzeW5jRmFjdG9yeUZuPFRbXT47XG5cbiAgcHJvdGVjdGVkIGxvY2F0b3JGb3JBbGwoYXJnOiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhdG9yRmFjdG9yeS5sb2NhdG9yRm9yQWxsKGFyZyk7XG4gIH1cblxuICAvKipcbiAgICogRmx1c2hlcyBjaGFuZ2UgZGV0ZWN0aW9uIGFuZCBhc3luYyB0YXNrcyBpbiB0aGUgQW5ndWxhciB6b25lLlxuICAgKiBJbiBtb3N0IGNhc2VzIGl0IHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5IHRvIGNhbGwgdGhpcyBtYW51YWxseS4gSG93ZXZlciwgdGhlcmUgbWF5IGJlIHNvbWUgZWRnZVxuICAgKiBjYXNlcyB3aGVyZSBpdCBpcyBuZWVkZWQgdG8gZnVsbHkgZmx1c2ggYW5pbWF0aW9uIGV2ZW50cy5cbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBmb3JjZVN0YWJpbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhdG9yRmFjdG9yeS5mb3JjZVN0YWJpbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciBhbGwgc2NoZWR1bGVkIG9yIHJ1bm5pbmcgYXN5bmMgdGFza3MgdG8gY29tcGxldGUuIFRoaXMgYWxsb3dzIGhhcm5lc3NcbiAgICogYXV0aG9ycyB0byB3YWl0IGZvciBhc3luYyB0YXNrcyBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmUuXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgd2FpdEZvclRhc2tzT3V0c2lkZUFuZ3VsYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYXRvckZhY3Rvcnkud2FpdEZvclRhc2tzT3V0c2lkZUFuZ3VsYXIoKTtcbiAgfVxufVxuXG4vKiogQ29uc3RydWN0b3IgZm9yIGEgQ29tcG9uZW50SGFybmVzcyBzdWJjbGFzcy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcG9uZW50SGFybmVzc0NvbnN0cnVjdG9yPFQgZXh0ZW5kcyBDb21wb25lbnRIYXJuZXNzPiB7XG4gIG5ldyhsb2NhdG9yRmFjdG9yeTogTG9jYXRvckZhY3RvcnkpOiBUO1xuXG4gIC8qKlxuICAgKiBgQ29tcG9uZW50SGFybmVzc2Agc3ViY2xhc3NlcyBtdXN0IHNwZWNpZnkgYSBzdGF0aWMgYGhvc3RTZWxlY3RvcmAgcHJvcGVydHkgdGhhdCBpcyB1c2VkIHRvXG4gICAqIGZpbmQgdGhlIGhvc3QgZWxlbWVudCBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgY29tcG9uZW50LiBUaGlzIHByb3BlcnR5IHNob3VsZCBtYXRjaCB0aGUgc2VsZWN0b3JcbiAgICogZm9yIHRoZSBBbmd1bGFyIGNvbXBvbmVudC5cbiAgICovXG4gIGhvc3RTZWxlY3Rvcjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhc2VIYXJuZXNzRmlsdGVycyB7XG4gIC8qKiBPbmx5IGZpbmQgY29tcG9uZW50IGluc3RhbmNlcyB3aG9zZSBob3N0IGVsZW1lbnQgbWF0Y2hlcyB0aGUgZ2l2ZW4gc2VsZWN0b3IuICovXG4gIHNlbGVjdG9yPzogc3RyaW5nO1xuICAvKiogT25seSBmaW5kIGNvbXBvbmVudCBpbnN0YW5jZXMgdGhhdCBhcmUgbmVzdGVkIHVuZGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgZ2l2ZW4gc2VsZWN0b3IuICovXG4gIGFuY2VzdG9yPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgY2xhc3MgdXNlZCB0byBhc3NvY2lhdGUgYSBDb21wb25lbnRIYXJuZXNzIGNsYXNzIHdpdGggcHJlZGljYXRlcyBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0b1xuICogZmlsdGVyIGluc3RhbmNlcyBvZiB0aGUgY2xhc3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBIYXJuZXNzUHJlZGljYXRlPFQgZXh0ZW5kcyBDb21wb25lbnRIYXJuZXNzPiB7XG4gIHByaXZhdGUgX3ByZWRpY2F0ZXM6IEFzeW5jUHJlZGljYXRlPFQ+W10gPSBbXTtcbiAgcHJpdmF0ZSBfZGVzY3JpcHRpb25zOiBzdHJpbmdbXSA9IFtdO1xuICBwcml2YXRlIF9hbmNlc3Rvcjogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBoYXJuZXNzVHlwZTogQ29tcG9uZW50SGFybmVzc0NvbnN0cnVjdG9yPFQ+LCBvcHRpb25zOiBCYXNlSGFybmVzc0ZpbHRlcnMpIHtcbiAgICB0aGlzLl9hZGRCYXNlT3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBzdHJpbmcgbWF0Y2hlcyB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAgICogQHBhcmFtIHMgVGhlIHN0cmluZyB0byBjaGVjaywgb3IgYSBQcm9taXNlIGZvciB0aGUgc3RyaW5nIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0gcGF0dGVybiBUaGUgcGF0dGVybiB0aGUgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIG1hdGNoLiBJZiBgcGF0dGVybmAgaXMgYSBzdHJpbmcsIGBzYCBpc1xuICAgKiAgIGV4cGVjdGVkIHRvIG1hdGNoIGV4YWN0bHkuIElmIGBwYXR0ZXJuYCBpcyBhIHJlZ2V4LCBhIHBhcnRpYWwgbWF0Y2ggaXMgYWxsb3dlZC5cbiAgICogQHJldHVybiBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB3aGV0aGVyIHRoZSBzdHJpbmcgbWF0Y2hlcyB0aGUgcGF0dGVybi5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBzdHJpbmdNYXRjaGVzKHM6IHN0cmluZyB8IFByb21pc2U8c3RyaW5nPiwgcGF0dGVybjogc3RyaW5nIHwgUmVnRXhwKTpcbiAgICAgIFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHMgPSBhd2FpdCBzO1xuICAgIHJldHVybiB0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycgPyBzID09PSBwYXR0ZXJuIDogcGF0dGVybi50ZXN0KHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gYmUgcnVuIGFnYWluc3QgY2FuZGlkYXRlIGhhcm5lc3Nlcy5cbiAgICogQHBhcmFtIGRlc2NyaXB0aW9uIEEgZGVzY3JpcHRpb24gb2YgdGhpcyBwcmVkaWNhdGUgdGhhdCBtYXkgYmUgdXNlZCBpbiBlcnJvciBtZXNzYWdlcy5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBBbiBhc3luYyBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4gdGhpcyAoZm9yIG1ldGhvZCBjaGFpbmluZykuXG4gICAqL1xuICBhZGQoZGVzY3JpcHRpb246IHN0cmluZywgcHJlZGljYXRlOiBBc3luY1ByZWRpY2F0ZTxUPikge1xuICAgIHRoaXMuX2Rlc2NyaXB0aW9ucy5wdXNoKGRlc2NyaXB0aW9uKTtcbiAgICB0aGlzLl9wcmVkaWNhdGVzLnB1c2gocHJlZGljYXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgZGVwZW5kcyBvbiBhbiBvcHRpb24gdmFsdWUgdG8gYmUgcnVuIGFnYWluc3QgY2FuZGlkYXRlXG4gICAqIGhhcm5lc3Nlcy4gSWYgdGhlIG9wdGlvbiB2YWx1ZSBpcyB1bmRlZmluZWQsIHRoZSBwcmVkaWNhdGUgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uIChtYXkgYmUgdXNlZCBpbiBlcnJvciBtZXNzYWdlcykuXG4gICAqIEBwYXJhbSBvcHRpb24gVGhlIG9wdGlvbiB2YWx1ZS5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIHJ1biBpZiB0aGUgb3B0aW9uIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQuXG4gICAqIEByZXR1cm4gdGhpcyAoZm9yIG1ldGhvZCBjaGFpbmluZykuXG4gICAqL1xuICBhZGRPcHRpb248Tz4obmFtZTogc3RyaW5nLCBvcHRpb246IE8gfCB1bmRlZmluZWQsIHByZWRpY2F0ZTogQXN5bmNPcHRpb25QcmVkaWNhdGU8VCwgTz4pIHtcbiAgICAvLyBBZGQgcXVvdGVzIGFyb3VuZCBzdHJpbmdzIHRvIGRpZmZlcmVudGlhdGUgdGhlbSBmcm9tIG90aGVyIHZhbHVlc1xuICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycgPyBgXCIke29wdGlvbn1cImAgOiBgJHtvcHRpb259YDtcbiAgICBpZiAob3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYWRkKGAke25hbWV9ID0gJHt2YWx1ZX1gLCBpdGVtID0+IHByZWRpY2F0ZShpdGVtLCBvcHRpb24pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRmlsdGVycyBhIGxpc3Qgb2YgaGFybmVzc2VzIG9uIHRoaXMgcHJlZGljYXRlLlxuICAgKiBAcGFyYW0gaGFybmVzc2VzIFRoZSBsaXN0IG9mIGhhcm5lc3NlcyB0byBmaWx0ZXIuXG4gICAqIEByZXR1cm4gQSBsaXN0IG9mIGhhcm5lc3NlcyB0aGF0IHNhdGlzZnkgdGhpcyBwcmVkaWNhdGUuXG4gICAqL1xuICBhc3luYyBmaWx0ZXIoaGFybmVzc2VzOiBUW10pOiBQcm9taXNlPFRbXT4ge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChoYXJuZXNzZXMubWFwKGggPT4gdGhpcy5ldmFsdWF0ZShoKSkpO1xuICAgIHJldHVybiBoYXJuZXNzZXMuZmlsdGVyKChfLCBpKSA9PiByZXN1bHRzW2ldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZXMgd2hldGhlciB0aGUgZ2l2ZW4gaGFybmVzcyBzYXRpc2ZpZXMgdGhpcyBwcmVkaWNhdGUuXG4gICAqIEBwYXJhbSBoYXJuZXNzIFRoZSBoYXJuZXNzIHRvIGNoZWNrXG4gICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgaGFybmVzcyBzYXRpc2ZpZXMgdGhpcyBwcmVkaWNhdGUsXG4gICAqICAgYW5kIHJlc29sdmVzIHRvIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGFzeW5jIGV2YWx1YXRlKGhhcm5lc3M6IFQpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5fcHJlZGljYXRlcy5tYXAocCA9PiBwKGhhcm5lc3MpKSk7XG4gICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChjb21iaW5lZCwgY3VycmVudCkgPT4gY29tYmluZWQgJiYgY3VycmVudCwgdHJ1ZSk7XG4gIH1cblxuICAvKiogR2V0cyBhIGRlc2NyaXB0aW9uIG9mIHRoaXMgcHJlZGljYXRlIGZvciB1c2UgaW4gZXJyb3IgbWVzc2FnZXMuICovXG4gIGdldERlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kZXNjcmlwdGlvbnMuam9pbignLCAnKTtcbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSBzZWxlY3RvciB1c2VkIHRvIGZpbmQgY2FuZGlkYXRlIGVsZW1lbnRzLiAqL1xuICBnZXRTZWxlY3RvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYW5jZXN0b3Iuc3BsaXQoJywnKVxuICAgICAgICAubWFwKHBhcnQgPT4gYCR7cGFydC50cmltKCl9ICR7dGhpcy5oYXJuZXNzVHlwZS5ob3N0U2VsZWN0b3J9YC50cmltKCkpXG4gICAgICAgIC5qb2luKCcsJyk7XG4gIH1cblxuICAvKiogQWRkcyBiYXNlIG9wdGlvbnMgY29tbW9uIHRvIGFsbCBoYXJuZXNzIHR5cGVzLiAqL1xuICBwcml2YXRlIF9hZGRCYXNlT3B0aW9ucyhvcHRpb25zOiBCYXNlSGFybmVzc0ZpbHRlcnMpIHtcbiAgICB0aGlzLl9hbmNlc3RvciA9IG9wdGlvbnMuYW5jZXN0b3IgfHwgJyc7XG4gICAgaWYgKHRoaXMuX2FuY2VzdG9yKSB7XG4gICAgICB0aGlzLl9kZXNjcmlwdGlvbnMucHVzaChgaGFzIGFuY2VzdG9yIG1hdGNoaW5nIHNlbGVjdG9yIFwiJHt0aGlzLl9hbmNlc3Rvcn1cImApO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RvciA9IG9wdGlvbnMuc2VsZWN0b3I7XG4gICAgaWYgKHNlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYWRkKGBob3N0IG1hdGNoZXMgc2VsZWN0b3IgXCIke3NlbGVjdG9yfVwiYCwgYXN5bmMgaXRlbSA9PiB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgaXRlbS5ob3N0KCkpLm1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==