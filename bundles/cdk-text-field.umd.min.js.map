{"version":3,"sources":["src/cdk/cdk-text-field.umd.js"],"names":["global","factory","exports","module","require","define","amd","globalThis","self","ng","cdk","textField","platform","core","coercion","rxjs","operators","common","this","i1","i0","_interopNamespace","e","__esModule","n","Object","create","keys","forEach","k","d","getOwnPropertyDescriptor","defineProperty","get","enumerable","freeze","i1__namespace","i0__namespace","listenerOptions","normalizePassiveListenerOptions","passive","AutofillMonitor","_platform","_ngZone","_monitoredElements","Map","prototype","monitor","elementOrRef","_this","isBrowser","EMPTY","element","coerceElement","info","subject","result","Subject","cssClass","listener","event","animationName","classList","contains","remove","run","next","target","isAutofilled","add","runOutsideAngular","addEventListener","set","unlisten","removeEventListener","stopMonitoring","complete","delete","ngOnDestroy","_info","ɵprov","ɵɵdefineInjectable","AutofillMonitor_Factory","ɵɵinject","Platform","NgZone","token","providedIn","decorators","type","Injectable","args","ctorParameters","CdkAutofill","_elementRef","_autofillMonitor","cdkAutofill","EventEmitter","ngOnInit","subscribe","emit","Directive","selector","ElementRef","propDecorators","Output","TextFieldModule","CdkTextareaAutosize","document","_destroyed","_enabled","_previousMinRows","_document","_textareaElement","nativeElement","_measuringClass","FIREFOX","_minRows","value","coerceNumberProperty","_setMinHeight","configurable","_maxRows","_setMaxHeight","coerceBooleanProperty","resizeToFitContent","reset","minHeight","minRows","_cachedLineHeight","style","maxHeight","maxRows","ngAfterViewInit","_initialHeight","height","window","_getWindow","fromEvent","pipe","auditTime","takeUntil","_cacheTextareaLineHeight","textareaClone","cloneNode","rows","position","visibility","border","padding","overflow","parentNode","appendChild","clientHeight","removeChild","ngDoCheck","force","textarea","_previousValue","placeholderText","placeholder","scrollHeight","requestAnimationFrame","_scrollToCaretPosition","setTimeout","undefined","_noopInputHandler","_getDocument","defaultView","selectionStart","selectionEnd","isStopped","activeElement","setSelectionRange","exportAs","host","class","Optional","Inject","DOCUMENT","Input","enabled","HostListener","NgModule","declarations","imports","PlatformModule"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/platform'), require('@angular/core'), require('@angular/cdk/coercion'), require('rxjs'), require('rxjs/operators'), require('@angular/common')) :\n    typeof define === 'function' && define.amd ? define('@angular/cdk/text-field', ['exports', '@angular/cdk/platform', '@angular/core', '@angular/cdk/coercion', 'rxjs', 'rxjs/operators', '@angular/common'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.ng = global.ng || {}, global.ng.cdk = global.ng.cdk || {}, global.ng.cdk.textField = {}), global.ng.cdk.platform, global.ng.core, global.ng.cdk.coercion, global.rxjs, global.rxjs.operators, global.ng.common));\n}(this, (function (exports, i1, i0, coercion, rxjs, operators, common) { 'use strict';\n\n    function _interopNamespace(e) {\n        if (e && e.__esModule) return e;\n        var n = Object.create(null);\n        if (e) {\n            Object.keys(e).forEach(function (k) {\n                if (k !== 'default') {\n                    var d = Object.getOwnPropertyDescriptor(e, k);\n                    Object.defineProperty(n, k, d.get ? d : {\n                        enumerable: true,\n                        get: function () {\n                            return e[k];\n                        }\n                    });\n                }\n            });\n        }\n        n['default'] = e;\n        return Object.freeze(n);\n    }\n\n    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);\n    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Options to pass to the animationstart listener. */\n    var listenerOptions = i1.normalizePassiveListenerOptions({ passive: true });\n    /**\n     * An injectable service that can be used to monitor the autofill state of an input.\n     * Based on the following blog post:\n     * https://medium.com/@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n     */\n    var AutofillMonitor = /** @class */ (function () {\n        function AutofillMonitor(_platform, _ngZone) {\n            this._platform = _platform;\n            this._ngZone = _ngZone;\n            this._monitoredElements = new Map();\n        }\n        AutofillMonitor.prototype.monitor = function (elementOrRef) {\n            var _this = this;\n            if (!this._platform.isBrowser) {\n                return rxjs.EMPTY;\n            }\n            var element = coercion.coerceElement(elementOrRef);\n            var info = this._monitoredElements.get(element);\n            if (info) {\n                return info.subject;\n            }\n            var result = new rxjs.Subject();\n            var cssClass = 'cdk-text-field-autofilled';\n            var listener = (function (event) {\n                // Animation events fire on initial element render, we check for the presence of the autofill\n                // CSS class to make sure this is a real change in state, not just the initial render before\n                // we fire off events.\n                if (event.animationName === 'cdk-text-field-autofill-start' &&\n                    !element.classList.contains(cssClass)) {\n                    element.classList.add(cssClass);\n                    _this._ngZone.run(function () { return result.next({ target: event.target, isAutofilled: true }); });\n                }\n                else if (event.animationName === 'cdk-text-field-autofill-end' &&\n                    element.classList.contains(cssClass)) {\n                    element.classList.remove(cssClass);\n                    _this._ngZone.run(function () { return result.next({ target: event.target, isAutofilled: false }); });\n                }\n            });\n            this._ngZone.runOutsideAngular(function () {\n                element.addEventListener('animationstart', listener, listenerOptions);\n                element.classList.add('cdk-text-field-autofill-monitored');\n            });\n            this._monitoredElements.set(element, {\n                subject: result,\n                unlisten: function () {\n                    element.removeEventListener('animationstart', listener, listenerOptions);\n                }\n            });\n            return result;\n        };\n        AutofillMonitor.prototype.stopMonitoring = function (elementOrRef) {\n            var element = coercion.coerceElement(elementOrRef);\n            var info = this._monitoredElements.get(element);\n            if (info) {\n                info.unlisten();\n                info.subject.complete();\n                element.classList.remove('cdk-text-field-autofill-monitored');\n                element.classList.remove('cdk-text-field-autofilled');\n                this._monitoredElements.delete(element);\n            }\n        };\n        AutofillMonitor.prototype.ngOnDestroy = function () {\n            var _this = this;\n            this._monitoredElements.forEach(function (_info, element) { return _this.stopMonitoring(element); });\n        };\n        return AutofillMonitor;\n    }());\n    AutofillMonitor.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function AutofillMonitor_Factory() { return new AutofillMonitor(i0__namespace.ɵɵinject(i1__namespace.Platform), i0__namespace.ɵɵinject(i0__namespace.NgZone)); }, token: AutofillMonitor, providedIn: \"root\" });\n    AutofillMonitor.decorators = [\n        { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n    ];\n    AutofillMonitor.ctorParameters = function () { return [\n        { type: i1.Platform },\n        { type: i0.NgZone }\n    ]; };\n    /** A directive that can be used to monitor the autofill state of an input. */\n    var CdkAutofill = /** @class */ (function () {\n        function CdkAutofill(_elementRef, _autofillMonitor) {\n            this._elementRef = _elementRef;\n            this._autofillMonitor = _autofillMonitor;\n            /** Emits when the autofill state of the element changes. */\n            this.cdkAutofill = new i0.EventEmitter();\n        }\n        CdkAutofill.prototype.ngOnInit = function () {\n            var _this = this;\n            this._autofillMonitor\n                .monitor(this._elementRef)\n                .subscribe(function (event) { return _this.cdkAutofill.emit(event); });\n        };\n        CdkAutofill.prototype.ngOnDestroy = function () {\n            this._autofillMonitor.stopMonitoring(this._elementRef);\n        };\n        return CdkAutofill;\n    }());\n    CdkAutofill.decorators = [\n        { type: i0.Directive, args: [{\n                    selector: '[cdkAutofill]',\n                },] }\n    ];\n    CdkAutofill.ctorParameters = function () { return [\n        { type: i0.ElementRef },\n        { type: AutofillMonitor }\n    ]; };\n    CdkAutofill.propDecorators = {\n        cdkAutofill: [{ type: i0.Output }]\n    };\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Directive to automatically resize a textarea to fit its content. */\n    var CdkTextareaAutosize = /** @class */ (function () {\n        function CdkTextareaAutosize(_elementRef, _platform, _ngZone, \n        /** @breaking-change 11.0.0 make document required */\n        document) {\n            this._elementRef = _elementRef;\n            this._platform = _platform;\n            this._ngZone = _ngZone;\n            this._destroyed = new rxjs.Subject();\n            this._enabled = true;\n            /**\n             * Value of minRows as of last resize. If the minRows has decreased, the\n             * height of the textarea needs to be recomputed to reflect the new minimum. The maxHeight\n             * does not have the same problem because it does not affect the textarea's scrollHeight.\n             */\n            this._previousMinRows = -1;\n            this._document = document;\n            this._textareaElement = this._elementRef.nativeElement;\n            this._measuringClass = _platform.FIREFOX ?\n                'cdk-textarea-autosize-measuring-firefox' :\n                'cdk-textarea-autosize-measuring';\n        }\n        Object.defineProperty(CdkTextareaAutosize.prototype, \"minRows\", {\n            /** Minimum amount of rows in the textarea. */\n            get: function () { return this._minRows; },\n            set: function (value) {\n                this._minRows = coercion.coerceNumberProperty(value);\n                this._setMinHeight();\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(CdkTextareaAutosize.prototype, \"maxRows\", {\n            /** Maximum amount of rows in the textarea. */\n            get: function () { return this._maxRows; },\n            set: function (value) {\n                this._maxRows = coercion.coerceNumberProperty(value);\n                this._setMaxHeight();\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(CdkTextareaAutosize.prototype, \"enabled\", {\n            /** Whether autosizing is enabled or not */\n            get: function () { return this._enabled; },\n            set: function (value) {\n                value = coercion.coerceBooleanProperty(value);\n                // Only act if the actual value changed. This specifically helps to not run\n                // resizeToFitContent too early (i.e. before ngAfterViewInit)\n                if (this._enabled !== value) {\n                    (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();\n                }\n            },\n            enumerable: false,\n            configurable: true\n        });\n        /** Sets the minimum height of the textarea as determined by minRows. */\n        CdkTextareaAutosize.prototype._setMinHeight = function () {\n            var minHeight = this.minRows && this._cachedLineHeight ?\n                this.minRows * this._cachedLineHeight + \"px\" : null;\n            if (minHeight) {\n                this._textareaElement.style.minHeight = minHeight;\n            }\n        };\n        /** Sets the maximum height of the textarea as determined by maxRows. */\n        CdkTextareaAutosize.prototype._setMaxHeight = function () {\n            var maxHeight = this.maxRows && this._cachedLineHeight ?\n                this.maxRows * this._cachedLineHeight + \"px\" : null;\n            if (maxHeight) {\n                this._textareaElement.style.maxHeight = maxHeight;\n            }\n        };\n        CdkTextareaAutosize.prototype.ngAfterViewInit = function () {\n            var _this = this;\n            if (this._platform.isBrowser) {\n                // Remember the height which we started with in case autosizing is disabled\n                this._initialHeight = this._textareaElement.style.height;\n                this.resizeToFitContent();\n                this._ngZone.runOutsideAngular(function () {\n                    var window = _this._getWindow();\n                    rxjs.fromEvent(window, 'resize')\n                        .pipe(operators.auditTime(16), operators.takeUntil(_this._destroyed))\n                        .subscribe(function () { return _this.resizeToFitContent(true); });\n                });\n            }\n        };\n        CdkTextareaAutosize.prototype.ngOnDestroy = function () {\n            this._destroyed.next();\n            this._destroyed.complete();\n        };\n        /**\n         * Cache the height of a single-row textarea if it has not already been cached.\n         *\n         * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n         * maxRows. For the initial version, we will assume that the height of a single line in the\n         * textarea does not ever change.\n         */\n        CdkTextareaAutosize.prototype._cacheTextareaLineHeight = function () {\n            if (this._cachedLineHeight) {\n                return;\n            }\n            // Use a clone element because we have to override some styles.\n            var textareaClone = this._textareaElement.cloneNode(false);\n            textareaClone.rows = 1;\n            // Use `position: absolute` so that this doesn't cause a browser layout and use\n            // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n            // would affect the height.\n            textareaClone.style.position = 'absolute';\n            textareaClone.style.visibility = 'hidden';\n            textareaClone.style.border = 'none';\n            textareaClone.style.padding = '0';\n            textareaClone.style.height = '';\n            textareaClone.style.minHeight = '';\n            textareaClone.style.maxHeight = '';\n            // In Firefox it happens that textarea elements are always bigger than the specified amount\n            // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n            // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n            // to hidden. This ensures that there is no invalid calculation of the line height.\n            // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n            textareaClone.style.overflow = 'hidden';\n            this._textareaElement.parentNode.appendChild(textareaClone);\n            this._cachedLineHeight = textareaClone.clientHeight;\n            this._textareaElement.parentNode.removeChild(textareaClone);\n            // Min and max heights have to be re-calculated if the cached line height changes\n            this._setMinHeight();\n            this._setMaxHeight();\n        };\n        CdkTextareaAutosize.prototype.ngDoCheck = function () {\n            if (this._platform.isBrowser) {\n                this.resizeToFitContent();\n            }\n        };\n        /**\n         * Resize the textarea to fit its content.\n         * @param force Whether to force a height recalculation. By default the height will be\n         *    recalculated only if the value changed since the last call.\n         */\n        CdkTextareaAutosize.prototype.resizeToFitContent = function (force) {\n            var _this = this;\n            if (force === void 0) { force = false; }\n            // If autosizing is disabled, just skip everything else\n            if (!this._enabled) {\n                return;\n            }\n            this._cacheTextareaLineHeight();\n            // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n            // in checking the height of the textarea.\n            if (!this._cachedLineHeight) {\n                return;\n            }\n            var textarea = this._elementRef.nativeElement;\n            var value = textarea.value;\n            // Only resize if the value or minRows have changed since these calculations can be expensive.\n            if (!force && this._minRows === this._previousMinRows && value === this._previousValue) {\n                return;\n            }\n            var placeholderText = textarea.placeholder;\n            // Reset the textarea height to auto in order to shrink back to its default size.\n            // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n            // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight\n            // value. To ensure that the scrollHeight is not bigger than the content, the placeholders\n            // need to be removed temporarily.\n            textarea.classList.add(this._measuringClass);\n            textarea.placeholder = '';\n            // The measuring class includes a 2px padding to workaround an issue with Chrome,\n            // so we account for that extra space here by subtracting 4 (2px top + 2px bottom).\n            var height = textarea.scrollHeight - 4;\n            // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n            textarea.style.height = height + \"px\";\n            textarea.classList.remove(this._measuringClass);\n            textarea.placeholder = placeholderText;\n            this._ngZone.runOutsideAngular(function () {\n                if (typeof requestAnimationFrame !== 'undefined') {\n                    requestAnimationFrame(function () { return _this._scrollToCaretPosition(textarea); });\n                }\n                else {\n                    setTimeout(function () { return _this._scrollToCaretPosition(textarea); });\n                }\n            });\n            this._previousValue = value;\n            this._previousMinRows = this._minRows;\n        };\n        /**\n         * Resets the textarea to its original size\n         */\n        CdkTextareaAutosize.prototype.reset = function () {\n            // Do not try to change the textarea, if the initialHeight has not been determined yet\n            // This might potentially remove styles when reset() is called before ngAfterViewInit\n            if (this._initialHeight !== undefined) {\n                this._textareaElement.style.height = this._initialHeight;\n            }\n        };\n        // In Ivy the `host` metadata will be merged, whereas in ViewEngine it is overridden. In order\n        // to avoid double event listeners, we need to use `HostListener`. Once Ivy is the default, we\n        // can move this back into `host`.\n        // tslint:disable:no-host-decorator-in-concrete\n        CdkTextareaAutosize.prototype._noopInputHandler = function () {\n            // no-op handler that ensures we're running change detection on input events.\n        };\n        /** Access injected document if available or fallback to global document reference */\n        CdkTextareaAutosize.prototype._getDocument = function () {\n            return this._document || document;\n        };\n        /** Use defaultView of injected document if available or fallback to global window reference */\n        CdkTextareaAutosize.prototype._getWindow = function () {\n            var doc = this._getDocument();\n            return doc.defaultView || window;\n        };\n        /**\n         * Scrolls a textarea to the caret position. On Firefox resizing the textarea will\n         * prevent it from scrolling to the caret position. We need to re-set the selection\n         * in order for it to scroll to the proper position.\n         */\n        CdkTextareaAutosize.prototype._scrollToCaretPosition = function (textarea) {\n            var selectionStart = textarea.selectionStart, selectionEnd = textarea.selectionEnd;\n            var document = this._getDocument();\n            // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n            // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n            // between the time we requested the animation frame and when it was executed.\n            // Also note that we have to assert that the textarea is focused before we set the\n            // selection range. Setting the selection range on a non-focused textarea will cause\n            // it to receive focus on IE and Edge.\n            if (!this._destroyed.isStopped && document.activeElement === textarea) {\n                textarea.setSelectionRange(selectionStart, selectionEnd);\n            }\n        };\n        return CdkTextareaAutosize;\n    }());\n    CdkTextareaAutosize.decorators = [\n        { type: i0.Directive, args: [{\n                    selector: 'textarea[cdkTextareaAutosize]',\n                    exportAs: 'cdkTextareaAutosize',\n                    host: {\n                        'class': 'cdk-textarea-autosize',\n                        // Textarea elements that have the directive applied should have a single row by default.\n                        // Browsers normally show two rows by default and therefore this limits the minRows binding.\n                        'rows': '1',\n                    },\n                },] }\n    ];\n    CdkTextareaAutosize.ctorParameters = function () { return [\n        { type: i0.ElementRef },\n        { type: i1.Platform },\n        { type: i0.NgZone },\n        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [common.DOCUMENT,] }] }\n    ]; };\n    CdkTextareaAutosize.propDecorators = {\n        minRows: [{ type: i0.Input, args: ['cdkAutosizeMinRows',] }],\n        maxRows: [{ type: i0.Input, args: ['cdkAutosizeMaxRows',] }],\n        enabled: [{ type: i0.Input, args: ['cdkTextareaAutosize',] }],\n        _noopInputHandler: [{ type: i0.HostListener, args: ['input',] }]\n    };\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var TextFieldModule = /** @class */ (function () {\n        function TextFieldModule() {\n        }\n        return TextFieldModule;\n    }());\n    TextFieldModule.decorators = [\n        { type: i0.NgModule, args: [{\n                    declarations: [CdkAutofill, CdkTextareaAutosize],\n                    imports: [i1.PlatformModule],\n                    exports: [CdkAutofill, CdkTextareaAutosize],\n                },] }\n    ];\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.AutofillMonitor = AutofillMonitor;\n    exports.CdkAutofill = CdkAutofill;\n    exports.CdkTextareaAutosize = CdkTextareaAutosize;\n    exports.TextFieldModule = TextFieldModule;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=cdk-text-field.umd.js.map\n"]}