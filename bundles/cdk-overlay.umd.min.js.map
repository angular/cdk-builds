{"version":3,"sources":["src/cdk/cdk-overlay.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","cdk","overlay","tslib","scrolling","common","core","coercion","platform","rxjs","operators","bidi","portal","keycodes","this","i1","i0","BlockScrollStrategy","_viewportRuler","document","_previousHTMLStyles","top","left","_isEnabled","_document","prototype","attach","enable","_canBeEnabled","root","documentElement","_previousScrollPosition","getViewportScrollPosition","style","coerceCssPixelValue","classList","add","disable","html","htmlStyle","bodyStyle","body","previousHtmlScrollBehavior","scrollBehavior","previousBodyScrollBehavior","remove","window","scroll","contains","viewport","getViewportSize","scrollHeight","height","scrollWidth","width","getMatScrollStrategyAlreadyAttachedError","Error","CloseScrollStrategy","_scrollDispatcher","_ngZone","_config","_this","_scrollSubscription","_detach","_overlayRef","hasAttached","run","detach","overlayRef","stream","scrolled","threshold","_initialScrollPosition","subscribe","scrollPosition","Math","abs","updatePosition","unsubscribe","NoopScrollStrategy","isElementScrolledOutsideView","element","scrollContainers","some","containerBounds","bottom","right","isElementClippedByScrolling","scrollContainerRect","hasV8BreakIterator","RepositionScrollStrategy","scrollThrottle","autoClose","overlayRect","overlayElement","getBoundingClientRect","_a","Intl","v8BreakIterator","Platform","_platformId","isBrowser","isPlatformBrowser","EDGE","test","navigator","userAgent","TRIDENT","BLINK","chrome","CSS","WEBKIT","IOS","FIREFOX","ANDROID","SAFARI","decorators","type","Injectable","args","providedIn","ctorParameters","Object","Optional","Inject","PLATFORM_ID","ɵprov","ɵɵdefineInjectable","Platform_Factory","ɵɵinject","token","ScrollDispatcher","_platform","_scrolled","Subject","_globalSubscription","_scrolledCount","Map","register","scrollable","has","set","elementScrolled","next","deregister","scrollableReference","get","delete","auditTimeInMs","Observable","observer","_addGlobalListener","subscription","pipe","auditTime","_removeGlobalListener","of","ngOnDestroy","forEach","_","container","complete","ancestorScrolled","elementRef","ancestors","getAncestorScrollContainers","filter","target","indexOf","scrollingContainers","_subscription","_scrollableContainsElement","push","nativeElement","scrollableElement","getElementRef","parentElement","runOutsideAngular","fromEvent","NgZone","ScrollDispatcher_Factory","ViewportRuler","ngZone","_change","merge","_invalidateCache","change","_updateViewportSize","_viewportSize","output","getViewportRect","documentRect","scrollTop","scrollY","scrollLeft","scrollX","throttleTime","innerWidth","innerHeight","ViewportRuler_Factory","ScrollStrategyOptions","noop","close","config","block","reposition","undefined","DOCUMENT","ScrollStrategyOptions_Factory","OverlayConfig","e_1","scrollStrategy","panelClass","hasBackdrop","backdropClass","disposeOnNavigation","configKeys","keys","configKeys_1","__values","configKeys_1_1","done","key","value","e_1_1","error","return","call","ConnectionPositionPair","origin","offsetX","offsetY","originX","originY","overlayX","overlayY","ScrollingVisibility","ConnectedOverlayPositionChange","connectionPair","scrollableViewProperties","validateVerticalPosition","property","validateHorizontalPosition","OverlayKeyboardDispatcher","_attachedOverlays","_keydownListener","event","overlays","i","length","_keydownEventSubscriptions","_keydownEvents","_isAttached","addEventListener","index","splice","removeEventListener","OverlayKeyboardDispatcher_Factory","OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY","dispatcher","OVERLAY_KEYBOARD_DISPATCHER_PROVIDER","provide","deps","SkipSelf","useFactory","OverlayContainer","_containerElement","parentNode","removeChild","getContainerElement","_createContainer","previousContainers","getElementsByClassName","createElement","appendChild","OverlayContainer_Factory","OVERLAY_CONTAINER_PROVIDER_FACTORY","parentContainer","OVERLAY_CONTAINER_PROVIDER","OverlayRef","_portalOutlet","_host","_pane","_keyboardDispatcher","_location","_backdropElement","_backdropClick","_attachments","_detachments","_locationChanges","Subscription","EMPTY","_backdropClickHandler","_keydownEventsObservable","_scrollStrategy","_positionStrategy","positionStrategy","defineProperty","enumerable","configurable","attachResult","_previousHostParent","_updateStackingOrder","_updateElementSize","_updateElementDirection","onStable","asObservable","take","_togglePointerEvents","_attachBackdrop","_toggleClasses","dispose","detachBackdrop","detachmentResult","_detachContentWhenStable","isAttached","_disposeScrollStrategy","backdropClick","attachments","detachments","keydownEvents","getConfig","apply","updatePositionStrategy","strategy","updateSize","sizeConfig","__assign","setDirection","dir","direction","addPanelClass","classes","removePanelClass","getDirection","updateScrollStrategy","setAttribute","minWidth","minHeight","maxWidth","maxHeight","enablePointer","pointerEvents","insertBefore","requestAnimationFrame","nextSibling","backdropToDetach","timeoutId","finishDetach","clearTimeout","setTimeout","cssClasses","isAdd","coerceArray","cssClass","takeUntil","children","FlexibleConnectedPositionStrategy","connectedTo","_overlayContainer","_lastBoundingBoxSize","_isPushed","_canPush","_growAfterOpen","_hasFlexibleDimensions","_positionLocked","_viewportMargin","_scrollables","_preferredPositions","_positionChanges","_resizeSubscription","_offsetX","_offsetY","_appliedPanelClasses","positionChanges","setOrigin","_validatePositions","hostElement","_boundingBox","_isDisposed","_isInitialRender","_lastPosition","e_2","_b","reapplyLastPosition","_clearPanelClasses","_resetOverlayElementStyles","_resetBoundingBoxStyles","_viewportRect","_getNarrowedViewportRect","_originRect","_getOriginRect","_overlayRect","fallback","originRect","viewportRect","flexibleFits","_c","_d","pos","originPoint","_getOriginPoint","overlayPoint","_getOverlayPoint","overlayFit","_getOverlayFit","isCompletelyWithinViewport","_applyPosition","_canFitWithFlexibleDimensions","position","boundingBoxRect","_calculateBoundingBoxRect","visibleArea","bestFit","bestScore","flexibleFits_1","flexibleFits_1_1","fit","score","weight","e_2_1","_previousPushAmount","extendStyles","alignItems","justifyContent","lastPosition","withScrollableContainers","scrollables","withPositions","positions","withViewportMargin","margin","withFlexibleDimensions","flexibleDimensions","withGrowAfterOpen","growAfterOpen","withPush","canPush","withLockedPosition","isLocked","_origin","withDefaultOffsetX","offset","withDefaultOffsetY","withTransformOriginOn","selector","_transformOriginSelector","x","startX","_isRtl","endX","y","overlayStartX","point","_getOffset","topOverflow","bottomOverflow","visibleWidth","_subtractOverflows","visibleHeight","fitsInViewportVertically","fitsInViewportHorizontally","availableHeight","availableWidth","_pushOverlayOnScreen","start","pushX","pushY","overflowRight","max","overflowBottom","overflowTop","overflowLeft","_setTransformOrigin","_setOverlayElementStyles","_setBoundingBoxStyles","_addPanelClasses","observers","_getScrollVisibility","changeEvent","xOrigin","elements","querySelectorAll","yOrigin","transformOrigin","isRtl","smallestDistanceToViewportEdge","min","previousHeight","previousWidth","styles","_hasExactPosition","transform","hasExactPosition","hasFlexibleDimensions","_getExactOverlayY","_getExactOverlayX","transformString","trim","virtualKeyboardOffset","clientHeight","clientWidth","originBounds","overlayBounds","scrollContainerBounds","map","isOriginClipped","isOriginOutsideView","isOverlayClipped","isOverlayOutsideView","overflows","_i","arguments","reduce","currentValue","currentOverflow","axis","pair","ElementRef","HTMLElement","dest","source","hasOwnProperty","ConnectedPositionStrategy","originPos","overlayPos","viewportRuler","overlayContainer","withFallbackPosition","_direction","recalculateLastPosition","withDirection","withOffsetX","withOffsetY","slice","GlobalPositionStrategy","_cssPosition","_topOffset","_bottomOffset","_leftOffset","_rightOffset","_alignItems","_justifyContent","_width","_height","centerHorizontally","centerVertically","parentStyles","marginLeft","marginTop","marginBottom","marginRight","parent","OverlayPositionBuilder","flexibleConnectedTo","OverlayPositionBuilder_Factory","nextUniqueId","Overlay","scrollStrategies","_componentFactoryResolver","_positionBuilder","_injector","_directionality","create","host","_createHostElement","pane","_createPaneElement","portalOutlet","_createPortalOutlet","overlayConfig","id","_appRef","ApplicationRef","DomPortalOutlet","ComponentFactoryResolver","Injector","Directionality","Location","defaultPositionList","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY","InjectionToken","CdkOverlayOrigin","Directive","exportAs","CdkConnectedOverlay","_overlay","templateRef","viewContainerRef","scrollStrategyFactory","_dir","_hasBackdrop","_lockPosition","_flexibleDimensions","_push","_backdropSubscription","viewportMargin","open","EventEmitter","positionChange","overlayKeydown","_templatePortal","TemplatePortal","_scrollStrategyFactory","_position","_updatePositionStrategy","coerceBooleanProperty","ngOnChanges","changes","_attachOverlay","_detachOverlay","_createOverlay","_buildConfig","keyCode","ESCAPE","hasModifierKey","preventDefault","_createPositionStrategy","currentPosition","lockPosition","p","emit","TemplateRef","ViewContainerRef","propDecorators","Input","Output","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER","OverlayModule","NgModule","imports","BidiModule","PortalModule","ScrollingModule","declarations","providers","OVERLAY_PROVIDERS","FullscreenOverlayContainer","_super","__extends","_fullScreenEventName","_fullScreenListener","_adjustParentForFullscreenChange","_addFullscreenChangeListener","getFullscreenElement","fn","eventName","_getEventName","fullscreenEnabled","webkitFullscreenEnabled","mozFullScreenEnabled","msFullscreenEnabled","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","FullscreenOverlayContainer_Factory","CdkScrollable","ɵangular_material_src_cdk_overlay_overlay_a","ɵangular_material_src_cdk_overlay_overlay_b","ɵangular_material_src_cdk_overlay_overlay_c","ɵangular_material_src_cdk_overlay_overlay_d","ɵangular_material_src_cdk_overlay_overlay_e","ɵangular_material_src_cdk_overlay_overlay_f","ɵangular_material_src_cdk_overlay_overlay_g"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@angular/cdk/scrolling'), require('@angular/common'), require('@angular/core'), require('@angular/cdk/coercion'), require('@angular/cdk/platform'), require('rxjs'), require('rxjs/operators'), require('@angular/cdk/bidi'), require('@angular/cdk/portal'), require('@angular/cdk/keycodes')) :\n    typeof define === 'function' && define.amd ? define('@angular/cdk/overlay', ['exports', 'tslib', '@angular/cdk/scrolling', '@angular/common', '@angular/core', '@angular/cdk/coercion', '@angular/cdk/platform', 'rxjs', 'rxjs/operators', '@angular/cdk/bidi', '@angular/cdk/portal', '@angular/cdk/keycodes'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.cdk = global.ng.cdk || {}, global.ng.cdk.overlay = {}), global.tslib, global.ng.cdk.scrolling, global.ng.common, global.ng.core, global.ng.cdk.coercion, global.ng.cdk.platform, global.rxjs, global.rxjs.operators, global.ng.cdk.bidi, global.ng.cdk.portal, global.ng.cdk.keycodes));\n}(this, (function (exports, tslib, scrolling, i1, i0, coercion, platform, rxjs, operators, bidi, portal, keycodes) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Strategy that will prevent the user from scrolling while the overlay is visible.\n     */\n    var BlockScrollStrategy = /** @class */ (function () {\n        function BlockScrollStrategy(_viewportRuler, document) {\n            this._viewportRuler = _viewportRuler;\n            this._previousHTMLStyles = { top: '', left: '' };\n            this._isEnabled = false;\n            this._document = document;\n        }\n        /** Attaches this scroll strategy to an overlay. */\n        BlockScrollStrategy.prototype.attach = function () { };\n        /** Blocks page-level scroll while the attached overlay is open. */\n        BlockScrollStrategy.prototype.enable = function () {\n            if (this._canBeEnabled()) {\n                var root = this._document.documentElement;\n                this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n                // Cache the previous inline styles in case the user had set them.\n                this._previousHTMLStyles.left = root.style.left || '';\n                this._previousHTMLStyles.top = root.style.top || '';\n                // Note: we're using the `html` node, instead of the `body`, because the `body` may\n                // have the user agent margin, whereas the `html` is guaranteed not to have one.\n                root.style.left = coercion.coerceCssPixelValue(-this._previousScrollPosition.left);\n                root.style.top = coercion.coerceCssPixelValue(-this._previousScrollPosition.top);\n                root.classList.add('cdk-global-scrollblock');\n                this._isEnabled = true;\n            }\n        };\n        /** Unblocks page-level scroll while the attached overlay is open. */\n        BlockScrollStrategy.prototype.disable = function () {\n            if (this._isEnabled) {\n                var html = this._document.documentElement;\n                var body = this._document.body;\n                var htmlStyle = html.style;\n                var bodyStyle = body.style;\n                var previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';\n                var previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';\n                this._isEnabled = false;\n                htmlStyle.left = this._previousHTMLStyles.left;\n                htmlStyle.top = this._previousHTMLStyles.top;\n                html.classList.remove('cdk-global-scrollblock');\n                // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n                // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n                htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';\n                window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n                htmlStyle.scrollBehavior = previousHtmlScrollBehavior;\n                bodyStyle.scrollBehavior = previousBodyScrollBehavior;\n            }\n        };\n        BlockScrollStrategy.prototype._canBeEnabled = function () {\n            // Since the scroll strategies can't be singletons, we have to use a global CSS class\n            // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n            // scrolling multiple times.\n            var html = this._document.documentElement;\n            if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n                return false;\n            }\n            var body = this._document.body;\n            var viewport = this._viewportRuler.getViewportSize();\n            return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n        };\n        return BlockScrollStrategy;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n     */\n    function getMatScrollStrategyAlreadyAttachedError() {\n        return Error(\"Scroll strategy has already been attached.\");\n    }\n\n    /**\n     * Strategy that will close the overlay as soon as the user starts scrolling.\n     */\n    var CloseScrollStrategy = /** @class */ (function () {\n        function CloseScrollStrategy(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n            var _this = this;\n            this._scrollDispatcher = _scrollDispatcher;\n            this._ngZone = _ngZone;\n            this._viewportRuler = _viewportRuler;\n            this._config = _config;\n            this._scrollSubscription = null;\n            /** Detaches the overlay ref and disables the scroll strategy. */\n            this._detach = function () {\n                _this.disable();\n                if (_this._overlayRef.hasAttached()) {\n                    _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n                }\n            };\n        }\n        /** Attaches this scroll strategy to an overlay. */\n        CloseScrollStrategy.prototype.attach = function (overlayRef) {\n            if (this._overlayRef) {\n                throw getMatScrollStrategyAlreadyAttachedError();\n            }\n            this._overlayRef = overlayRef;\n        };\n        /** Enables the closing of the attached overlay on scroll. */\n        CloseScrollStrategy.prototype.enable = function () {\n            var _this = this;\n            if (this._scrollSubscription) {\n                return;\n            }\n            var stream = this._scrollDispatcher.scrolled(0);\n            if (this._config && this._config.threshold && this._config.threshold > 1) {\n                this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n                this._scrollSubscription = stream.subscribe(function () {\n                    var scrollPosition = _this._viewportRuler.getViewportScrollPosition().top;\n                    if (Math.abs(scrollPosition - _this._initialScrollPosition) > _this._config.threshold) {\n                        _this._detach();\n                    }\n                    else {\n                        _this._overlayRef.updatePosition();\n                    }\n                });\n            }\n            else {\n                this._scrollSubscription = stream.subscribe(this._detach);\n            }\n        };\n        /** Disables the closing the attached overlay on scroll. */\n        CloseScrollStrategy.prototype.disable = function () {\n            if (this._scrollSubscription) {\n                this._scrollSubscription.unsubscribe();\n                this._scrollSubscription = null;\n            }\n        };\n        CloseScrollStrategy.prototype.detach = function () {\n            this.disable();\n            this._overlayRef = null;\n        };\n        return CloseScrollStrategy;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Scroll strategy that doesn't do anything. */\n    var NoopScrollStrategy = /** @class */ (function () {\n        function NoopScrollStrategy() {\n        }\n        /** Does nothing, as this scroll strategy is a no-op. */\n        NoopScrollStrategy.prototype.enable = function () { };\n        /** Does nothing, as this scroll strategy is a no-op. */\n        NoopScrollStrategy.prototype.disable = function () { };\n        /** Does nothing, as this scroll strategy is a no-op. */\n        NoopScrollStrategy.prototype.attach = function () { };\n        return NoopScrollStrategy;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // TODO(jelbourn): move this to live with the rest of the scrolling code\n    // TODO(jelbourn): someday replace this with IntersectionObservers\n    /**\n     * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n     * @param element Dimensions of the element (from getBoundingClientRect)\n     * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n     * @returns Whether the element is scrolled out of view\n     * @docs-private\n     */\n    function isElementScrolledOutsideView(element, scrollContainers) {\n        return scrollContainers.some(function (containerBounds) {\n            var outsideAbove = element.bottom < containerBounds.top;\n            var outsideBelow = element.top > containerBounds.bottom;\n            var outsideLeft = element.right < containerBounds.left;\n            var outsideRight = element.left > containerBounds.right;\n            return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n        });\n    }\n    /**\n     * Gets whether an element is clipped by any of its scrolling containers.\n     * @param element Dimensions of the element (from getBoundingClientRect)\n     * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n     * @returns Whether the element is clipped\n     * @docs-private\n     */\n    function isElementClippedByScrolling(element, scrollContainers) {\n        return scrollContainers.some(function (scrollContainerRect) {\n            var clippedAbove = element.top < scrollContainerRect.top;\n            var clippedBelow = element.bottom > scrollContainerRect.bottom;\n            var clippedLeft = element.left < scrollContainerRect.left;\n            var clippedRight = element.right > scrollContainerRect.right;\n            return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n        });\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Strategy that will update the element position as the user is scrolling.\n     */\n    var RepositionScrollStrategy = /** @class */ (function () {\n        function RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n            this._scrollDispatcher = _scrollDispatcher;\n            this._viewportRuler = _viewportRuler;\n            this._ngZone = _ngZone;\n            this._config = _config;\n            this._scrollSubscription = null;\n        }\n        /** Attaches this scroll strategy to an overlay. */\n        RepositionScrollStrategy.prototype.attach = function (overlayRef) {\n            if (this._overlayRef) {\n                throw getMatScrollStrategyAlreadyAttachedError();\n            }\n            this._overlayRef = overlayRef;\n        };\n        /** Enables repositioning of the attached overlay on scroll. */\n        RepositionScrollStrategy.prototype.enable = function () {\n            var _this = this;\n            if (!this._scrollSubscription) {\n                var throttle = this._config ? this._config.scrollThrottle : 0;\n                this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(function () {\n                    _this._overlayRef.updatePosition();\n                    // TODO(crisbeto): make `close` on by default once all components can handle it.\n                    if (_this._config && _this._config.autoClose) {\n                        var overlayRect = _this._overlayRef.overlayElement.getBoundingClientRect();\n                        var _a = _this._viewportRuler.getViewportSize(), width = _a.width, height = _a.height;\n                        // TODO(crisbeto): include all ancestor scroll containers here once\n                        // we have a way of exposing the trigger element to the scroll strategy.\n                        var parentRects = [{ width: width, height: height, bottom: height, right: width, top: 0, left: 0 }];\n                        if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                            _this.disable();\n                            _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n                        }\n                    }\n                });\n            }\n        };\n        /** Disables repositioning of the attached overlay on scroll. */\n        RepositionScrollStrategy.prototype.disable = function () {\n            if (this._scrollSubscription) {\n                this._scrollSubscription.unsubscribe();\n                this._scrollSubscription = null;\n            }\n        };\n        RepositionScrollStrategy.prototype.detach = function () {\n            this.disable();\n            this._overlayRef = null;\n        };\n        return RepositionScrollStrategy;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Whether the current platform supports the V8 Break Iterator. The V8 check\n    // is necessary to detect all Blink based browsers.\n    var hasV8BreakIterator;\n    // We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n    // cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n    // the consumer is providing a polyfilled `Map`. See:\n    // https://github.com/Microsoft/ChakraCore/issues/3189\n    // https://github.com/angular/components/issues/15687\n    try {\n        hasV8BreakIterator = (typeof Intl !== 'undefined' && Intl.v8BreakIterator);\n    }\n    catch (_a) {\n        hasV8BreakIterator = false;\n    }\n    /**\n     * Service to detect the current platform by comparing the userAgent strings and\n     * checking browser-specific global properties.\n     */\n    var Platform = /** @class */ (function () {\n        /**\n         * @breaking-change 8.0.0 remove optional decorator\n         */\n        function Platform(_platformId) {\n            this._platformId = _platformId;\n            // We want to use the Angular platform check because if the Document is shimmed\n            // without the navigator, the following checks will fail. This is preferred because\n            // sometimes the Document may be shimmed without the user's knowledge or intention\n            /** Whether the Angular application is being rendered in the browser. */\n            this.isBrowser = this._platformId ?\n                i1.isPlatformBrowser(this._platformId) : typeof document === 'object' && !!document;\n            /** Whether the current browser is Microsoft Edge. */\n            this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n            /** Whether the current rendering engine is Microsoft Trident. */\n            this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n            // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n            /** Whether the current rendering engine is Blink. */\n            this.BLINK = this.isBrowser && (!!(window.chrome || hasV8BreakIterator) &&\n                typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT);\n            // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n            // ensure that Webkit runs standalone and is not used as another engine's base.\n            /** Whether the current rendering engine is WebKit. */\n            this.WEBKIT = this.isBrowser &&\n                /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n            /** Whether the current platform is Apple iOS. */\n            this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n                !('MSStream' in window);\n            // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n            // them self as Gecko-like browsers and modify the userAgent's according to that.\n            // Since we only cover one explicit Firefox case, we can simply check for Firefox\n            // instead of having an unstable check for Gecko.\n            /** Whether the current browser is Firefox. */\n            this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n            /** Whether the current platform is Android. */\n            // Trident on mobile adds the android platform to the userAgent to trick detections.\n            this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n            // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n            // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n            // Safari browser should also use Webkit as its layout engine.\n            /** Whether the current browser is Safari. */\n            this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n        }\n        Platform.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        Platform.ctorParameters = function () { return [\n            { type: Object, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [i0.PLATFORM_ID,] }] }\n        ]; };\n        Platform.ɵprov = i0.ɵɵdefineInjectable({ factory: function Platform_Factory() { return new Platform(i0.ɵɵinject(i0.PLATFORM_ID, 8)); }, token: Platform, providedIn: \"root\" });\n        return Platform;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Time in ms to throttle the scrolling events by default. */\n    var DEFAULT_SCROLL_TIME = 20;\n    /**\n     * Service contained all registered Scrollable references and emits an event when any one of the\n     * Scrollable references emit a scrolled event.\n     */\n    var ScrollDispatcher = /** @class */ (function () {\n        function ScrollDispatcher(_ngZone, _platform) {\n            this._ngZone = _ngZone;\n            this._platform = _platform;\n            /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n            this._scrolled = new rxjs.Subject();\n            /** Keeps track of the global `scroll` and `resize` subscriptions. */\n            this._globalSubscription = null;\n            /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\n            this._scrolledCount = 0;\n            /**\n             * Map of all the scrollable references that are registered with the service and their\n             * scroll event subscriptions.\n             */\n            this.scrollContainers = new Map();\n        }\n        /**\n         * Registers a scrollable instance with the service and listens for its scrolled events. When the\n         * scrollable is scrolled, the service emits the event to its scrolled observable.\n         * @param scrollable Scrollable instance to be registered.\n         */\n        ScrollDispatcher.prototype.register = function (scrollable) {\n            var _this = this;\n            if (!this.scrollContainers.has(scrollable)) {\n                this.scrollContainers.set(scrollable, scrollable.elementScrolled()\n                    .subscribe(function () { return _this._scrolled.next(scrollable); }));\n            }\n        };\n        /**\n         * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n         * @param scrollable Scrollable instance to be deregistered.\n         */\n        ScrollDispatcher.prototype.deregister = function (scrollable) {\n            var scrollableReference = this.scrollContainers.get(scrollable);\n            if (scrollableReference) {\n                scrollableReference.unsubscribe();\n                this.scrollContainers.delete(scrollable);\n            }\n        };\n        /**\n         * Returns an observable that emits an event whenever any of the registered Scrollable\n         * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n         * to override the default \"throttle\" time.\n         *\n         * **Note:** in order to avoid hitting change detection for every scroll event,\n         * all of the events emitted from this stream will be run outside the Angular zone.\n         * If you need to update any data bindings as a result of a scroll event, you have\n         * to run the callback using `NgZone.run`.\n         */\n        ScrollDispatcher.prototype.scrolled = function (auditTimeInMs) {\n            var _this = this;\n            if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\n            if (!this._platform.isBrowser) {\n                return rxjs.of();\n            }\n            return new rxjs.Observable(function (observer) {\n                if (!_this._globalSubscription) {\n                    _this._addGlobalListener();\n                }\n                // In the case of a 0ms delay, use an observable without auditTime\n                // since it does add a perceptible delay in processing overhead.\n                var subscription = auditTimeInMs > 0 ?\n                    _this._scrolled.pipe(operators.auditTime(auditTimeInMs)).subscribe(observer) :\n                    _this._scrolled.subscribe(observer);\n                _this._scrolledCount++;\n                return function () {\n                    subscription.unsubscribe();\n                    _this._scrolledCount--;\n                    if (!_this._scrolledCount) {\n                        _this._removeGlobalListener();\n                    }\n                };\n            });\n        };\n        ScrollDispatcher.prototype.ngOnDestroy = function () {\n            var _this = this;\n            this._removeGlobalListener();\n            this.scrollContainers.forEach(function (_, container) { return _this.deregister(container); });\n            this._scrolled.complete();\n        };\n        /**\n         * Returns an observable that emits whenever any of the\n         * scrollable ancestors of an element are scrolled.\n         * @param elementRef Element whose ancestors to listen for.\n         * @param auditTimeInMs Time to throttle the scroll events.\n         */\n        ScrollDispatcher.prototype.ancestorScrolled = function (elementRef, auditTimeInMs) {\n            var ancestors = this.getAncestorScrollContainers(elementRef);\n            return this.scrolled(auditTimeInMs).pipe(operators.filter(function (target) {\n                return !target || ancestors.indexOf(target) > -1;\n            }));\n        };\n        /** Returns all registered Scrollables that contain the provided element. */\n        ScrollDispatcher.prototype.getAncestorScrollContainers = function (elementRef) {\n            var _this = this;\n            var scrollingContainers = [];\n            this.scrollContainers.forEach(function (_subscription, scrollable) {\n                if (_this._scrollableContainsElement(scrollable, elementRef)) {\n                    scrollingContainers.push(scrollable);\n                }\n            });\n            return scrollingContainers;\n        };\n        /** Returns true if the element is contained within the provided Scrollable. */\n        ScrollDispatcher.prototype._scrollableContainsElement = function (scrollable, elementRef) {\n            var element = elementRef.nativeElement;\n            var scrollableElement = scrollable.getElementRef().nativeElement;\n            // Traverse through the element parents until we reach null, checking if any of the elements\n            // are the scrollable's element.\n            do {\n                if (element == scrollableElement) {\n                    return true;\n                }\n            } while (element = element.parentElement);\n            return false;\n        };\n        /** Sets up the global scroll listeners. */\n        ScrollDispatcher.prototype._addGlobalListener = function () {\n            var _this = this;\n            this._globalSubscription = this._ngZone.runOutsideAngular(function () {\n                return rxjs.fromEvent(window.document, 'scroll').subscribe(function () { return _this._scrolled.next(); });\n            });\n        };\n        /** Cleans up the global scroll listener. */\n        ScrollDispatcher.prototype._removeGlobalListener = function () {\n            if (this._globalSubscription) {\n                this._globalSubscription.unsubscribe();\n                this._globalSubscription = null;\n            }\n        };\n        ScrollDispatcher.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        ScrollDispatcher.ctorParameters = function () { return [\n            { type: i0.NgZone },\n            { type: platform.Platform }\n        ]; };\n        ScrollDispatcher.ɵprov = i0.ɵɵdefineInjectable({ factory: function ScrollDispatcher_Factory() { return new ScrollDispatcher(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(Platform)); }, token: ScrollDispatcher, providedIn: \"root\" });\n        return ScrollDispatcher;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Time in ms to throttle the resize events by default. */\n    var DEFAULT_RESIZE_TIME = 20;\n    /**\n     * Simple utility for getting the bounds of the browser viewport.\n     * @docs-private\n     */\n    var ViewportRuler = /** @class */ (function () {\n        function ViewportRuler(_platform, ngZone) {\n            var _this = this;\n            this._platform = _platform;\n            ngZone.runOutsideAngular(function () {\n                _this._change = _platform.isBrowser ?\n                    rxjs.merge(rxjs.fromEvent(window, 'resize'), rxjs.fromEvent(window, 'orientationchange')) :\n                    rxjs.of();\n                // Note that we need to do the subscription inside `runOutsideAngular`\n                // since subscribing is what causes the event listener to be added.\n                _this._invalidateCache = _this.change().subscribe(function () { return _this._updateViewportSize(); });\n            });\n        }\n        ViewportRuler.prototype.ngOnDestroy = function () {\n            this._invalidateCache.unsubscribe();\n        };\n        /** Returns the viewport's width and height. */\n        ViewportRuler.prototype.getViewportSize = function () {\n            if (!this._viewportSize) {\n                this._updateViewportSize();\n            }\n            var output = { width: this._viewportSize.width, height: this._viewportSize.height };\n            // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\n            if (!this._platform.isBrowser) {\n                this._viewportSize = null;\n            }\n            return output;\n        };\n        /** Gets a ClientRect for the viewport's bounds. */\n        ViewportRuler.prototype.getViewportRect = function () {\n            // Use the document element's bounding rect rather than the window scroll properties\n            // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n            // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n            // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n            // can disagree when the page is pinch-zoomed (on devices that support touch).\n            // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n            // We use the documentElement instead of the body because, by default (without a css reset)\n            // browsers typically give the document body an 8px margin, which is not included in\n            // getBoundingClientRect().\n            var scrollPosition = this.getViewportScrollPosition();\n            var _a = this.getViewportSize(), width = _a.width, height = _a.height;\n            return {\n                top: scrollPosition.top,\n                left: scrollPosition.left,\n                bottom: scrollPosition.top + height,\n                right: scrollPosition.left + width,\n                height: height,\n                width: width,\n            };\n        };\n        /** Gets the (top, left) scroll position of the viewport. */\n        ViewportRuler.prototype.getViewportScrollPosition = function () {\n            // While we can get a reference to the fake document\n            // during SSR, it doesn't have getBoundingClientRect.\n            if (!this._platform.isBrowser) {\n                return { top: 0, left: 0 };\n            }\n            // The top-left-corner of the viewport is determined by the scroll position of the document\n            // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n            // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n            // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n            // `document.documentElement` works consistently, where the `top` and `left` values will\n            // equal negative the scroll position.\n            var documentElement = document.documentElement;\n            var documentRect = documentElement.getBoundingClientRect();\n            var top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n                documentElement.scrollTop || 0;\n            var left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n                documentElement.scrollLeft || 0;\n            return { top: top, left: left };\n        };\n        /**\n         * Returns a stream that emits whenever the size of the viewport changes.\n         * @param throttleTime Time in milliseconds to throttle the stream.\n         */\n        ViewportRuler.prototype.change = function (throttleTime) {\n            if (throttleTime === void 0) { throttleTime = DEFAULT_RESIZE_TIME; }\n            return throttleTime > 0 ? this._change.pipe(operators.auditTime(throttleTime)) : this._change;\n        };\n        /** Updates the cached viewport size. */\n        ViewportRuler.prototype._updateViewportSize = function () {\n            this._viewportSize = this._platform.isBrowser ?\n                { width: window.innerWidth, height: window.innerHeight } :\n                { width: 0, height: 0 };\n        };\n        ViewportRuler.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        ViewportRuler.ctorParameters = function () { return [\n            { type: platform.Platform },\n            { type: i0.NgZone }\n        ]; };\n        ViewportRuler.ɵprov = i0.ɵɵdefineInjectable({ factory: function ViewportRuler_Factory() { return new ViewportRuler(i0.ɵɵinject(Platform), i0.ɵɵinject(i0.NgZone)); }, token: ViewportRuler, providedIn: \"root\" });\n        return ViewportRuler;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Options for how an overlay will handle scrolling.\n     *\n     * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n     * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n     */\n    var ScrollStrategyOptions = /** @class */ (function () {\n        function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone, document) {\n            var _this = this;\n            this._scrollDispatcher = _scrollDispatcher;\n            this._viewportRuler = _viewportRuler;\n            this._ngZone = _ngZone;\n            /** Do nothing on scroll. */\n            this.noop = function () { return new NoopScrollStrategy(); };\n            /**\n             * Close the overlay as soon as the user scrolls.\n             * @param config Configuration to be used inside the scroll strategy.\n             */\n            this.close = function (config) { return new CloseScrollStrategy(_this._scrollDispatcher, _this._ngZone, _this._viewportRuler, config); };\n            /** Block scrolling. */\n            this.block = function () { return new BlockScrollStrategy(_this._viewportRuler, _this._document); };\n            /**\n             * Update the overlay's position on scroll.\n             * @param config Configuration to be used inside the scroll strategy.\n             * Allows debouncing the reposition calls.\n             */\n            this.reposition = function (config) { return new RepositionScrollStrategy(_this._scrollDispatcher, _this._viewportRuler, _this._ngZone, config); };\n            this._document = document;\n        }\n        ScrollStrategyOptions.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        ScrollStrategyOptions.ctorParameters = function () { return [\n            { type: scrolling.ScrollDispatcher },\n            { type: scrolling.ViewportRuler },\n            { type: i0.NgZone },\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] }\n        ]; };\n        ScrollStrategyOptions.ɵprov = i0.ɵɵdefineInjectable({ factory: function ScrollStrategyOptions_Factory() { return new ScrollStrategyOptions(i0.ɵɵinject(ScrollDispatcher), i0.ɵɵinject(ViewportRuler), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.DOCUMENT)); }, token: ScrollStrategyOptions, providedIn: \"root\" });\n        return ScrollStrategyOptions;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Initial configuration used when creating an overlay. */\n    var OverlayConfig = /** @class */ (function () {\n        function OverlayConfig(config) {\n            var e_1, _a;\n            /** Strategy to be used when handling scroll events while the overlay is open. */\n            this.scrollStrategy = new NoopScrollStrategy();\n            /** Custom class to add to the overlay pane. */\n            this.panelClass = '';\n            /** Whether the overlay has a backdrop. */\n            this.hasBackdrop = false;\n            /** Custom class to add to the backdrop */\n            this.backdropClass = 'cdk-overlay-dark-backdrop';\n            /**\n             * Whether the overlay should be disposed of when the user goes backwards/forwards in history.\n             * Note that this usually doesn't include clicking on links (unless the user is using\n             * the `HashLocationStrategy`).\n             */\n            this.disposeOnNavigation = false;\n            if (config) {\n                // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,\n                // loses the array generic type in the `for of`. But we *also* have to use `Array` because\n                // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`\n                var configKeys = Object.keys(config);\n                try {\n                    for (var configKeys_1 = tslib.__values(configKeys), configKeys_1_1 = configKeys_1.next(); !configKeys_1_1.done; configKeys_1_1 = configKeys_1.next()) {\n                        var key = configKeys_1_1.value;\n                        if (config[key] !== undefined) {\n                            // TypeScript, as of version 3.5, sees the left-hand-side of this expression\n                            // as \"I don't know *which* key this is, so the only valid value is the intersection\n                            // of all the posible values.\" In this case, that happens to be `undefined`. TypeScript\n                            // is not smart enough to see that the right-hand-side is actually an access of the same\n                            // exact type with the same exact key, meaning that the value type must be identical.\n                            // So we use `any` to work around this.\n                            this[key] = config[key];\n                        }\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (configKeys_1_1 && !configKeys_1_1.done && (_a = configKeys_1.return)) _a.call(configKeys_1);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n        }\n        return OverlayConfig;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** The points of the origin element and the overlay element to connect. */\n    var ConnectionPositionPair = /** @class */ (function () {\n        function ConnectionPositionPair(origin, overlay, \n        /** Offset along the X axis. */\n        offsetX, \n        /** Offset along the Y axis. */\n        offsetY, \n        /** Class(es) to be applied to the panel while this position is active. */\n        panelClass) {\n            this.offsetX = offsetX;\n            this.offsetY = offsetY;\n            this.panelClass = panelClass;\n            this.originX = origin.originX;\n            this.originY = origin.originY;\n            this.overlayX = overlay.overlayX;\n            this.overlayY = overlay.overlayY;\n        }\n        return ConnectionPositionPair;\n    }());\n    /**\n     * Set of properties regarding the position of the origin and overlay relative to the viewport\n     * with respect to the containing Scrollable elements.\n     *\n     * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n     * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n     *\n     * The overlay and origin are outside view if there is no overlap between their bounding client\n     * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n     *\n     *       -----------                    -----------\n     *       | outside |                    | clipped |\n     *       |  view   |              --------------------------\n     *       |         |              |     |         |        |\n     *       ----------               |     -----------        |\n     *  --------------------------    |                        |\n     *  |                        |    |      Scrollable        |\n     *  |                        |    |                        |\n     *  |                        |     --------------------------\n     *  |      Scrollable        |\n     *  |                        |\n     *  --------------------------\n     *\n     *  @docs-private\n     */\n    var ScrollingVisibility = /** @class */ (function () {\n        function ScrollingVisibility() {\n        }\n        return ScrollingVisibility;\n    }());\n    /** The change event emitted by the strategy when a fallback position is used. */\n    var ConnectedOverlayPositionChange = /** @class */ (function () {\n        function ConnectedOverlayPositionChange(\n        /** The position used as a result of this change. */\n        connectionPair, \n        /** @docs-private */\n        scrollableViewProperties) {\n            this.connectionPair = connectionPair;\n            this.scrollableViewProperties = scrollableViewProperties;\n        }\n        /** @nocollapse */\n        ConnectedOverlayPositionChange.ctorParameters = function () { return [\n            { type: ConnectionPositionPair },\n            { type: ScrollingVisibility, decorators: [{ type: i0.Optional }] }\n        ]; };\n        return ConnectedOverlayPositionChange;\n    }());\n    /**\n     * Validates whether a vertical position property matches the expected values.\n     * @param property Name of the property being validated.\n     * @param value Value of the property being validated.\n     * @docs-private\n     */\n    function validateVerticalPosition(property, value) {\n        if (value !== 'top' && value !== 'bottom' && value !== 'center') {\n            throw Error(\"ConnectedPosition: Invalid \" + property + \" \\\"\" + value + \"\\\". \" +\n                \"Expected \\\"top\\\", \\\"bottom\\\" or \\\"center\\\".\");\n        }\n    }\n    /**\n     * Validates whether a horizontal position property matches the expected values.\n     * @param property Name of the property being validated.\n     * @param value Value of the property being validated.\n     * @docs-private\n     */\n    function validateHorizontalPosition(property, value) {\n        if (value !== 'start' && value !== 'end' && value !== 'center') {\n            throw Error(\"ConnectedPosition: Invalid \" + property + \" \\\"\" + value + \"\\\". \" +\n                \"Expected \\\"start\\\", \\\"end\\\" or \\\"center\\\".\");\n        }\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n     * if any. It maintains a list of attached overlays to determine best suited overlay based\n     * on event target and order of overlay opens.\n     */\n    var OverlayKeyboardDispatcher = /** @class */ (function () {\n        function OverlayKeyboardDispatcher(document) {\n            var _this = this;\n            /** Currently attached overlays in the order they were attached. */\n            this._attachedOverlays = [];\n            /** Keyboard event listener that will be attached to the body. */\n            this._keydownListener = function (event) {\n                var overlays = _this._attachedOverlays;\n                for (var i = overlays.length - 1; i > -1; i--) {\n                    // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.\n                    // We want to target the most recent overlay, rather than trying to match where the event came\n                    // from, because some components might open an overlay, but keep focus on a trigger element\n                    // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,\n                    // because we don't want overlays that don't handle keyboard events to block the ones below\n                    // them that do.\n                    if (overlays[i]._keydownEventSubscriptions > 0) {\n                        overlays[i]._keydownEvents.next(event);\n                        break;\n                    }\n                }\n            };\n            this._document = document;\n        }\n        OverlayKeyboardDispatcher.prototype.ngOnDestroy = function () {\n            this._detach();\n        };\n        /** Add a new overlay to the list of attached overlay refs. */\n        OverlayKeyboardDispatcher.prototype.add = function (overlayRef) {\n            // Ensure that we don't get the same overlay multiple times.\n            this.remove(overlayRef);\n            // Lazily start dispatcher once first overlay is added\n            if (!this._isAttached) {\n                this._document.body.addEventListener('keydown', this._keydownListener);\n                this._isAttached = true;\n            }\n            this._attachedOverlays.push(overlayRef);\n        };\n        /** Remove an overlay from the list of attached overlay refs. */\n        OverlayKeyboardDispatcher.prototype.remove = function (overlayRef) {\n            var index = this._attachedOverlays.indexOf(overlayRef);\n            if (index > -1) {\n                this._attachedOverlays.splice(index, 1);\n            }\n            // Remove the global listener once there are no more overlays.\n            if (this._attachedOverlays.length === 0) {\n                this._detach();\n            }\n        };\n        /** Detaches the global keyboard event listener. */\n        OverlayKeyboardDispatcher.prototype._detach = function () {\n            if (this._isAttached) {\n                this._document.body.removeEventListener('keydown', this._keydownListener);\n                this._isAttached = false;\n            }\n        };\n        OverlayKeyboardDispatcher.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        OverlayKeyboardDispatcher.ctorParameters = function () { return [\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] }\n        ]; };\n        OverlayKeyboardDispatcher.ɵprov = i0.ɵɵdefineInjectable({ factory: function OverlayKeyboardDispatcher_Factory() { return new OverlayKeyboardDispatcher(i0.ɵɵinject(i1.DOCUMENT)); }, token: OverlayKeyboardDispatcher, providedIn: \"root\" });\n        return OverlayKeyboardDispatcher;\n    }());\n    /** @docs-private @deprecated @breaking-change 8.0.0 */\n    function OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {\n        return dispatcher || new OverlayKeyboardDispatcher(_document);\n    }\n    /** @docs-private @deprecated @breaking-change 8.0.0 */\n    var OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n        // If there is already an OverlayKeyboardDispatcher available, use that.\n        // Otherwise, provide a new one.\n        provide: OverlayKeyboardDispatcher,\n        deps: [\n            [new i0.Optional(), new i0.SkipSelf(), OverlayKeyboardDispatcher],\n            // Coerce to `InjectionToken` so that the `deps` match the \"shape\"\n            // of the type expected by Angular\n            i1.DOCUMENT\n        ],\n        useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n    };\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Container inside which all overlays will render. */\n    var OverlayContainer = /** @class */ (function () {\n        function OverlayContainer(document) {\n            this._document = document;\n        }\n        OverlayContainer.prototype.ngOnDestroy = function () {\n            if (this._containerElement && this._containerElement.parentNode) {\n                this._containerElement.parentNode.removeChild(this._containerElement);\n            }\n        };\n        /**\n         * This method returns the overlay container element. It will lazily\n         * create the element the first time  it is called to facilitate using\n         * the container in non-browser environments.\n         * @returns the container element\n         */\n        OverlayContainer.prototype.getContainerElement = function () {\n            if (!this._containerElement) {\n                this._createContainer();\n            }\n            return this._containerElement;\n        };\n        /**\n         * Create the overlay container element, which is simply a div\n         * with the 'cdk-overlay-container' class on the document body.\n         */\n        OverlayContainer.prototype._createContainer = function () {\n            var containerClass = 'cdk-overlay-container';\n            var previousContainers = this._document.getElementsByClassName(containerClass);\n            // Remove any old containers. This can happen when transitioning from the server to the client.\n            for (var i = 0; i < previousContainers.length; i++) {\n                previousContainers[i].parentNode.removeChild(previousContainers[i]);\n            }\n            var container = this._document.createElement('div');\n            container.classList.add(containerClass);\n            this._document.body.appendChild(container);\n            this._containerElement = container;\n        };\n        OverlayContainer.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        OverlayContainer.ctorParameters = function () { return [\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] }\n        ]; };\n        OverlayContainer.ɵprov = i0.ɵɵdefineInjectable({ factory: function OverlayContainer_Factory() { return new OverlayContainer(i0.ɵɵinject(i1.DOCUMENT)); }, token: OverlayContainer, providedIn: \"root\" });\n        return OverlayContainer;\n    }());\n    /** @docs-private @deprecated @breaking-change 8.0.0 */\n    function OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {\n        return parentContainer || new OverlayContainer(_document);\n    }\n    /** @docs-private @deprecated @breaking-change 8.0.0 */\n    var OVERLAY_CONTAINER_PROVIDER = {\n        // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n        provide: OverlayContainer,\n        deps: [\n            [new i0.Optional(), new i0.SkipSelf(), OverlayContainer],\n            i1.DOCUMENT // We need to use the InjectionToken somewhere to keep TS happy\n        ],\n        useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n    };\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Reference to an overlay that has been created with the Overlay service.\n     * Used to manipulate or dispose of said overlay.\n     */\n    var OverlayRef = /** @class */ (function () {\n        function OverlayRef(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, \n        // @breaking-change 8.0.0 `_location` parameter to be made required.\n        _location) {\n            var _this = this;\n            this._portalOutlet = _portalOutlet;\n            this._host = _host;\n            this._pane = _pane;\n            this._config = _config;\n            this._ngZone = _ngZone;\n            this._keyboardDispatcher = _keyboardDispatcher;\n            this._document = _document;\n            this._location = _location;\n            this._backdropElement = null;\n            this._backdropClick = new rxjs.Subject();\n            this._attachments = new rxjs.Subject();\n            this._detachments = new rxjs.Subject();\n            this._locationChanges = rxjs.Subscription.EMPTY;\n            this._backdropClickHandler = function (event) { return _this._backdropClick.next(event); };\n            this._keydownEventsObservable = new rxjs.Observable(function (observer) {\n                var subscription = _this._keydownEvents.subscribe(observer);\n                _this._keydownEventSubscriptions++;\n                return function () {\n                    subscription.unsubscribe();\n                    _this._keydownEventSubscriptions--;\n                };\n            });\n            /** Stream of keydown events dispatched to this overlay. */\n            this._keydownEvents = new rxjs.Subject();\n            /** Amount of subscriptions to the keydown events. */\n            this._keydownEventSubscriptions = 0;\n            if (_config.scrollStrategy) {\n                this._scrollStrategy = _config.scrollStrategy;\n                this._scrollStrategy.attach(this);\n            }\n            this._positionStrategy = _config.positionStrategy;\n        }\n        Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n            /** The overlay's HTML element */\n            get: function () {\n                return this._pane;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(OverlayRef.prototype, \"backdropElement\", {\n            /** The overlay's backdrop HTML element. */\n            get: function () {\n                return this._backdropElement;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(OverlayRef.prototype, \"hostElement\", {\n            /**\n             * Wrapper around the panel element. Can be used for advanced\n             * positioning where a wrapper with specific styling is\n             * required around the overlay pane.\n             */\n            get: function () {\n                return this._host;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Attaches content, given via a Portal, to the overlay.\n         * If the overlay is configured to have a backdrop, it will be created.\n         *\n         * @param portal Portal instance to which to attach the overlay.\n         * @returns The portal attachment result.\n         */\n        OverlayRef.prototype.attach = function (portal) {\n            var _this = this;\n            var attachResult = this._portalOutlet.attach(portal);\n            if (this._positionStrategy) {\n                this._positionStrategy.attach(this);\n            }\n            // Update the pane element with the given configuration.\n            if (!this._host.parentElement && this._previousHostParent) {\n                this._previousHostParent.appendChild(this._host);\n            }\n            this._updateStackingOrder();\n            this._updateElementSize();\n            this._updateElementDirection();\n            if (this._scrollStrategy) {\n                this._scrollStrategy.enable();\n            }\n            // Update the position once the zone is stable so that the overlay will be fully rendered\n            // before attempting to position it, as the position may depend on the size of the rendered\n            // content.\n            this._ngZone.onStable\n                .asObservable()\n                .pipe(operators.take(1))\n                .subscribe(function () {\n                // The overlay could've been detached before the zone has stabilized.\n                if (_this.hasAttached()) {\n                    _this.updatePosition();\n                }\n            });\n            // Enable pointer events for the overlay pane element.\n            this._togglePointerEvents(true);\n            if (this._config.hasBackdrop) {\n                this._attachBackdrop();\n            }\n            if (this._config.panelClass) {\n                this._toggleClasses(this._pane, this._config.panelClass, true);\n            }\n            // Only emit the `attachments` event once all other setup is done.\n            this._attachments.next();\n            // Track this overlay by the keyboard dispatcher\n            this._keyboardDispatcher.add(this);\n            // @breaking-change 8.0.0 remove the null check for `_location`\n            // once the constructor parameter is made required.\n            if (this._config.disposeOnNavigation && this._location) {\n                this._locationChanges = this._location.subscribe(function () { return _this.dispose(); });\n            }\n            return attachResult;\n        };\n        /**\n         * Detaches an overlay from a portal.\n         * @returns The portal detachment result.\n         */\n        OverlayRef.prototype.detach = function () {\n            if (!this.hasAttached()) {\n                return;\n            }\n            this.detachBackdrop();\n            // When the overlay is detached, the pane element should disable pointer events.\n            // This is necessary because otherwise the pane element will cover the page and disable\n            // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n            this._togglePointerEvents(false);\n            if (this._positionStrategy && this._positionStrategy.detach) {\n                this._positionStrategy.detach();\n            }\n            if (this._scrollStrategy) {\n                this._scrollStrategy.disable();\n            }\n            var detachmentResult = this._portalOutlet.detach();\n            // Only emit after everything is detached.\n            this._detachments.next();\n            // Remove this overlay from keyboard dispatcher tracking.\n            this._keyboardDispatcher.remove(this);\n            // Keeping the host element in the DOM can cause scroll jank, because it still gets\n            // rendered, even though it's transparent and unclickable which is why we remove it.\n            this._detachContentWhenStable();\n            // Stop listening for location changes.\n            this._locationChanges.unsubscribe();\n            return detachmentResult;\n        };\n        /** Cleans up the overlay from the DOM. */\n        OverlayRef.prototype.dispose = function () {\n            var isAttached = this.hasAttached();\n            if (this._positionStrategy) {\n                this._positionStrategy.dispose();\n            }\n            this._disposeScrollStrategy();\n            this.detachBackdrop();\n            this._locationChanges.unsubscribe();\n            this._keyboardDispatcher.remove(this);\n            this._portalOutlet.dispose();\n            this._attachments.complete();\n            this._backdropClick.complete();\n            this._keydownEvents.complete();\n            if (this._host && this._host.parentNode) {\n                this._host.parentNode.removeChild(this._host);\n                this._host = null;\n            }\n            this._previousHostParent = this._pane = null;\n            if (isAttached) {\n                this._detachments.next();\n            }\n            this._detachments.complete();\n        };\n        /** Whether the overlay has attached content. */\n        OverlayRef.prototype.hasAttached = function () {\n            return this._portalOutlet.hasAttached();\n        };\n        /** Gets an observable that emits when the backdrop has been clicked. */\n        OverlayRef.prototype.backdropClick = function () {\n            return this._backdropClick.asObservable();\n        };\n        /** Gets an observable that emits when the overlay has been attached. */\n        OverlayRef.prototype.attachments = function () {\n            return this._attachments.asObservable();\n        };\n        /** Gets an observable that emits when the overlay has been detached. */\n        OverlayRef.prototype.detachments = function () {\n            return this._detachments.asObservable();\n        };\n        /** Gets an observable of keydown events targeted to this overlay. */\n        OverlayRef.prototype.keydownEvents = function () {\n            return this._keydownEventsObservable;\n        };\n        /** Gets the current overlay configuration, which is immutable. */\n        OverlayRef.prototype.getConfig = function () {\n            return this._config;\n        };\n        /** Updates the position of the overlay based on the position strategy. */\n        OverlayRef.prototype.updatePosition = function () {\n            if (this._positionStrategy) {\n                this._positionStrategy.apply();\n            }\n        };\n        /** Switches to a new position strategy and updates the overlay position. */\n        OverlayRef.prototype.updatePositionStrategy = function (strategy) {\n            if (strategy === this._positionStrategy) {\n                return;\n            }\n            if (this._positionStrategy) {\n                this._positionStrategy.dispose();\n            }\n            this._positionStrategy = strategy;\n            if (this.hasAttached()) {\n                strategy.attach(this);\n                this.updatePosition();\n            }\n        };\n        /** Update the size properties of the overlay. */\n        OverlayRef.prototype.updateSize = function (sizeConfig) {\n            this._config = tslib.__assign(tslib.__assign({}, this._config), sizeConfig);\n            this._updateElementSize();\n        };\n        /** Sets the LTR/RTL direction for the overlay. */\n        OverlayRef.prototype.setDirection = function (dir) {\n            this._config = tslib.__assign(tslib.__assign({}, this._config), { direction: dir });\n            this._updateElementDirection();\n        };\n        /** Add a CSS class or an array of classes to the overlay pane. */\n        OverlayRef.prototype.addPanelClass = function (classes) {\n            if (this._pane) {\n                this._toggleClasses(this._pane, classes, true);\n            }\n        };\n        /** Remove a CSS class or an array of classes from the overlay pane. */\n        OverlayRef.prototype.removePanelClass = function (classes) {\n            if (this._pane) {\n                this._toggleClasses(this._pane, classes, false);\n            }\n        };\n        /**\n         * Returns the layout direction of the overlay panel.\n         */\n        OverlayRef.prototype.getDirection = function () {\n            var direction = this._config.direction;\n            if (!direction) {\n                return 'ltr';\n            }\n            return typeof direction === 'string' ? direction : direction.value;\n        };\n        /** Switches to a new scroll strategy. */\n        OverlayRef.prototype.updateScrollStrategy = function (strategy) {\n            if (strategy === this._scrollStrategy) {\n                return;\n            }\n            this._disposeScrollStrategy();\n            this._scrollStrategy = strategy;\n            if (this.hasAttached()) {\n                strategy.attach(this);\n                strategy.enable();\n            }\n        };\n        /** Updates the text direction of the overlay panel. */\n        OverlayRef.prototype._updateElementDirection = function () {\n            this._host.setAttribute('dir', this.getDirection());\n        };\n        /** Updates the size of the overlay element based on the overlay config. */\n        OverlayRef.prototype._updateElementSize = function () {\n            if (!this._pane) {\n                return;\n            }\n            var style = this._pane.style;\n            style.width = coercion.coerceCssPixelValue(this._config.width);\n            style.height = coercion.coerceCssPixelValue(this._config.height);\n            style.minWidth = coercion.coerceCssPixelValue(this._config.minWidth);\n            style.minHeight = coercion.coerceCssPixelValue(this._config.minHeight);\n            style.maxWidth = coercion.coerceCssPixelValue(this._config.maxWidth);\n            style.maxHeight = coercion.coerceCssPixelValue(this._config.maxHeight);\n        };\n        /** Toggles the pointer events for the overlay pane element. */\n        OverlayRef.prototype._togglePointerEvents = function (enablePointer) {\n            this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n        };\n        /** Attaches a backdrop for this overlay. */\n        OverlayRef.prototype._attachBackdrop = function () {\n            var _this = this;\n            var showingClass = 'cdk-overlay-backdrop-showing';\n            this._backdropElement = this._document.createElement('div');\n            this._backdropElement.classList.add('cdk-overlay-backdrop');\n            if (this._config.backdropClass) {\n                this._toggleClasses(this._backdropElement, this._config.backdropClass, true);\n            }\n            // Insert the backdrop before the pane in the DOM order,\n            // in order to handle stacked overlays properly.\n            this._host.parentElement.insertBefore(this._backdropElement, this._host);\n            // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n            // action desired when such a click occurs (usually closing the overlay).\n            this._backdropElement.addEventListener('click', this._backdropClickHandler);\n            // Add class to fade-in the backdrop after one frame.\n            if (typeof requestAnimationFrame !== 'undefined') {\n                this._ngZone.runOutsideAngular(function () {\n                    requestAnimationFrame(function () {\n                        if (_this._backdropElement) {\n                            _this._backdropElement.classList.add(showingClass);\n                        }\n                    });\n                });\n            }\n            else {\n                this._backdropElement.classList.add(showingClass);\n            }\n        };\n        /**\n         * Updates the stacking order of the element, moving it to the top if necessary.\n         * This is required in cases where one overlay was detached, while another one,\n         * that should be behind it, was destroyed. The next time both of them are opened,\n         * the stacking will be wrong, because the detached element's pane will still be\n         * in its original DOM position.\n         */\n        OverlayRef.prototype._updateStackingOrder = function () {\n            if (this._host.nextSibling) {\n                this._host.parentNode.appendChild(this._host);\n            }\n        };\n        /** Detaches the backdrop (if any) associated with the overlay. */\n        OverlayRef.prototype.detachBackdrop = function () {\n            var _this = this;\n            var backdropToDetach = this._backdropElement;\n            if (!backdropToDetach) {\n                return;\n            }\n            var timeoutId;\n            var finishDetach = function () {\n                // It may not be attached to anything in certain cases (e.g. unit tests).\n                if (backdropToDetach) {\n                    backdropToDetach.removeEventListener('click', _this._backdropClickHandler);\n                    backdropToDetach.removeEventListener('transitionend', finishDetach);\n                    if (backdropToDetach.parentNode) {\n                        backdropToDetach.parentNode.removeChild(backdropToDetach);\n                    }\n                }\n                // It is possible that a new portal has been attached to this overlay since we started\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                // is still the same instance that we started to remove.\n                if (_this._backdropElement == backdropToDetach) {\n                    _this._backdropElement = null;\n                }\n                if (_this._config.backdropClass) {\n                    _this._toggleClasses(backdropToDetach, _this._config.backdropClass, false);\n                }\n                clearTimeout(timeoutId);\n            };\n            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n            this._ngZone.runOutsideAngular(function () {\n                backdropToDetach.addEventListener('transitionend', finishDetach);\n            });\n            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n            // In this case we make it unclickable and we try to remove it after a delay.\n            backdropToDetach.style.pointerEvents = 'none';\n            // Run this outside the Angular zone because there's nothing that Angular cares about.\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\n            // either async or fakeAsync.\n            timeoutId = this._ngZone.runOutsideAngular(function () { return setTimeout(finishDetach, 500); });\n        };\n        /** Toggles a single CSS class or an array of classes on an element. */\n        OverlayRef.prototype._toggleClasses = function (element, cssClasses, isAdd) {\n            var classList = element.classList;\n            coercion.coerceArray(cssClasses).forEach(function (cssClass) {\n                // We can't do a spread here, because IE doesn't support setting multiple classes.\n                // Also trying to add an empty string to a DOMTokenList will throw.\n                if (cssClass) {\n                    isAdd ? classList.add(cssClass) : classList.remove(cssClass);\n                }\n            });\n        };\n        /** Detaches the overlay content next time the zone stabilizes. */\n        OverlayRef.prototype._detachContentWhenStable = function () {\n            var _this = this;\n            // Normally we wouldn't have to explicitly run this outside the `NgZone`, however\n            // if the consumer is using `zone-patch-rxjs`, the `Subscription.unsubscribe` call will\n            // be patched to run inside the zone, which will throw us into an infinite loop.\n            this._ngZone.runOutsideAngular(function () {\n                // We can't remove the host here immediately, because the overlay pane's content\n                // might still be animating. This stream helps us avoid interrupting the animation\n                // by waiting for the pane to become empty.\n                var subscription = _this._ngZone.onStable\n                    .asObservable()\n                    .pipe(operators.takeUntil(rxjs.merge(_this._attachments, _this._detachments)))\n                    .subscribe(function () {\n                    // Needs a couple of checks for the pane and host, because\n                    // they may have been removed by the time the zone stabilizes.\n                    if (!_this._pane || !_this._host || _this._pane.children.length === 0) {\n                        if (_this._pane && _this._config.panelClass) {\n                            _this._toggleClasses(_this._pane, _this._config.panelClass, false);\n                        }\n                        if (_this._host && _this._host.parentElement) {\n                            _this._previousHostParent = _this._host.parentElement;\n                            _this._previousHostParent.removeChild(_this._host);\n                        }\n                        subscription.unsubscribe();\n                    }\n                });\n            });\n        };\n        /** Disposes of a scroll strategy. */\n        OverlayRef.prototype._disposeScrollStrategy = function () {\n            var scrollStrategy = this._scrollStrategy;\n            if (scrollStrategy) {\n                scrollStrategy.disable();\n                if (scrollStrategy.detach) {\n                    scrollStrategy.detach();\n                }\n            }\n        };\n        return OverlayRef;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // TODO: refactor clipping detection into a separate thing (part of scrolling module)\n    // TODO: doesn't handle both flexible width and height when it has to scroll along both axis.\n    /** Class to be added to the overlay bounding box. */\n    var boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';\n    /**\n     * A strategy for positioning overlays. Using this strategy, an overlay is given an\n     * implicit position relative some origin element. The relative position is defined in terms of\n     * a point on the origin element that is connected to a point on the overlay element. For example,\n     * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n     * of the overlay.\n     */\n    var FlexibleConnectedPositionStrategy = /** @class */ (function () {\n        function FlexibleConnectedPositionStrategy(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {\n            this._viewportRuler = _viewportRuler;\n            this._document = _document;\n            this._platform = _platform;\n            this._overlayContainer = _overlayContainer;\n            /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */\n            this._lastBoundingBoxSize = { width: 0, height: 0 };\n            /** Whether the overlay was pushed in a previous positioning. */\n            this._isPushed = false;\n            /** Whether the overlay can be pushed on-screen on the initial open. */\n            this._canPush = true;\n            /** Whether the overlay can grow via flexible width/height after the initial open. */\n            this._growAfterOpen = false;\n            /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n            this._hasFlexibleDimensions = true;\n            /** Whether the overlay position is locked. */\n            this._positionLocked = false;\n            /** Amount of space that must be maintained between the overlay and the edge of the viewport. */\n            this._viewportMargin = 0;\n            /** The Scrollable containers used to check scrollable view properties on position change. */\n            this._scrollables = [];\n            /** Ordered list of preferred positions, from most to least desirable. */\n            this._preferredPositions = [];\n            /** Subject that emits whenever the position changes. */\n            this._positionChanges = new rxjs.Subject();\n            /** Subscription to viewport size changes. */\n            this._resizeSubscription = rxjs.Subscription.EMPTY;\n            /** Default offset for the overlay along the x axis. */\n            this._offsetX = 0;\n            /** Default offset for the overlay along the y axis. */\n            this._offsetY = 0;\n            /** Keeps track of the CSS classes that the position strategy has applied on the overlay panel. */\n            this._appliedPanelClasses = [];\n            /** Observable sequence of position changes. */\n            this.positionChanges = this._positionChanges.asObservable();\n            this.setOrigin(connectedTo);\n        }\n        Object.defineProperty(FlexibleConnectedPositionStrategy.prototype, \"positions\", {\n            /** Ordered list of preferred positions, from most to least desirable. */\n            get: function () {\n                return this._preferredPositions;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Attaches this position strategy to an overlay. */\n        FlexibleConnectedPositionStrategy.prototype.attach = function (overlayRef) {\n            var _this = this;\n            if (this._overlayRef && overlayRef !== this._overlayRef) {\n                throw Error('This position strategy is already attached to an overlay');\n            }\n            this._validatePositions();\n            overlayRef.hostElement.classList.add(boundingBoxClass);\n            this._overlayRef = overlayRef;\n            this._boundingBox = overlayRef.hostElement;\n            this._pane = overlayRef.overlayElement;\n            this._isDisposed = false;\n            this._isInitialRender = true;\n            this._lastPosition = null;\n            this._resizeSubscription.unsubscribe();\n            this._resizeSubscription = this._viewportRuler.change().subscribe(function () {\n                // When the window is resized, we want to trigger the next reposition as if it\n                // was an initial render, in order for the strategy to pick a new optimal position,\n                // otherwise position locking will cause it to stay at the old one.\n                _this._isInitialRender = true;\n                _this.apply();\n            });\n        };\n        /**\n         * Updates the position of the overlay element, using whichever preferred position relative\n         * to the origin best fits on-screen.\n         *\n         * The selection of a position goes as follows:\n         *  - If any positions fit completely within the viewport as-is,\n         *      choose the first position that does so.\n         *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,\n         *      choose the position with the greatest available size modified by the positions' weight.\n         *  - If pushing is enabled, take the position that went off-screen the least and push it\n         *      on-screen.\n         *  - If none of the previous criteria were met, use the position that goes off-screen the least.\n         * @docs-private\n         */\n        FlexibleConnectedPositionStrategy.prototype.apply = function () {\n            var e_1, _a, e_2, _b;\n            // We shouldn't do anything if the strategy was disposed or we're on the server.\n            if (this._isDisposed || !this._platform.isBrowser) {\n                return;\n            }\n            // If the position has been applied already (e.g. when the overlay was opened) and the\n            // consumer opted into locking in the position, re-use the old position, in order to\n            // prevent the overlay from jumping around.\n            if (!this._isInitialRender && this._positionLocked && this._lastPosition) {\n                this.reapplyLastPosition();\n                return;\n            }\n            this._clearPanelClasses();\n            this._resetOverlayElementStyles();\n            this._resetBoundingBoxStyles();\n            // We need the bounding rects for the origin and the overlay to determine how to position\n            // the overlay relative to the origin.\n            // We use the viewport rect to determine whether a position would go off-screen.\n            this._viewportRect = this._getNarrowedViewportRect();\n            this._originRect = this._getOriginRect();\n            this._overlayRect = this._pane.getBoundingClientRect();\n            var originRect = this._originRect;\n            var overlayRect = this._overlayRect;\n            var viewportRect = this._viewportRect;\n            // Positions where the overlay will fit with flexible dimensions.\n            var flexibleFits = [];\n            // Fallback if none of the preferred positions fit within the viewport.\n            var fallback;\n            try {\n                // Go through each of the preferred positions looking for a good fit.\n                // If a good fit is found, it will be applied immediately.\n                for (var _c = tslib.__values(this._preferredPositions), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var pos = _d.value;\n                    // Get the exact (x, y) coordinate for the point-of-origin on the origin element.\n                    var originPoint = this._getOriginPoint(originRect, pos);\n                    // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the\n                    // overlay in this position. We use the top-left corner for calculations and later translate\n                    // this into an appropriate (top, left, bottom, right) style.\n                    var overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);\n                    // Calculate how well the overlay would fit into the viewport with this point.\n                    var overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);\n                    // If the overlay, without any further work, fits into the viewport, use this position.\n                    if (overlayFit.isCompletelyWithinViewport) {\n                        this._isPushed = false;\n                        this._applyPosition(pos, originPoint);\n                        return;\n                    }\n                    // If the overlay has flexible dimensions, we can use this position\n                    // so long as there's enough space for the minimum dimensions.\n                    if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {\n                        // Save positions where the overlay will fit with flexible dimensions. We will use these\n                        // if none of the positions fit *without* flexible dimensions.\n                        flexibleFits.push({\n                            position: pos,\n                            origin: originPoint,\n                            overlayRect: overlayRect,\n                            boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)\n                        });\n                        continue;\n                    }\n                    // If the current preferred position does not fit on the screen, remember the position\n                    // if it has more visible area on-screen than we've seen and move onto the next preferred\n                    // position.\n                    if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {\n                        fallback = { overlayFit: overlayFit, overlayPoint: overlayPoint, originPoint: originPoint, position: pos, overlayRect: overlayRect };\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            // If there are any positions where the overlay would fit with flexible dimensions, choose the\n            // one that has the greatest area available modified by the position's weight\n            if (flexibleFits.length) {\n                var bestFit = null;\n                var bestScore = -1;\n                try {\n                    for (var flexibleFits_1 = tslib.__values(flexibleFits), flexibleFits_1_1 = flexibleFits_1.next(); !flexibleFits_1_1.done; flexibleFits_1_1 = flexibleFits_1.next()) {\n                        var fit = flexibleFits_1_1.value;\n                        var score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);\n                        if (score > bestScore) {\n                            bestScore = score;\n                            bestFit = fit;\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (flexibleFits_1_1 && !flexibleFits_1_1.done && (_b = flexibleFits_1.return)) _b.call(flexibleFits_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n                this._isPushed = false;\n                this._applyPosition(bestFit.position, bestFit.origin);\n                return;\n            }\n            // When none of the preferred positions fit within the viewport, take the position\n            // that went off-screen the least and attempt to push it on-screen.\n            if (this._canPush) {\n                // TODO(jelbourn): after pushing, the opening \"direction\" of the overlay might not make sense.\n                this._isPushed = true;\n                this._applyPosition(fallback.position, fallback.originPoint);\n                return;\n            }\n            // All options for getting the overlay within the viewport have been exhausted, so go with the\n            // position that went off-screen the least.\n            this._applyPosition(fallback.position, fallback.originPoint);\n        };\n        FlexibleConnectedPositionStrategy.prototype.detach = function () {\n            this._clearPanelClasses();\n            this._lastPosition = null;\n            this._previousPushAmount = null;\n            this._resizeSubscription.unsubscribe();\n        };\n        /** Cleanup after the element gets destroyed. */\n        FlexibleConnectedPositionStrategy.prototype.dispose = function () {\n            if (this._isDisposed) {\n                return;\n            }\n            // We can't use `_resetBoundingBoxStyles` here, because it resets\n            // some properties to zero, rather than removing them.\n            if (this._boundingBox) {\n                extendStyles(this._boundingBox.style, {\n                    top: '',\n                    left: '',\n                    right: '',\n                    bottom: '',\n                    height: '',\n                    width: '',\n                    alignItems: '',\n                    justifyContent: '',\n                });\n            }\n            if (this._pane) {\n                this._resetOverlayElementStyles();\n            }\n            if (this._overlayRef) {\n                this._overlayRef.hostElement.classList.remove(boundingBoxClass);\n            }\n            this.detach();\n            this._positionChanges.complete();\n            this._overlayRef = this._boundingBox = null;\n            this._isDisposed = true;\n        };\n        /**\n         * This re-aligns the overlay element with the trigger in its last calculated position,\n         * even if a position higher in the \"preferred positions\" list would now fit. This\n         * allows one to re-align the panel without changing the orientation of the panel.\n         */\n        FlexibleConnectedPositionStrategy.prototype.reapplyLastPosition = function () {\n            if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) {\n                this._originRect = this._getOriginRect();\n                this._overlayRect = this._pane.getBoundingClientRect();\n                this._viewportRect = this._getNarrowedViewportRect();\n                var lastPosition = this._lastPosition || this._preferredPositions[0];\n                var originPoint = this._getOriginPoint(this._originRect, lastPosition);\n                this._applyPosition(lastPosition, originPoint);\n            }\n        };\n        /**\n         * Sets the list of Scrollable containers that host the origin element so that\n         * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n         * Scrollable must be an ancestor element of the strategy's origin element.\n         */\n        FlexibleConnectedPositionStrategy.prototype.withScrollableContainers = function (scrollables) {\n            this._scrollables = scrollables;\n            return this;\n        };\n        /**\n         * Adds new preferred positions.\n         * @param positions List of positions options for this overlay.\n         */\n        FlexibleConnectedPositionStrategy.prototype.withPositions = function (positions) {\n            this._preferredPositions = positions;\n            // If the last calculated position object isn't part of the positions anymore, clear\n            // it in order to avoid it being picked up if the consumer tries to re-apply.\n            if (positions.indexOf(this._lastPosition) === -1) {\n                this._lastPosition = null;\n            }\n            this._validatePositions();\n            return this;\n        };\n        /**\n         * Sets a minimum distance the overlay may be positioned to the edge of the viewport.\n         * @param margin Required margin between the overlay and the viewport edge in pixels.\n         */\n        FlexibleConnectedPositionStrategy.prototype.withViewportMargin = function (margin) {\n            this._viewportMargin = margin;\n            return this;\n        };\n        /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */\n        FlexibleConnectedPositionStrategy.prototype.withFlexibleDimensions = function (flexibleDimensions) {\n            if (flexibleDimensions === void 0) { flexibleDimensions = true; }\n            this._hasFlexibleDimensions = flexibleDimensions;\n            return this;\n        };\n        /** Sets whether the overlay can grow after the initial open via flexible width/height. */\n        FlexibleConnectedPositionStrategy.prototype.withGrowAfterOpen = function (growAfterOpen) {\n            if (growAfterOpen === void 0) { growAfterOpen = true; }\n            this._growAfterOpen = growAfterOpen;\n            return this;\n        };\n        /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */\n        FlexibleConnectedPositionStrategy.prototype.withPush = function (canPush) {\n            if (canPush === void 0) { canPush = true; }\n            this._canPush = canPush;\n            return this;\n        };\n        /**\n         * Sets whether the overlay's position should be locked in after it is positioned\n         * initially. When an overlay is locked in, it won't attempt to reposition itself\n         * when the position is re-applied (e.g. when the user scrolls away).\n         * @param isLocked Whether the overlay should locked in.\n         */\n        FlexibleConnectedPositionStrategy.prototype.withLockedPosition = function (isLocked) {\n            if (isLocked === void 0) { isLocked = true; }\n            this._positionLocked = isLocked;\n            return this;\n        };\n        /**\n         * Sets the origin, relative to which to position the overlay.\n         * Using an element origin is useful for building components that need to be positioned\n         * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be\n         * used for cases like contextual menus which open relative to the user's pointer.\n         * @param origin Reference to the new origin.\n         */\n        FlexibleConnectedPositionStrategy.prototype.setOrigin = function (origin) {\n            this._origin = origin;\n            return this;\n        };\n        /**\n         * Sets the default offset for the overlay's connection point on the x-axis.\n         * @param offset New offset in the X axis.\n         */\n        FlexibleConnectedPositionStrategy.prototype.withDefaultOffsetX = function (offset) {\n            this._offsetX = offset;\n            return this;\n        };\n        /**\n         * Sets the default offset for the overlay's connection point on the y-axis.\n         * @param offset New offset in the Y axis.\n         */\n        FlexibleConnectedPositionStrategy.prototype.withDefaultOffsetY = function (offset) {\n            this._offsetY = offset;\n            return this;\n        };\n        /**\n         * Configures that the position strategy should set a `transform-origin` on some elements\n         * inside the overlay, depending on the current position that is being applied. This is\n         * useful for the cases where the origin of an animation can change depending on the\n         * alignment of the overlay.\n         * @param selector CSS selector that will be used to find the target\n         *    elements onto which to set the transform origin.\n         */\n        FlexibleConnectedPositionStrategy.prototype.withTransformOriginOn = function (selector) {\n            this._transformOriginSelector = selector;\n            return this;\n        };\n        /**\n         * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n         */\n        FlexibleConnectedPositionStrategy.prototype._getOriginPoint = function (originRect, pos) {\n            var x;\n            if (pos.originX == 'center') {\n                // Note: when centering we should always use the `left`\n                // offset, otherwise the position will be wrong in RTL.\n                x = originRect.left + (originRect.width / 2);\n            }\n            else {\n                var startX = this._isRtl() ? originRect.right : originRect.left;\n                var endX = this._isRtl() ? originRect.left : originRect.right;\n                x = pos.originX == 'start' ? startX : endX;\n            }\n            var y;\n            if (pos.originY == 'center') {\n                y = originRect.top + (originRect.height / 2);\n            }\n            else {\n                y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n            }\n            return { x: x, y: y };\n        };\n        /**\n         * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n         * origin point to which the overlay should be connected.\n         */\n        FlexibleConnectedPositionStrategy.prototype._getOverlayPoint = function (originPoint, overlayRect, pos) {\n            // Calculate the (overlayStartX, overlayStartY), the start of the\n            // potential overlay position relative to the origin point.\n            var overlayStartX;\n            if (pos.overlayX == 'center') {\n                overlayStartX = -overlayRect.width / 2;\n            }\n            else if (pos.overlayX === 'start') {\n                overlayStartX = this._isRtl() ? -overlayRect.width : 0;\n            }\n            else {\n                overlayStartX = this._isRtl() ? 0 : -overlayRect.width;\n            }\n            var overlayStartY;\n            if (pos.overlayY == 'center') {\n                overlayStartY = -overlayRect.height / 2;\n            }\n            else {\n                overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n            }\n            // The (x, y) coordinates of the overlay.\n            return {\n                x: originPoint.x + overlayStartX,\n                y: originPoint.y + overlayStartY,\n            };\n        };\n        /** Gets how well an overlay at the given point will fit within the viewport. */\n        FlexibleConnectedPositionStrategy.prototype._getOverlayFit = function (point, overlay, viewport, position) {\n            var x = point.x, y = point.y;\n            var offsetX = this._getOffset(position, 'x');\n            var offsetY = this._getOffset(position, 'y');\n            // Account for the offsets since they could push the overlay out of the viewport.\n            if (offsetX) {\n                x += offsetX;\n            }\n            if (offsetY) {\n                y += offsetY;\n            }\n            // How much the overlay would overflow at this position, on each side.\n            var leftOverflow = 0 - x;\n            var rightOverflow = (x + overlay.width) - viewport.width;\n            var topOverflow = 0 - y;\n            var bottomOverflow = (y + overlay.height) - viewport.height;\n            // Visible parts of the element on each axis.\n            var visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);\n            var visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);\n            var visibleArea = visibleWidth * visibleHeight;\n            return {\n                visibleArea: visibleArea,\n                isCompletelyWithinViewport: (overlay.width * overlay.height) === visibleArea,\n                fitsInViewportVertically: visibleHeight === overlay.height,\n                fitsInViewportHorizontally: visibleWidth == overlay.width,\n            };\n        };\n        /**\n         * Whether the overlay can fit within the viewport when it may resize either its width or height.\n         * @param fit How well the overlay fits in the viewport at some position.\n         * @param point The (x, y) coordinates of the overlat at some position.\n         * @param viewport The geometry of the viewport.\n         */\n        FlexibleConnectedPositionStrategy.prototype._canFitWithFlexibleDimensions = function (fit, point, viewport) {\n            if (this._hasFlexibleDimensions) {\n                var availableHeight = viewport.bottom - point.y;\n                var availableWidth = viewport.right - point.x;\n                var minHeight = this._overlayRef.getConfig().minHeight;\n                var minWidth = this._overlayRef.getConfig().minWidth;\n                var verticalFit = fit.fitsInViewportVertically ||\n                    (minHeight != null && minHeight <= availableHeight);\n                var horizontalFit = fit.fitsInViewportHorizontally ||\n                    (minWidth != null && minWidth <= availableWidth);\n                return verticalFit && horizontalFit;\n            }\n            return false;\n        };\n        /**\n         * Gets the point at which the overlay can be \"pushed\" on-screen. If the overlay is larger than\n         * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the\n         * right and bottom).\n         *\n         * @param start Starting point from which the overlay is pushed.\n         * @param overlay Dimensions of the overlay.\n         * @param scrollPosition Current viewport scroll position.\n         * @returns The point at which to position the overlay after pushing. This is effectively a new\n         *     originPoint.\n         */\n        FlexibleConnectedPositionStrategy.prototype._pushOverlayOnScreen = function (start, overlay, scrollPosition) {\n            // If the position is locked and we've pushed the overlay already, reuse the previous push\n            // amount, rather than pushing it again. If we were to continue pushing, the element would\n            // remain in the viewport, which goes against the expectations when position locking is enabled.\n            if (this._previousPushAmount && this._positionLocked) {\n                return {\n                    x: start.x + this._previousPushAmount.x,\n                    y: start.y + this._previousPushAmount.y\n                };\n            }\n            var viewport = this._viewportRect;\n            // Determine how much the overlay goes outside the viewport on each\n            // side, which we'll use to decide which direction to push it.\n            var overflowRight = Math.max(start.x + overlay.width - viewport.right, 0);\n            var overflowBottom = Math.max(start.y + overlay.height - viewport.bottom, 0);\n            var overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);\n            var overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);\n            // Amount by which to push the overlay in each axis such that it remains on-screen.\n            var pushX = 0;\n            var pushY = 0;\n            // If the overlay fits completely within the bounds of the viewport, push it from whichever\n            // direction is goes off-screen. Otherwise, push the top-left corner such that its in the\n            // viewport and allow for the trailing end of the overlay to go out of bounds.\n            if (overlay.width <= viewport.width) {\n                pushX = overflowLeft || -overflowRight;\n            }\n            else {\n                pushX = start.x < this._viewportMargin ? (viewport.left - scrollPosition.left) - start.x : 0;\n            }\n            if (overlay.height <= viewport.height) {\n                pushY = overflowTop || -overflowBottom;\n            }\n            else {\n                pushY = start.y < this._viewportMargin ? (viewport.top - scrollPosition.top) - start.y : 0;\n            }\n            this._previousPushAmount = { x: pushX, y: pushY };\n            return {\n                x: start.x + pushX,\n                y: start.y + pushY,\n            };\n        };\n        /**\n         * Applies a computed position to the overlay and emits a position change.\n         * @param position The position preference\n         * @param originPoint The point on the origin element where the overlay is connected.\n         */\n        FlexibleConnectedPositionStrategy.prototype._applyPosition = function (position, originPoint) {\n            this._setTransformOrigin(position);\n            this._setOverlayElementStyles(originPoint, position);\n            this._setBoundingBoxStyles(originPoint, position);\n            if (position.panelClass) {\n                this._addPanelClasses(position.panelClass);\n            }\n            // Save the last connected position in case the position needs to be re-calculated.\n            this._lastPosition = position;\n            // Notify that the position has been changed along with its change properties.\n            // We only emit if we've got any subscriptions, because the scroll visibility\n            // calculcations can be somewhat expensive.\n            if (this._positionChanges.observers.length) {\n                var scrollableViewProperties = this._getScrollVisibility();\n                var changeEvent = new ConnectedOverlayPositionChange(position, scrollableViewProperties);\n                this._positionChanges.next(changeEvent);\n            }\n            this._isInitialRender = false;\n        };\n        /** Sets the transform origin based on the configured selector and the passed-in position.  */\n        FlexibleConnectedPositionStrategy.prototype._setTransformOrigin = function (position) {\n            if (!this._transformOriginSelector) {\n                return;\n            }\n            var elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);\n            var xOrigin;\n            var yOrigin = position.overlayY;\n            if (position.overlayX === 'center') {\n                xOrigin = 'center';\n            }\n            else if (this._isRtl()) {\n                xOrigin = position.overlayX === 'start' ? 'right' : 'left';\n            }\n            else {\n                xOrigin = position.overlayX === 'start' ? 'left' : 'right';\n            }\n            for (var i = 0; i < elements.length; i++) {\n                elements[i].style.transformOrigin = xOrigin + \" \" + yOrigin;\n            }\n        };\n        /**\n         * Gets the position and size of the overlay's sizing container.\n         *\n         * This method does no measuring and applies no styles so that we can cheaply compute the\n         * bounds for all positions and choose the best fit based on these results.\n         */\n        FlexibleConnectedPositionStrategy.prototype._calculateBoundingBoxRect = function (origin, position) {\n            var viewport = this._viewportRect;\n            var isRtl = this._isRtl();\n            var height, top, bottom;\n            if (position.overlayY === 'top') {\n                // Overlay is opening \"downward\" and thus is bound by the bottom viewport edge.\n                top = origin.y;\n                height = viewport.height - top + this._viewportMargin;\n            }\n            else if (position.overlayY === 'bottom') {\n                // Overlay is opening \"upward\" and thus is bound by the top viewport edge. We need to add\n                // the viewport margin back in, because the viewport rect is narrowed down to remove the\n                // margin, whereas the `origin` position is calculated based on its `ClientRect`.\n                bottom = viewport.height - origin.y + this._viewportMargin * 2;\n                height = viewport.height - bottom + this._viewportMargin;\n            }\n            else {\n                // If neither top nor bottom, it means that the overlay is vertically centered on the\n                // origin point. Note that we want the position relative to the viewport, rather than\n                // the page, which is why we don't use something like `viewport.bottom - origin.y` and\n                // `origin.y - viewport.top`.\n                var smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);\n                var previousHeight = this._lastBoundingBoxSize.height;\n                height = smallestDistanceToViewportEdge * 2;\n                top = origin.y - smallestDistanceToViewportEdge;\n                if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {\n                    top = origin.y - (previousHeight / 2);\n                }\n            }\n            // The overlay is opening 'right-ward' (the content flows to the right).\n            var isBoundedByRightViewportEdge = (position.overlayX === 'start' && !isRtl) ||\n                (position.overlayX === 'end' && isRtl);\n            // The overlay is opening 'left-ward' (the content flows to the left).\n            var isBoundedByLeftViewportEdge = (position.overlayX === 'end' && !isRtl) ||\n                (position.overlayX === 'start' && isRtl);\n            var width, left, right;\n            if (isBoundedByLeftViewportEdge) {\n                right = viewport.width - origin.x + this._viewportMargin;\n                width = origin.x - this._viewportMargin;\n            }\n            else if (isBoundedByRightViewportEdge) {\n                left = origin.x;\n                width = viewport.right - origin.x;\n            }\n            else {\n                // If neither start nor end, it means that the overlay is horizontally centered on the\n                // origin point. Note that we want the position relative to the viewport, rather than\n                // the page, which is why we don't use something like `viewport.right - origin.x` and\n                // `origin.x - viewport.left`.\n                var smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);\n                var previousWidth = this._lastBoundingBoxSize.width;\n                width = smallestDistanceToViewportEdge * 2;\n                left = origin.x - smallestDistanceToViewportEdge;\n                if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {\n                    left = origin.x - (previousWidth / 2);\n                }\n            }\n            return { top: top, left: left, bottom: bottom, right: right, width: width, height: height };\n        };\n        /**\n         * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the\n         * origin's connection point and stetches to the bounds of the viewport.\n         *\n         * @param origin The point on the origin element where the overlay is connected.\n         * @param position The position preference\n         */\n        FlexibleConnectedPositionStrategy.prototype._setBoundingBoxStyles = function (origin, position) {\n            var boundingBoxRect = this._calculateBoundingBoxRect(origin, position);\n            // It's weird if the overlay *grows* while scrolling, so we take the last size into account\n            // when applying a new size.\n            if (!this._isInitialRender && !this._growAfterOpen) {\n                boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);\n                boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);\n            }\n            var styles = {};\n            if (this._hasExactPosition()) {\n                styles.top = styles.left = '0';\n                styles.bottom = styles.right = styles.maxHeight = styles.maxWidth = '';\n                styles.width = styles.height = '100%';\n            }\n            else {\n                var maxHeight = this._overlayRef.getConfig().maxHeight;\n                var maxWidth = this._overlayRef.getConfig().maxWidth;\n                styles.height = coercion.coerceCssPixelValue(boundingBoxRect.height);\n                styles.top = coercion.coerceCssPixelValue(boundingBoxRect.top);\n                styles.bottom = coercion.coerceCssPixelValue(boundingBoxRect.bottom);\n                styles.width = coercion.coerceCssPixelValue(boundingBoxRect.width);\n                styles.left = coercion.coerceCssPixelValue(boundingBoxRect.left);\n                styles.right = coercion.coerceCssPixelValue(boundingBoxRect.right);\n                // Push the pane content towards the proper direction.\n                if (position.overlayX === 'center') {\n                    styles.alignItems = 'center';\n                }\n                else {\n                    styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';\n                }\n                if (position.overlayY === 'center') {\n                    styles.justifyContent = 'center';\n                }\n                else {\n                    styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';\n                }\n                if (maxHeight) {\n                    styles.maxHeight = coercion.coerceCssPixelValue(maxHeight);\n                }\n                if (maxWidth) {\n                    styles.maxWidth = coercion.coerceCssPixelValue(maxWidth);\n                }\n            }\n            this._lastBoundingBoxSize = boundingBoxRect;\n            extendStyles(this._boundingBox.style, styles);\n        };\n        /** Resets the styles for the bounding box so that a new positioning can be computed. */\n        FlexibleConnectedPositionStrategy.prototype._resetBoundingBoxStyles = function () {\n            extendStyles(this._boundingBox.style, {\n                top: '0',\n                left: '0',\n                right: '0',\n                bottom: '0',\n                height: '',\n                width: '',\n                alignItems: '',\n                justifyContent: '',\n            });\n        };\n        /** Resets the styles for the overlay pane so that a new positioning can be computed. */\n        FlexibleConnectedPositionStrategy.prototype._resetOverlayElementStyles = function () {\n            extendStyles(this._pane.style, {\n                top: '',\n                left: '',\n                bottom: '',\n                right: '',\n                position: '',\n                transform: '',\n            });\n        };\n        /** Sets positioning styles to the overlay element. */\n        FlexibleConnectedPositionStrategy.prototype._setOverlayElementStyles = function (originPoint, position) {\n            var styles = {};\n            var hasExactPosition = this._hasExactPosition();\n            var hasFlexibleDimensions = this._hasFlexibleDimensions;\n            var config = this._overlayRef.getConfig();\n            if (hasExactPosition) {\n                var scrollPosition = this._viewportRuler.getViewportScrollPosition();\n                extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));\n                extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));\n            }\n            else {\n                styles.position = 'static';\n            }\n            // Use a transform to apply the offsets. We do this because the `center` positions rely on\n            // being in the normal flex flow and setting a `top` / `left` at all will completely throw\n            // off the position. We also can't use margins, because they won't have an effect in some\n            // cases where the element doesn't have anything to \"push off of\". Finally, this works\n            // better both with flexible and non-flexible positioning.\n            var transformString = '';\n            var offsetX = this._getOffset(position, 'x');\n            var offsetY = this._getOffset(position, 'y');\n            if (offsetX) {\n                transformString += \"translateX(\" + offsetX + \"px) \";\n            }\n            if (offsetY) {\n                transformString += \"translateY(\" + offsetY + \"px)\";\n            }\n            styles.transform = transformString.trim();\n            // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because\n            // we need these values to both be set to \"100%\" for the automatic flexible sizing to work.\n            // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.\n            // Note that this doesn't apply when we have an exact position, in which case we do want to\n            // apply them because they'll be cleared from the bounding box.\n            if (config.maxHeight) {\n                if (hasExactPosition) {\n                    styles.maxHeight = coercion.coerceCssPixelValue(config.maxHeight);\n                }\n                else if (hasFlexibleDimensions) {\n                    styles.maxHeight = '';\n                }\n            }\n            if (config.maxWidth) {\n                if (hasExactPosition) {\n                    styles.maxWidth = coercion.coerceCssPixelValue(config.maxWidth);\n                }\n                else if (hasFlexibleDimensions) {\n                    styles.maxWidth = '';\n                }\n            }\n            extendStyles(this._pane.style, styles);\n        };\n        /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */\n        FlexibleConnectedPositionStrategy.prototype._getExactOverlayY = function (position, originPoint, scrollPosition) {\n            // Reset any existing styles. This is necessary in case the\n            // preferred position has changed since the last `apply`.\n            var styles = { top: null, bottom: null };\n            var overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n            if (this._isPushed) {\n                overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n            }\n            var virtualKeyboardOffset = this._overlayContainer.getContainerElement().getBoundingClientRect().top;\n            // Normally this would be zero, however when the overlay is attached to an input (e.g. in an\n            // autocomplete), mobile browsers will shift everything in order to put the input in the middle\n            // of the screen and to make space for the virtual keyboard. We need to account for this offset,\n            // otherwise our positioning will be thrown off.\n            overlayPoint.y -= virtualKeyboardOffset;\n            // We want to set either `top` or `bottom` based on whether the overlay wants to appear\n            // above or below the origin and the direction in which the element will expand.\n            if (position.overlayY === 'bottom') {\n                // When using `bottom`, we adjust the y position such that it is the distance\n                // from the bottom of the viewport rather than the top.\n                var documentHeight = this._document.documentElement.clientHeight;\n                styles.bottom = documentHeight - (overlayPoint.y + this._overlayRect.height) + \"px\";\n            }\n            else {\n                styles.top = coercion.coerceCssPixelValue(overlayPoint.y);\n            }\n            return styles;\n        };\n        /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */\n        FlexibleConnectedPositionStrategy.prototype._getExactOverlayX = function (position, originPoint, scrollPosition) {\n            // Reset any existing styles. This is necessary in case the preferred position has\n            // changed since the last `apply`.\n            var styles = { left: null, right: null };\n            var overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n            if (this._isPushed) {\n                overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n            }\n            // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n            // or \"after\" the origin, which determines the direction in which the element will expand.\n            // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n            // page is in RTL or LTR.\n            var horizontalStyleProperty;\n            if (this._isRtl()) {\n                horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';\n            }\n            else {\n                horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';\n            }\n            // When we're setting `right`, we adjust the x position such that it is the distance\n            // from the right edge of the viewport rather than the left edge.\n            if (horizontalStyleProperty === 'right') {\n                var documentWidth = this._document.documentElement.clientWidth;\n                styles.right = documentWidth - (overlayPoint.x + this._overlayRect.width) + \"px\";\n            }\n            else {\n                styles.left = coercion.coerceCssPixelValue(overlayPoint.x);\n            }\n            return styles;\n        };\n        /**\n         * Gets the view properties of the trigger and overlay, including whether they are clipped\n         * or completely outside the view of any of the strategy's scrollables.\n         */\n        FlexibleConnectedPositionStrategy.prototype._getScrollVisibility = function () {\n            // Note: needs fresh rects since the position could've changed.\n            var originBounds = this._getOriginRect();\n            var overlayBounds = this._pane.getBoundingClientRect();\n            // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers\n            // every time, we should be able to use the scrollTop of the containers if the size of those\n            // containers hasn't changed.\n            var scrollContainerBounds = this._scrollables.map(function (scrollable) {\n                return scrollable.getElementRef().nativeElement.getBoundingClientRect();\n            });\n            return {\n                isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n                isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n                isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n                isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n            };\n        };\n        /** Subtracts the amount that an element is overflowing on an axis from its length. */\n        FlexibleConnectedPositionStrategy.prototype._subtractOverflows = function (length) {\n            var overflows = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                overflows[_i - 1] = arguments[_i];\n            }\n            return overflows.reduce(function (currentValue, currentOverflow) {\n                return currentValue - Math.max(currentOverflow, 0);\n            }, length);\n        };\n        /** Narrows the given viewport rect by the current _viewportMargin. */\n        FlexibleConnectedPositionStrategy.prototype._getNarrowedViewportRect = function () {\n            // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,\n            // because we want to use the `clientWidth` and `clientHeight` as the base. The difference\n            // being that the client properties don't include the scrollbar, as opposed to `innerWidth`\n            // and `innerHeight` that do. This is necessary, because the overlay container uses\n            // 100% `width` and `height` which don't include the scrollbar either.\n            var width = this._document.documentElement.clientWidth;\n            var height = this._document.documentElement.clientHeight;\n            var scrollPosition = this._viewportRuler.getViewportScrollPosition();\n            return {\n                top: scrollPosition.top + this._viewportMargin,\n                left: scrollPosition.left + this._viewportMargin,\n                right: scrollPosition.left + width - this._viewportMargin,\n                bottom: scrollPosition.top + height - this._viewportMargin,\n                width: width - (2 * this._viewportMargin),\n                height: height - (2 * this._viewportMargin),\n            };\n        };\n        /** Whether the we're dealing with an RTL context */\n        FlexibleConnectedPositionStrategy.prototype._isRtl = function () {\n            return this._overlayRef.getDirection() === 'rtl';\n        };\n        /** Determines whether the overlay uses exact or flexible positioning. */\n        FlexibleConnectedPositionStrategy.prototype._hasExactPosition = function () {\n            return !this._hasFlexibleDimensions || this._isPushed;\n        };\n        /** Retrieves the offset of a position along the x or y axis. */\n        FlexibleConnectedPositionStrategy.prototype._getOffset = function (position, axis) {\n            if (axis === 'x') {\n                // We don't do something like `position['offset' + axis]` in\n                // order to avoid breking minifiers that rename properties.\n                return position.offsetX == null ? this._offsetX : position.offsetX;\n            }\n            return position.offsetY == null ? this._offsetY : position.offsetY;\n        };\n        /** Validates that the current position match the expected values. */\n        FlexibleConnectedPositionStrategy.prototype._validatePositions = function () {\n            if (!this._preferredPositions.length) {\n                throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');\n            }\n            // TODO(crisbeto): remove these once Angular's template type\n            // checking is advanced enough to catch these cases.\n            this._preferredPositions.forEach(function (pair) {\n                validateHorizontalPosition('originX', pair.originX);\n                validateVerticalPosition('originY', pair.originY);\n                validateHorizontalPosition('overlayX', pair.overlayX);\n                validateVerticalPosition('overlayY', pair.overlayY);\n            });\n        };\n        /** Adds a single CSS class or an array of classes on the overlay panel. */\n        FlexibleConnectedPositionStrategy.prototype._addPanelClasses = function (cssClasses) {\n            var _this = this;\n            if (this._pane) {\n                coercion.coerceArray(cssClasses).forEach(function (cssClass) {\n                    if (cssClass !== '' && _this._appliedPanelClasses.indexOf(cssClass) === -1) {\n                        _this._appliedPanelClasses.push(cssClass);\n                        _this._pane.classList.add(cssClass);\n                    }\n                });\n            }\n        };\n        /** Clears the classes that the position strategy has applied from the overlay panel. */\n        FlexibleConnectedPositionStrategy.prototype._clearPanelClasses = function () {\n            var _this = this;\n            if (this._pane) {\n                this._appliedPanelClasses.forEach(function (cssClass) {\n                    _this._pane.classList.remove(cssClass);\n                });\n                this._appliedPanelClasses = [];\n            }\n        };\n        /** Returns the ClientRect of the current origin. */\n        FlexibleConnectedPositionStrategy.prototype._getOriginRect = function () {\n            var origin = this._origin;\n            if (origin instanceof i0.ElementRef) {\n                return origin.nativeElement.getBoundingClientRect();\n            }\n            if (origin instanceof HTMLElement) {\n                return origin.getBoundingClientRect();\n            }\n            var width = origin.width || 0;\n            var height = origin.height || 0;\n            // If the origin is a point, return a client rect as if it was a 0x0 element at the point.\n            return {\n                top: origin.y,\n                bottom: origin.y + height,\n                left: origin.x,\n                right: origin.x + width,\n                height: height,\n                width: width\n            };\n        };\n        return FlexibleConnectedPositionStrategy;\n    }());\n    /** Shallow-extends a stylesheet object with another stylesheet object. */\n    function extendStyles(dest, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                dest[key] = source[key];\n            }\n        }\n        return dest;\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * A strategy for positioning overlays. Using this strategy, an overlay is given an\n     * implicit position relative to some origin element. The relative position is defined in terms of\n     * a point on the origin element that is connected to a point on the overlay element. For example,\n     * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n     * of the overlay.\n     * @deprecated Use `FlexibleConnectedPositionStrategy` instead.\n     * @breaking-change 8.0.0\n     */\n    var ConnectedPositionStrategy = /** @class */ (function () {\n        function ConnectedPositionStrategy(originPos, overlayPos, connectedTo, viewportRuler, document, platform, overlayContainer) {\n            /** Ordered list of preferred positions, from most to least desirable. */\n            this._preferredPositions = [];\n            // Since the `ConnectedPositionStrategy` is deprecated and we don't want to maintain\n            // the extra logic, we create an instance of the positioning strategy that has some\n            // defaults that make it behave as the old position strategy and to which we'll\n            // proxy all of the API calls.\n            this._positionStrategy = new FlexibleConnectedPositionStrategy(connectedTo, viewportRuler, document, platform, overlayContainer)\n                .withFlexibleDimensions(false)\n                .withPush(false)\n                .withViewportMargin(0);\n            this.withFallbackPosition(originPos, overlayPos);\n        }\n        Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\n            /** Whether the we're dealing with an RTL context */\n            get: function () {\n                return this._overlayRef.getDirection() === 'rtl';\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\n            /** Emits an event when the connection point changes. */\n            get: function () {\n                return this._positionStrategy.positionChanges;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n            /** Ordered list of preferred positions, from most to least desirable. */\n            get: function () {\n                return this._preferredPositions;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Attach this position strategy to an overlay. */\n        ConnectedPositionStrategy.prototype.attach = function (overlayRef) {\n            this._overlayRef = overlayRef;\n            this._positionStrategy.attach(overlayRef);\n            if (this._direction) {\n                overlayRef.setDirection(this._direction);\n                this._direction = null;\n            }\n        };\n        /** Disposes all resources used by the position strategy. */\n        ConnectedPositionStrategy.prototype.dispose = function () {\n            this._positionStrategy.dispose();\n        };\n        /** @docs-private */\n        ConnectedPositionStrategy.prototype.detach = function () {\n            this._positionStrategy.detach();\n        };\n        /**\n         * Updates the position of the overlay element, using whichever preferred position relative\n         * to the origin fits on-screen.\n         * @docs-private\n         */\n        ConnectedPositionStrategy.prototype.apply = function () {\n            this._positionStrategy.apply();\n        };\n        /**\n         * Re-positions the overlay element with the trigger in its last calculated position,\n         * even if a position higher in the \"preferred positions\" list would now fit. This\n         * allows one to re-align the panel without changing the orientation of the panel.\n         */\n        ConnectedPositionStrategy.prototype.recalculateLastPosition = function () {\n            this._positionStrategy.reapplyLastPosition();\n        };\n        /**\n         * Sets the list of Scrollable containers that host the origin element so that\n         * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n         * Scrollable must be an ancestor element of the strategy's origin element.\n         */\n        ConnectedPositionStrategy.prototype.withScrollableContainers = function (scrollables) {\n            this._positionStrategy.withScrollableContainers(scrollables);\n        };\n        /**\n         * Adds a new preferred fallback position.\n         * @param originPos\n         * @param overlayPos\n         */\n        ConnectedPositionStrategy.prototype.withFallbackPosition = function (originPos, overlayPos, offsetX, offsetY) {\n            var position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n            this._preferredPositions.push(position);\n            this._positionStrategy.withPositions(this._preferredPositions);\n            return this;\n        };\n        /**\n         * Sets the layout direction so the overlay's position can be adjusted to match.\n         * @param dir New layout direction.\n         */\n        ConnectedPositionStrategy.prototype.withDirection = function (dir) {\n            // Since the direction might be declared before the strategy is attached,\n            // we save the value in a temporary property and we'll transfer it to the\n            // overlay ref on attachment.\n            if (this._overlayRef) {\n                this._overlayRef.setDirection(dir);\n            }\n            else {\n                this._direction = dir;\n            }\n            return this;\n        };\n        /**\n         * Sets an offset for the overlay's connection point on the x-axis\n         * @param offset New offset in the X axis.\n         */\n        ConnectedPositionStrategy.prototype.withOffsetX = function (offset) {\n            this._positionStrategy.withDefaultOffsetX(offset);\n            return this;\n        };\n        /**\n         * Sets an offset for the overlay's connection point on the y-axis\n         * @param  offset New offset in the Y axis.\n         */\n        ConnectedPositionStrategy.prototype.withOffsetY = function (offset) {\n            this._positionStrategy.withDefaultOffsetY(offset);\n            return this;\n        };\n        /**\n         * Sets whether the overlay's position should be locked in after it is positioned\n         * initially. When an overlay is locked in, it won't attempt to reposition itself\n         * when the position is re-applied (e.g. when the user scrolls away).\n         * @param isLocked Whether the overlay should locked in.\n         */\n        ConnectedPositionStrategy.prototype.withLockedPosition = function (isLocked) {\n            this._positionStrategy.withLockedPosition(isLocked);\n            return this;\n        };\n        /**\n         * Overwrites the current set of positions with an array of new ones.\n         * @param positions Position pairs to be set on the strategy.\n         */\n        ConnectedPositionStrategy.prototype.withPositions = function (positions) {\n            this._preferredPositions = positions.slice();\n            this._positionStrategy.withPositions(this._preferredPositions);\n            return this;\n        };\n        /**\n         * Sets the origin element, relative to which to position the overlay.\n         * @param origin Reference to the new origin element.\n         */\n        ConnectedPositionStrategy.prototype.setOrigin = function (origin) {\n            this._positionStrategy.setOrigin(origin);\n            return this;\n        };\n        return ConnectedPositionStrategy;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Class to be added to the overlay pane wrapper. */\n    var wrapperClass = 'cdk-global-overlay-wrapper';\n    /**\n     * A strategy for positioning overlays. Using this strategy, an overlay is given an\n     * explicit position relative to the browser's viewport. We use flexbox, instead of\n     * transforms, in order to avoid issues with subpixel rendering which can cause the\n     * element to become blurry.\n     */\n    var GlobalPositionStrategy = /** @class */ (function () {\n        function GlobalPositionStrategy() {\n            this._cssPosition = 'static';\n            this._topOffset = '';\n            this._bottomOffset = '';\n            this._leftOffset = '';\n            this._rightOffset = '';\n            this._alignItems = '';\n            this._justifyContent = '';\n            this._width = '';\n            this._height = '';\n        }\n        GlobalPositionStrategy.prototype.attach = function (overlayRef) {\n            var config = overlayRef.getConfig();\n            this._overlayRef = overlayRef;\n            if (this._width && !config.width) {\n                overlayRef.updateSize({ width: this._width });\n            }\n            if (this._height && !config.height) {\n                overlayRef.updateSize({ height: this._height });\n            }\n            overlayRef.hostElement.classList.add(wrapperClass);\n            this._isDisposed = false;\n        };\n        /**\n         * Sets the top position of the overlay. Clears any previously set vertical position.\n         * @param value New top offset.\n         */\n        GlobalPositionStrategy.prototype.top = function (value) {\n            if (value === void 0) { value = ''; }\n            this._bottomOffset = '';\n            this._topOffset = value;\n            this._alignItems = 'flex-start';\n            return this;\n        };\n        /**\n         * Sets the left position of the overlay. Clears any previously set horizontal position.\n         * @param value New left offset.\n         */\n        GlobalPositionStrategy.prototype.left = function (value) {\n            if (value === void 0) { value = ''; }\n            this._rightOffset = '';\n            this._leftOffset = value;\n            this._justifyContent = 'flex-start';\n            return this;\n        };\n        /**\n         * Sets the bottom position of the overlay. Clears any previously set vertical position.\n         * @param value New bottom offset.\n         */\n        GlobalPositionStrategy.prototype.bottom = function (value) {\n            if (value === void 0) { value = ''; }\n            this._topOffset = '';\n            this._bottomOffset = value;\n            this._alignItems = 'flex-end';\n            return this;\n        };\n        /**\n         * Sets the right position of the overlay. Clears any previously set horizontal position.\n         * @param value New right offset.\n         */\n        GlobalPositionStrategy.prototype.right = function (value) {\n            if (value === void 0) { value = ''; }\n            this._leftOffset = '';\n            this._rightOffset = value;\n            this._justifyContent = 'flex-end';\n            return this;\n        };\n        /**\n         * Sets the overlay width and clears any previously set width.\n         * @param value New width for the overlay\n         * @deprecated Pass the `width` through the `OverlayConfig`.\n         * @breaking-change 8.0.0\n         */\n        GlobalPositionStrategy.prototype.width = function (value) {\n            if (value === void 0) { value = ''; }\n            if (this._overlayRef) {\n                this._overlayRef.updateSize({ width: value });\n            }\n            else {\n                this._width = value;\n            }\n            return this;\n        };\n        /**\n         * Sets the overlay height and clears any previously set height.\n         * @param value New height for the overlay\n         * @deprecated Pass the `height` through the `OverlayConfig`.\n         * @breaking-change 8.0.0\n         */\n        GlobalPositionStrategy.prototype.height = function (value) {\n            if (value === void 0) { value = ''; }\n            if (this._overlayRef) {\n                this._overlayRef.updateSize({ height: value });\n            }\n            else {\n                this._height = value;\n            }\n            return this;\n        };\n        /**\n         * Centers the overlay horizontally with an optional offset.\n         * Clears any previously set horizontal position.\n         *\n         * @param offset Overlay offset from the horizontal center.\n         */\n        GlobalPositionStrategy.prototype.centerHorizontally = function (offset) {\n            if (offset === void 0) { offset = ''; }\n            this.left(offset);\n            this._justifyContent = 'center';\n            return this;\n        };\n        /**\n         * Centers the overlay vertically with an optional offset.\n         * Clears any previously set vertical position.\n         *\n         * @param offset Overlay offset from the vertical center.\n         */\n        GlobalPositionStrategy.prototype.centerVertically = function (offset) {\n            if (offset === void 0) { offset = ''; }\n            this.top(offset);\n            this._alignItems = 'center';\n            return this;\n        };\n        /**\n         * Apply the position to the element.\n         * @docs-private\n         */\n        GlobalPositionStrategy.prototype.apply = function () {\n            // Since the overlay ref applies the strategy asynchronously, it could\n            // have been disposed before it ends up being applied. If that is the\n            // case, we shouldn't do anything.\n            if (!this._overlayRef || !this._overlayRef.hasAttached()) {\n                return;\n            }\n            var styles = this._overlayRef.overlayElement.style;\n            var parentStyles = this._overlayRef.hostElement.style;\n            var config = this._overlayRef.getConfig();\n            styles.position = this._cssPosition;\n            styles.marginLeft = config.width === '100%' ? '0' : this._leftOffset;\n            styles.marginTop = config.height === '100%' ? '0' : this._topOffset;\n            styles.marginBottom = this._bottomOffset;\n            styles.marginRight = this._rightOffset;\n            if (config.width === '100%') {\n                parentStyles.justifyContent = 'flex-start';\n            }\n            else if (this._justifyContent === 'center') {\n                parentStyles.justifyContent = 'center';\n            }\n            else if (this._overlayRef.getConfig().direction === 'rtl') {\n                // In RTL the browser will invert `flex-start` and `flex-end` automatically, but we\n                // don't want that because our positioning is explicitly `left` and `right`, hence\n                // why we do another inversion to ensure that the overlay stays in the same position.\n                // TODO: reconsider this if we add `start` and `end` methods.\n                if (this._justifyContent === 'flex-start') {\n                    parentStyles.justifyContent = 'flex-end';\n                }\n                else if (this._justifyContent === 'flex-end') {\n                    parentStyles.justifyContent = 'flex-start';\n                }\n            }\n            else {\n                parentStyles.justifyContent = this._justifyContent;\n            }\n            parentStyles.alignItems = config.height === '100%' ? 'flex-start' : this._alignItems;\n        };\n        /**\n         * Cleans up the DOM changes from the position strategy.\n         * @docs-private\n         */\n        GlobalPositionStrategy.prototype.dispose = function () {\n            if (this._isDisposed || !this._overlayRef) {\n                return;\n            }\n            var styles = this._overlayRef.overlayElement.style;\n            var parent = this._overlayRef.hostElement;\n            var parentStyles = parent.style;\n            parent.classList.remove(wrapperClass);\n            parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop =\n                styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = '';\n            this._overlayRef = null;\n            this._isDisposed = true;\n        };\n        return GlobalPositionStrategy;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Builder for overlay position strategy. */\n    var OverlayPositionBuilder = /** @class */ (function () {\n        function OverlayPositionBuilder(_viewportRuler, _document, _platform, _overlayContainer) {\n            this._viewportRuler = _viewportRuler;\n            this._document = _document;\n            this._platform = _platform;\n            this._overlayContainer = _overlayContainer;\n        }\n        /**\n         * Creates a global position strategy.\n         */\n        OverlayPositionBuilder.prototype.global = function () {\n            return new GlobalPositionStrategy();\n        };\n        /**\n         * Creates a relative position strategy.\n         * @param elementRef\n         * @param originPos\n         * @param overlayPos\n         * @deprecated Use `flexibleConnectedTo` instead.\n         * @breaking-change 8.0.0\n         */\n        OverlayPositionBuilder.prototype.connectedTo = function (elementRef, originPos, overlayPos) {\n            return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document, this._platform, this._overlayContainer);\n        };\n        /**\n         * Creates a flexible position strategy.\n         * @param origin Origin relative to which to position the overlay.\n         */\n        OverlayPositionBuilder.prototype.flexibleConnectedTo = function (origin) {\n            return new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);\n        };\n        OverlayPositionBuilder.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        OverlayPositionBuilder.ctorParameters = function () { return [\n            { type: scrolling.ViewportRuler },\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] },\n            { type: platform.Platform },\n            { type: OverlayContainer }\n        ]; };\n        OverlayPositionBuilder.ɵprov = i0.ɵɵdefineInjectable({ factory: function OverlayPositionBuilder_Factory() { return new OverlayPositionBuilder(i0.ɵɵinject(ViewportRuler), i0.ɵɵinject(i1.DOCUMENT), i0.ɵɵinject(Platform), i0.ɵɵinject(OverlayContainer)); }, token: OverlayPositionBuilder, providedIn: \"root\" });\n        return OverlayPositionBuilder;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Next overlay unique ID. */\n    var nextUniqueId = 0;\n    // Note that Overlay is *not* scoped to the app root because of the ComponentFactoryResolver\n    // which needs to be different depending on where OverlayModule is imported.\n    /**\n     * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n     * used as a low-level building block for other components. Dialogs, tooltips, menus,\n     * selects, etc. can all be built using overlays. The service should primarily be used by authors\n     * of re-usable components rather than developers building end-user applications.\n     *\n     * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n     */\n    var Overlay = /** @class */ (function () {\n        function Overlay(\n        /** Scrolling strategies that can be used when creating an overlay. */\n        scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, \n        // @breaking-change 8.0.0 `_location` parameter to be made required.\n        _location) {\n            this.scrollStrategies = scrollStrategies;\n            this._overlayContainer = _overlayContainer;\n            this._componentFactoryResolver = _componentFactoryResolver;\n            this._positionBuilder = _positionBuilder;\n            this._keyboardDispatcher = _keyboardDispatcher;\n            this._injector = _injector;\n            this._ngZone = _ngZone;\n            this._document = _document;\n            this._directionality = _directionality;\n            this._location = _location;\n        }\n        /**\n         * Creates an overlay.\n         * @param config Configuration applied to the overlay.\n         * @returns Reference to the created overlay.\n         */\n        Overlay.prototype.create = function (config) {\n            var host = this._createHostElement();\n            var pane = this._createPaneElement(host);\n            var portalOutlet = this._createPortalOutlet(pane);\n            var overlayConfig = new OverlayConfig(config);\n            overlayConfig.direction = overlayConfig.direction || this._directionality.value;\n            return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location);\n        };\n        /**\n         * Gets a position builder that can be used, via fluent API,\n         * to construct and configure a position strategy.\n         * @returns An overlay position builder.\n         */\n        Overlay.prototype.position = function () {\n            return this._positionBuilder;\n        };\n        /**\n         * Creates the DOM element for an overlay and appends it to the overlay container.\n         * @returns Newly-created pane element\n         */\n        Overlay.prototype._createPaneElement = function (host) {\n            var pane = this._document.createElement('div');\n            pane.id = \"cdk-overlay-\" + nextUniqueId++;\n            pane.classList.add('cdk-overlay-pane');\n            host.appendChild(pane);\n            return pane;\n        };\n        /**\n         * Creates the host element that wraps around an overlay\n         * and can be used for advanced positioning.\n         * @returns Newly-create host element.\n         */\n        Overlay.prototype._createHostElement = function () {\n            var host = this._document.createElement('div');\n            this._overlayContainer.getContainerElement().appendChild(host);\n            return host;\n        };\n        /**\n         * Create a DomPortalOutlet into which the overlay content can be loaded.\n         * @param pane The DOM element to turn into a portal outlet.\n         * @returns A portal outlet for the given DOM element.\n         */\n        Overlay.prototype._createPortalOutlet = function (pane) {\n            // We have to resolve the ApplicationRef later in order to allow people\n            // to use overlay-based providers during app initialization.\n            if (!this._appRef) {\n                this._appRef = this._injector.get(i0.ApplicationRef);\n            }\n            return new portal.DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector, this._document);\n        };\n        Overlay.decorators = [\n            { type: i0.Injectable }\n        ];\n        /** @nocollapse */\n        Overlay.ctorParameters = function () { return [\n            { type: ScrollStrategyOptions },\n            { type: OverlayContainer },\n            { type: i0.ComponentFactoryResolver },\n            { type: OverlayPositionBuilder },\n            { type: OverlayKeyboardDispatcher },\n            { type: i0.Injector },\n            { type: i0.NgZone },\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] },\n            { type: bidi.Directionality },\n            { type: i1.Location, decorators: [{ type: i0.Optional }] }\n        ]; };\n        return Overlay;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Default set of positions for the overlay. Follows the behavior of a dropdown. */\n    var defaultPositionList = [\n        {\n            originX: 'start',\n            originY: 'bottom',\n            overlayX: 'start',\n            overlayY: 'top'\n        },\n        {\n            originX: 'start',\n            originY: 'top',\n            overlayX: 'start',\n            overlayY: 'bottom'\n        },\n        {\n            originX: 'end',\n            originY: 'top',\n            overlayX: 'end',\n            overlayY: 'bottom'\n        },\n        {\n            originX: 'end',\n            originY: 'bottom',\n            overlayX: 'end',\n            overlayY: 'top'\n        }\n    ];\n    /** Injection token that determines the scroll handling while the connected overlay is open. */\n    var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new i0.InjectionToken('cdk-connected-overlay-scroll-strategy');\n    /** @docs-private @deprecated @breaking-change 8.0.0 */\n    function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_FACTORY(overlay) {\n        return function (config) { return overlay.scrollStrategies.reposition(config); };\n    }\n    /**\n     * Directive applied to an element to make it usable as an origin for an Overlay using a\n     * ConnectedPositionStrategy.\n     */\n    var CdkOverlayOrigin = /** @class */ (function () {\n        function CdkOverlayOrigin(\n        /** Reference to the element on which the directive is applied. */\n        elementRef) {\n            this.elementRef = elementRef;\n        }\n        CdkOverlayOrigin.decorators = [\n            { type: i0.Directive, args: [{\n                        selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                        exportAs: 'cdkOverlayOrigin',\n                    },] }\n        ];\n        /** @nocollapse */\n        CdkOverlayOrigin.ctorParameters = function () { return [\n            { type: i0.ElementRef }\n        ]; };\n        return CdkOverlayOrigin;\n    }());\n    /**\n     * Directive to facilitate declarative creation of an\n     * Overlay using a FlexibleConnectedPositionStrategy.\n     */\n    var CdkConnectedOverlay = /** @class */ (function () {\n        // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n        function CdkConnectedOverlay(_overlay, templateRef, viewContainerRef, scrollStrategyFactory, _dir) {\n            this._overlay = _overlay;\n            this._dir = _dir;\n            this._hasBackdrop = false;\n            this._lockPosition = false;\n            this._growAfterOpen = false;\n            this._flexibleDimensions = false;\n            this._push = false;\n            this._backdropSubscription = rxjs.Subscription.EMPTY;\n            /** Margin between the overlay and the viewport edges. */\n            this.viewportMargin = 0;\n            /** Whether the overlay is open. */\n            this.open = false;\n            /** Event emitted when the backdrop is clicked. */\n            this.backdropClick = new i0.EventEmitter();\n            /** Event emitted when the position has changed. */\n            this.positionChange = new i0.EventEmitter();\n            /** Event emitted when the overlay has been attached. */\n            this.attach = new i0.EventEmitter();\n            /** Event emitted when the overlay has been detached. */\n            this.detach = new i0.EventEmitter();\n            /** Emits when there are keyboard events that are targeted at the overlay. */\n            this.overlayKeydown = new i0.EventEmitter();\n            this._templatePortal = new portal.TemplatePortal(templateRef, viewContainerRef);\n            this._scrollStrategyFactory = scrollStrategyFactory;\n            this.scrollStrategy = this._scrollStrategyFactory();\n        }\n        Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetX\", {\n            /** The offset in pixels for the overlay connection point on the x-axis */\n            get: function () { return this._offsetX; },\n            set: function (offsetX) {\n                this._offsetX = offsetX;\n                if (this._position) {\n                    this._updatePositionStrategy(this._position);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetY\", {\n            /** The offset in pixels for the overlay connection point on the y-axis */\n            get: function () { return this._offsetY; },\n            set: function (offsetY) {\n                this._offsetY = offsetY;\n                if (this._position) {\n                    this._updatePositionStrategy(this._position);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CdkConnectedOverlay.prototype, \"hasBackdrop\", {\n            /** Whether or not the overlay should attach a backdrop. */\n            get: function () { return this._hasBackdrop; },\n            set: function (value) { this._hasBackdrop = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CdkConnectedOverlay.prototype, \"lockPosition\", {\n            /** Whether or not the overlay should be locked when scrolling. */\n            get: function () { return this._lockPosition; },\n            set: function (value) { this._lockPosition = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CdkConnectedOverlay.prototype, \"flexibleDimensions\", {\n            /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n            get: function () { return this._flexibleDimensions; },\n            set: function (value) {\n                this._flexibleDimensions = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CdkConnectedOverlay.prototype, \"growAfterOpen\", {\n            /** Whether the overlay can grow after the initial open when flexible positioning is turned on. */\n            get: function () { return this._growAfterOpen; },\n            set: function (value) { this._growAfterOpen = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CdkConnectedOverlay.prototype, \"push\", {\n            /** Whether the overlay can be pushed on-screen if none of the provided positions fit. */\n            get: function () { return this._push; },\n            set: function (value) { this._push = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CdkConnectedOverlay.prototype, \"overlayRef\", {\n            /** The associated overlay reference. */\n            get: function () {\n                return this._overlayRef;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CdkConnectedOverlay.prototype, \"dir\", {\n            /** The element's layout direction. */\n            get: function () {\n                return this._dir ? this._dir.value : 'ltr';\n            },\n            enumerable: true,\n            configurable: true\n        });\n        CdkConnectedOverlay.prototype.ngOnDestroy = function () {\n            if (this._overlayRef) {\n                this._overlayRef.dispose();\n            }\n            this._backdropSubscription.unsubscribe();\n        };\n        CdkConnectedOverlay.prototype.ngOnChanges = function (changes) {\n            if (this._position) {\n                this._updatePositionStrategy(this._position);\n                this._overlayRef.updateSize({\n                    width: this.width,\n                    minWidth: this.minWidth,\n                    height: this.height,\n                    minHeight: this.minHeight,\n                });\n                if (changes['origin'] && this.open) {\n                    this._position.apply();\n                }\n            }\n            if (changes['open']) {\n                this.open ? this._attachOverlay() : this._detachOverlay();\n            }\n        };\n        /** Creates an overlay */\n        CdkConnectedOverlay.prototype._createOverlay = function () {\n            var _this = this;\n            if (!this.positions || !this.positions.length) {\n                this.positions = defaultPositionList;\n            }\n            this._overlayRef = this._overlay.create(this._buildConfig());\n            this._overlayRef.keydownEvents().subscribe(function (event) {\n                _this.overlayKeydown.next(event);\n                if (event.keyCode === keycodes.ESCAPE && !keycodes.hasModifierKey(event)) {\n                    event.preventDefault();\n                    _this._detachOverlay();\n                }\n            });\n        };\n        /** Builds the overlay config based on the directive's inputs */\n        CdkConnectedOverlay.prototype._buildConfig = function () {\n            var positionStrategy = this._position = this._createPositionStrategy();\n            var overlayConfig = new OverlayConfig({\n                direction: this._dir,\n                positionStrategy: positionStrategy,\n                scrollStrategy: this.scrollStrategy,\n                hasBackdrop: this.hasBackdrop\n            });\n            if (this.width || this.width === 0) {\n                overlayConfig.width = this.width;\n            }\n            if (this.height || this.height === 0) {\n                overlayConfig.height = this.height;\n            }\n            if (this.minWidth || this.minWidth === 0) {\n                overlayConfig.minWidth = this.minWidth;\n            }\n            if (this.minHeight || this.minHeight === 0) {\n                overlayConfig.minHeight = this.minHeight;\n            }\n            if (this.backdropClass) {\n                overlayConfig.backdropClass = this.backdropClass;\n            }\n            if (this.panelClass) {\n                overlayConfig.panelClass = this.panelClass;\n            }\n            return overlayConfig;\n        };\n        /** Updates the state of a position strategy, based on the values of the directive inputs. */\n        CdkConnectedOverlay.prototype._updatePositionStrategy = function (positionStrategy) {\n            var _this = this;\n            var positions = this.positions.map(function (currentPosition) { return ({\n                originX: currentPosition.originX,\n                originY: currentPosition.originY,\n                overlayX: currentPosition.overlayX,\n                overlayY: currentPosition.overlayY,\n                offsetX: currentPosition.offsetX || _this.offsetX,\n                offsetY: currentPosition.offsetY || _this.offsetY,\n                panelClass: currentPosition.panelClass || undefined,\n            }); });\n            return positionStrategy\n                .setOrigin(this.origin.elementRef)\n                .withPositions(positions)\n                .withFlexibleDimensions(this.flexibleDimensions)\n                .withPush(this.push)\n                .withGrowAfterOpen(this.growAfterOpen)\n                .withViewportMargin(this.viewportMargin)\n                .withLockedPosition(this.lockPosition);\n        };\n        /** Returns the position strategy of the overlay to be set on the overlay config */\n        CdkConnectedOverlay.prototype._createPositionStrategy = function () {\n            var _this = this;\n            var strategy = this._overlay.position().flexibleConnectedTo(this.origin.elementRef);\n            this._updatePositionStrategy(strategy);\n            strategy.positionChanges.subscribe(function (p) { return _this.positionChange.emit(p); });\n            return strategy;\n        };\n        /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */\n        CdkConnectedOverlay.prototype._attachOverlay = function () {\n            var _this = this;\n            if (!this._overlayRef) {\n                this._createOverlay();\n            }\n            else {\n                // Update the overlay size, in case the directive's inputs have changed\n                this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;\n            }\n            if (!this._overlayRef.hasAttached()) {\n                this._overlayRef.attach(this._templatePortal);\n                this.attach.emit();\n            }\n            if (this.hasBackdrop) {\n                this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function (event) {\n                    _this.backdropClick.emit(event);\n                });\n            }\n            else {\n                this._backdropSubscription.unsubscribe();\n            }\n        };\n        /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */\n        CdkConnectedOverlay.prototype._detachOverlay = function () {\n            if (this._overlayRef) {\n                this._overlayRef.detach();\n                this.detach.emit();\n            }\n            this._backdropSubscription.unsubscribe();\n        };\n        CdkConnectedOverlay.decorators = [\n            { type: i0.Directive, args: [{\n                        selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                        exportAs: 'cdkConnectedOverlay'\n                    },] }\n        ];\n        /** @nocollapse */\n        CdkConnectedOverlay.ctorParameters = function () { return [\n            { type: Overlay },\n            { type: i0.TemplateRef },\n            { type: i0.ViewContainerRef },\n            { type: undefined, decorators: [{ type: i0.Inject, args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] }] },\n            { type: bidi.Directionality, decorators: [{ type: i0.Optional }] }\n        ]; };\n        CdkConnectedOverlay.propDecorators = {\n            origin: [{ type: i0.Input, args: ['cdkConnectedOverlayOrigin',] }],\n            positions: [{ type: i0.Input, args: ['cdkConnectedOverlayPositions',] }],\n            offsetX: [{ type: i0.Input, args: ['cdkConnectedOverlayOffsetX',] }],\n            offsetY: [{ type: i0.Input, args: ['cdkConnectedOverlayOffsetY',] }],\n            width: [{ type: i0.Input, args: ['cdkConnectedOverlayWidth',] }],\n            height: [{ type: i0.Input, args: ['cdkConnectedOverlayHeight',] }],\n            minWidth: [{ type: i0.Input, args: ['cdkConnectedOverlayMinWidth',] }],\n            minHeight: [{ type: i0.Input, args: ['cdkConnectedOverlayMinHeight',] }],\n            backdropClass: [{ type: i0.Input, args: ['cdkConnectedOverlayBackdropClass',] }],\n            panelClass: [{ type: i0.Input, args: ['cdkConnectedOverlayPanelClass',] }],\n            viewportMargin: [{ type: i0.Input, args: ['cdkConnectedOverlayViewportMargin',] }],\n            scrollStrategy: [{ type: i0.Input, args: ['cdkConnectedOverlayScrollStrategy',] }],\n            open: [{ type: i0.Input, args: ['cdkConnectedOverlayOpen',] }],\n            hasBackdrop: [{ type: i0.Input, args: ['cdkConnectedOverlayHasBackdrop',] }],\n            lockPosition: [{ type: i0.Input, args: ['cdkConnectedOverlayLockPosition',] }],\n            flexibleDimensions: [{ type: i0.Input, args: ['cdkConnectedOverlayFlexibleDimensions',] }],\n            growAfterOpen: [{ type: i0.Input, args: ['cdkConnectedOverlayGrowAfterOpen',] }],\n            push: [{ type: i0.Input, args: ['cdkConnectedOverlayPush',] }],\n            backdropClick: [{ type: i0.Output }],\n            positionChange: [{ type: i0.Output }],\n            attach: [{ type: i0.Output }],\n            detach: [{ type: i0.Output }],\n            overlayKeydown: [{ type: i0.Output }]\n        };\n        return CdkConnectedOverlay;\n    }());\n    /** @docs-private */\n    function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n        return function () { return overlay.scrollStrategies.reposition(); };\n    }\n    /** @docs-private */\n    var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n        provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n        deps: [Overlay],\n        useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n    };\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var OverlayModule = /** @class */ (function () {\n        function OverlayModule() {\n        }\n        OverlayModule.decorators = [\n            { type: i0.NgModule, args: [{\n                        imports: [bidi.BidiModule, portal.PortalModule, scrolling.ScrollingModule],\n                        exports: [CdkConnectedOverlay, CdkOverlayOrigin, scrolling.ScrollingModule],\n                        declarations: [CdkConnectedOverlay, CdkOverlayOrigin],\n                        providers: [\n                            Overlay,\n                            CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n                        ],\n                    },] }\n        ];\n        return OverlayModule;\n    }());\n    /**\n     * @deprecated Use `OverlayModule` instead.\n     * @breaking-change 8.0.0\n     * @docs-private\n     */\n    var OVERLAY_PROVIDERS = [\n        Overlay,\n        OverlayPositionBuilder,\n        OVERLAY_KEYBOARD_DISPATCHER_PROVIDER,\n        OVERLAY_CONTAINER_PROVIDER,\n        CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n    ];\n\n    /**\n     * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n     * Fullscreen mode\n     * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n     *\n     * Should be provided in the root component.\n     */\n    var FullscreenOverlayContainer = /** @class */ (function (_super) {\n        tslib.__extends(FullscreenOverlayContainer, _super);\n        function FullscreenOverlayContainer(_document) {\n            return _super.call(this, _document) || this;\n        }\n        FullscreenOverlayContainer.prototype.ngOnDestroy = function () {\n            _super.prototype.ngOnDestroy.call(this);\n            if (this._fullScreenEventName && this._fullScreenListener) {\n                this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);\n            }\n        };\n        FullscreenOverlayContainer.prototype._createContainer = function () {\n            var _this = this;\n            _super.prototype._createContainer.call(this);\n            this._adjustParentForFullscreenChange();\n            this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\n        };\n        FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = function () {\n            if (!this._containerElement) {\n                return;\n            }\n            var fullscreenElement = this.getFullscreenElement();\n            var parent = fullscreenElement || this._document.body;\n            parent.appendChild(this._containerElement);\n        };\n        FullscreenOverlayContainer.prototype._addFullscreenChangeListener = function (fn) {\n            var eventName = this._getEventName();\n            if (eventName) {\n                if (this._fullScreenListener) {\n                    this._document.removeEventListener(eventName, this._fullScreenListener);\n                }\n                this._document.addEventListener(eventName, fn);\n                this._fullScreenListener = fn;\n            }\n        };\n        FullscreenOverlayContainer.prototype._getEventName = function () {\n            if (!this._fullScreenEventName) {\n                var _document = this._document;\n                if (_document.fullscreenEnabled) {\n                    this._fullScreenEventName = 'fullscreenchange';\n                }\n                else if (_document.webkitFullscreenEnabled) {\n                    this._fullScreenEventName = 'webkitfullscreenchange';\n                }\n                else if (_document.mozFullScreenEnabled) {\n                    this._fullScreenEventName = 'mozfullscreenchange';\n                }\n                else if (_document.msFullscreenEnabled) {\n                    this._fullScreenEventName = 'MSFullscreenChange';\n                }\n            }\n            return this._fullScreenEventName;\n        };\n        /**\n         * When the page is put into fullscreen mode, a specific element is specified.\n         * Only that element and its children are visible when in fullscreen mode.\n         */\n        FullscreenOverlayContainer.prototype.getFullscreenElement = function () {\n            var _document = this._document;\n            return _document.fullscreenElement ||\n                _document.webkitFullscreenElement ||\n                _document.mozFullScreenElement ||\n                _document.msFullscreenElement ||\n                null;\n        };\n        FullscreenOverlayContainer.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        FullscreenOverlayContainer.ctorParameters = function () { return [\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i1.DOCUMENT,] }] }\n        ]; };\n        FullscreenOverlayContainer.ɵprov = i0.ɵɵdefineInjectable({ factory: function FullscreenOverlayContainer_Factory() { return new FullscreenOverlayContainer(i0.ɵɵinject(i1.DOCUMENT)); }, token: FullscreenOverlayContainer, providedIn: \"root\" });\n        return FullscreenOverlayContainer;\n    }(OverlayContainer));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    Object.defineProperty(exports, 'CdkScrollable', {\n        enumerable: true,\n        get: function () {\n            return scrolling.CdkScrollable;\n        }\n    });\n    Object.defineProperty(exports, 'ScrollDispatcher', {\n        enumerable: true,\n        get: function () {\n            return scrolling.ScrollDispatcher;\n        }\n    });\n    Object.defineProperty(exports, 'ViewportRuler', {\n        enumerable: true,\n        get: function () {\n            return scrolling.ViewportRuler;\n        }\n    });\n    exports.BlockScrollStrategy = BlockScrollStrategy;\n    exports.CdkConnectedOverlay = CdkConnectedOverlay;\n    exports.CdkOverlayOrigin = CdkOverlayOrigin;\n    exports.CloseScrollStrategy = CloseScrollStrategy;\n    exports.ConnectedOverlayPositionChange = ConnectedOverlayPositionChange;\n    exports.ConnectedPositionStrategy = ConnectedPositionStrategy;\n    exports.ConnectionPositionPair = ConnectionPositionPair;\n    exports.FlexibleConnectedPositionStrategy = FlexibleConnectedPositionStrategy;\n    exports.FullscreenOverlayContainer = FullscreenOverlayContainer;\n    exports.GlobalPositionStrategy = GlobalPositionStrategy;\n    exports.NoopScrollStrategy = NoopScrollStrategy;\n    exports.OVERLAY_PROVIDERS = OVERLAY_PROVIDERS;\n    exports.Overlay = Overlay;\n    exports.OverlayConfig = OverlayConfig;\n    exports.OverlayContainer = OverlayContainer;\n    exports.OverlayKeyboardDispatcher = OverlayKeyboardDispatcher;\n    exports.OverlayModule = OverlayModule;\n    exports.OverlayPositionBuilder = OverlayPositionBuilder;\n    exports.OverlayRef = OverlayRef;\n    exports.RepositionScrollStrategy = RepositionScrollStrategy;\n    exports.ScrollStrategyOptions = ScrollStrategyOptions;\n    exports.ScrollingVisibility = ScrollingVisibility;\n    exports.validateHorizontalPosition = validateHorizontalPosition;\n    exports.validateVerticalPosition = validateVerticalPosition;\n    exports.ɵangular_material_src_cdk_overlay_overlay_a = OVERLAY_CONTAINER_PROVIDER_FACTORY;\n    exports.ɵangular_material_src_cdk_overlay_overlay_b = OVERLAY_CONTAINER_PROVIDER;\n    exports.ɵangular_material_src_cdk_overlay_overlay_c = CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY;\n    exports.ɵangular_material_src_cdk_overlay_overlay_d = CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY;\n    exports.ɵangular_material_src_cdk_overlay_overlay_e = CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER;\n    exports.ɵangular_material_src_cdk_overlay_overlay_f = OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY;\n    exports.ɵangular_material_src_cdk_overlay_overlay_g = OVERLAY_KEYBOARD_DISPATCHER_PROVIDER;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=cdk-overlay.umd.js.map\n"]}