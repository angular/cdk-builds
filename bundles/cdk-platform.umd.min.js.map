{"version":3,"sources":["src/cdk/cdk-platform.umd.js"],"names":["global","factory","exports","module","require","define","amd","globalThis","self","ng","cdk","platform","core","common","this","i0","_interopNamespace","e","__esModule","n","Object","create","keys","forEach","k","d","getOwnPropertyDescriptor","defineProperty","get","enumerable","freeze","hasV8BreakIterator","Platform","supportedInputTypes","PlatformModule","i0__namespace","Intl","v8BreakIterator","_a","_platformId","isBrowser","isPlatformBrowser","document","EDGE","test","navigator","userAgent","TRIDENT","BLINK","window","chrome","CSS","WEBKIT","IOS","FIREFOX","ANDROID","SAFARI","ɵprov","ɵɵdefineInjectable","Platform_Factory","ɵɵinject","PLATFORM_ID","token","providedIn","decorators","type","Injectable","args","ctorParameters","Inject","NgModule","supportsPassiveEvents","rtlScrollAxisType","scrollBehaviorSupported","shadowDomIsSupported","candidateInputTypes","supportsPassiveEventListeners","addEventListener","_supportsShadowDom","head","createShadowRoot","attachShadow","_getShadowRoot","element","rootNode","getRootNode","ShadowRoot","getRtlScrollAxisType","scrollContainer","createElement","containerStyle","style","dir","width","overflow","visibility","pointerEvents","position","content","contentStyle","height","appendChild","body","scrollLeft","parentNode","removeChild","getSupportedInputTypes","Set","featureTestInput","filter","value","setAttribute","normalizePassiveListenerOptions","options","capture","supportsScrollBehavior","documentElement","scrollToFunction","Element","prototype","scrollTo","toString"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common')) :\n    typeof define === 'function' && define.amd ? define('@angular/cdk/platform', ['exports', '@angular/core', '@angular/common'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.ng = global.ng || {}, global.ng.cdk = global.ng.cdk || {}, global.ng.cdk.platform = {}), global.ng.core, global.ng.common));\n}(this, (function (exports, i0, common) { 'use strict';\n\n    function _interopNamespace(e) {\n        if (e && e.__esModule) return e;\n        var n = Object.create(null);\n        if (e) {\n            Object.keys(e).forEach(function (k) {\n                if (k !== 'default') {\n                    var d = Object.getOwnPropertyDescriptor(e, k);\n                    Object.defineProperty(n, k, d.get ? d : {\n                        enumerable: true,\n                        get: function () {\n                            return e[k];\n                        }\n                    });\n                }\n            });\n        }\n        n['default'] = e;\n        return Object.freeze(n);\n    }\n\n    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Whether the current platform supports the V8 Break Iterator. The V8 check\n    // is necessary to detect all Blink based browsers.\n    var hasV8BreakIterator;\n    // We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n    // cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n    // the consumer is providing a polyfilled `Map`. See:\n    // https://github.com/Microsoft/ChakraCore/issues/3189\n    // https://github.com/angular/components/issues/15687\n    try {\n        hasV8BreakIterator = (typeof Intl !== 'undefined' && Intl.v8BreakIterator);\n    }\n    catch (_a) {\n        hasV8BreakIterator = false;\n    }\n    /**\n     * Service to detect the current platform by comparing the userAgent strings and\n     * checking browser-specific global properties.\n     */\n    var Platform = /** @class */ (function () {\n        function Platform(_platformId) {\n            this._platformId = _platformId;\n            // We want to use the Angular platform check because if the Document is shimmed\n            // without the navigator, the following checks will fail. This is preferred because\n            // sometimes the Document may be shimmed without the user's knowledge or intention\n            /** Whether the Angular application is being rendered in the browser. */\n            this.isBrowser = this._platformId ?\n                common.isPlatformBrowser(this._platformId) : typeof document === 'object' && !!document;\n            /** Whether the current browser is Microsoft Edge. */\n            this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n            /** Whether the current rendering engine is Microsoft Trident. */\n            this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n            // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n            /** Whether the current rendering engine is Blink. */\n            this.BLINK = this.isBrowser && (!!(window.chrome || hasV8BreakIterator) &&\n                typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT);\n            // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n            // ensure that Webkit runs standalone and is not used as another engine's base.\n            /** Whether the current rendering engine is WebKit. */\n            this.WEBKIT = this.isBrowser &&\n                /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n            /** Whether the current platform is Apple iOS. */\n            this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n                !('MSStream' in window);\n            // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n            // them self as Gecko-like browsers and modify the userAgent's according to that.\n            // Since we only cover one explicit Firefox case, we can simply check for Firefox\n            // instead of having an unstable check for Gecko.\n            /** Whether the current browser is Firefox. */\n            this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n            /** Whether the current platform is Android. */\n            // Trident on mobile adds the android platform to the userAgent to trick detections.\n            this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n            // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n            // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n            // Safari browser should also use Webkit as its layout engine.\n            /** Whether the current browser is Safari. */\n            this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n        }\n        return Platform;\n    }());\n    Platform.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function Platform_Factory() { return new Platform(i0__namespace.ɵɵinject(i0__namespace.PLATFORM_ID)); }, token: Platform, providedIn: \"root\" });\n    Platform.decorators = [\n        { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n    ];\n    Platform.ctorParameters = function () { return [\n        { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }\n    ]; };\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var PlatformModule = /** @class */ (function () {\n        function PlatformModule() {\n        }\n        return PlatformModule;\n    }());\n    PlatformModule.decorators = [\n        { type: i0.NgModule, args: [{},] }\n    ];\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Cached result Set of input types support by the current browser. */\n    var supportedInputTypes;\n    /** Types of `<input>` that *might* be supported. */\n    var candidateInputTypes = [\n        // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\n        // first changing it to something else:\n        // The specified value \"\" does not conform to the required format.\n        // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\n        'color',\n        'button',\n        'checkbox',\n        'date',\n        'datetime-local',\n        'email',\n        'file',\n        'hidden',\n        'image',\n        'month',\n        'number',\n        'password',\n        'radio',\n        'range',\n        'reset',\n        'search',\n        'submit',\n        'tel',\n        'text',\n        'time',\n        'url',\n        'week',\n    ];\n    /** @returns The input types supported by this browser. */\n    function getSupportedInputTypes() {\n        // Result is cached.\n        if (supportedInputTypes) {\n            return supportedInputTypes;\n        }\n        // We can't check if an input type is not supported until we're on the browser, so say that\n        // everything is supported when not on the browser. We don't use `Platform` here since it's\n        // just a helper function and can't inject it.\n        if (typeof document !== 'object' || !document) {\n            supportedInputTypes = new Set(candidateInputTypes);\n            return supportedInputTypes;\n        }\n        var featureTestInput = document.createElement('input');\n        supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {\n            featureTestInput.setAttribute('type', value);\n            return featureTestInput.type === value;\n        }));\n        return supportedInputTypes;\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Cached result of whether the user's browser supports passive event listeners. */\n    var supportsPassiveEvents;\n    /**\n     * Checks whether the user's browser supports passive event listeners.\n     * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n     */\n    function supportsPassiveEventListeners() {\n        if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n            try {\n                window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n                    get: function () { return supportsPassiveEvents = true; }\n                }));\n            }\n            finally {\n                supportsPassiveEvents = supportsPassiveEvents || false;\n            }\n        }\n        return supportsPassiveEvents;\n    }\n    /**\n     * Normalizes an `AddEventListener` object to something that can be passed\n     * to `addEventListener` on any browser, no matter whether it supports the\n     * `options` parameter.\n     * @param options Object to be normalized.\n     */\n    function normalizePassiveListenerOptions(options) {\n        return supportsPassiveEventListeners() ? options : !!options.capture;\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Cached result of the way the browser handles the horizontal scroll axis in RTL mode. */\n    var rtlScrollAxisType;\n    /** Cached result of the check that indicates whether the browser supports scroll behaviors. */\n    var scrollBehaviorSupported;\n    /** Check whether the browser supports scroll behaviors. */\n    function supportsScrollBehavior() {\n        if (scrollBehaviorSupported == null) {\n            // If we're not in the browser, it can't be supported.\n            if (typeof document !== 'object' || !document) {\n                scrollBehaviorSupported = false;\n                return scrollBehaviorSupported;\n            }\n            // If the element can have a `scrollBehavior` style, we can be sure that it's supported.\n            if ('scrollBehavior' in document.documentElement.style) {\n                scrollBehaviorSupported = true;\n            }\n            else {\n                // At this point we have 3 possibilities: `scrollTo` isn't supported at all, it's\n                // supported but it doesn't handle scroll behavior, or it has been polyfilled.\n                var scrollToFunction = Element.prototype.scrollTo;\n                if (scrollToFunction) {\n                    // We can detect if the function has been polyfilled by calling `toString` on it. Native\n                    // functions are obfuscated using `[native code]`, whereas if it was overwritten we'd get\n                    // the actual function source. Via https://davidwalsh.name/detect-native-function. Consider\n                    // polyfilled functions as supporting scroll behavior.\n                    scrollBehaviorSupported = !/\\{\\s*\\[native code\\]\\s*\\}/.test(scrollToFunction.toString());\n                }\n                else {\n                    scrollBehaviorSupported = false;\n                }\n            }\n        }\n        return scrollBehaviorSupported;\n    }\n    /**\n     * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,\n     * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.\n     */\n    function getRtlScrollAxisType() {\n        // We can't check unless we're on the browser. Just assume 'normal' if we're not.\n        if (typeof document !== 'object' || !document) {\n            return 0 /* NORMAL */;\n        }\n        if (rtlScrollAxisType == null) {\n            // Create a 1px wide scrolling container and a 2px wide content element.\n            var scrollContainer = document.createElement('div');\n            var containerStyle = scrollContainer.style;\n            scrollContainer.dir = 'rtl';\n            containerStyle.width = '1px';\n            containerStyle.overflow = 'auto';\n            containerStyle.visibility = 'hidden';\n            containerStyle.pointerEvents = 'none';\n            containerStyle.position = 'absolute';\n            var content = document.createElement('div');\n            var contentStyle = content.style;\n            contentStyle.width = '2px';\n            contentStyle.height = '1px';\n            scrollContainer.appendChild(content);\n            document.body.appendChild(scrollContainer);\n            rtlScrollAxisType = 0 /* NORMAL */;\n            // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL\n            // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're\n            // dealing with one of the other two types of browsers.\n            if (scrollContainer.scrollLeft === 0) {\n                // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an\n                // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by\n                // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will\n                // return 0 when we read it again.\n                scrollContainer.scrollLeft = 1;\n                rtlScrollAxisType =\n                    scrollContainer.scrollLeft === 0 ? 1 /* NEGATED */ : 2 /* INVERTED */;\n            }\n            scrollContainer.parentNode.removeChild(scrollContainer);\n        }\n        return rtlScrollAxisType;\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var shadowDomIsSupported;\n    /** Checks whether the user's browser support Shadow DOM. */\n    function _supportsShadowDom() {\n        if (shadowDomIsSupported == null) {\n            var head = typeof document !== 'undefined' ? document.head : null;\n            shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));\n        }\n        return shadowDomIsSupported;\n    }\n    /** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\n    function _getShadowRoot(element) {\n        if (_supportsShadowDom()) {\n            var rootNode = element.getRootNode ? element.getRootNode() : null;\n            // Note that this should be caught by `_supportsShadowDom`, but some\n            // teams have been able to hit this code path on unsupported browsers.\n            if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\n                return rootNode;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.Platform = Platform;\n    exports.PlatformModule = PlatformModule;\n    exports._getShadowRoot = _getShadowRoot;\n    exports._supportsShadowDom = _supportsShadowDom;\n    exports.getRtlScrollAxisType = getRtlScrollAxisType;\n    exports.getSupportedInputTypes = getSupportedInputTypes;\n    exports.normalizePassiveListenerOptions = normalizePassiveListenerOptions;\n    exports.supportsPassiveEventListeners = supportsPassiveEventListeners;\n    exports.supportsScrollBehavior = supportsScrollBehavior;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=cdk-platform.umd.js.map\n"]}