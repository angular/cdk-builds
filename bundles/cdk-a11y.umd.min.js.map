{"version":3,"sources":["src/cdk/cdk-a11y.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","cdk","a11Y","common","core","tslib","rxjs","keycodes","operators","coercion","platform","observers","this","i2","i0","tslib_1","i1","getAriaReferenceIds","el","attr","getAttribute","match","nextId","messageRegistry","Map","messagesContainer","AriaDescriber","_document","prototype","describe","hostElement","message","_canBeDescribed","_setMessageId","set","messageElement","referenceCount","has","_createMessageElement","_isElementDescribedByMessage","_addMessageReference","removeDescription","_isElementNode","_removeMessageReference","registeredMessage","get","_deleteMessageElement","childNodes","length","_deleteMessagesContainer","ngOnDestroy","describedElements","querySelectorAll","i","_removeCdkDescribedByReferenceIds","removeAttribute","clear","createElement","textContent","_createMessagesContainer","appendChild","element","id","CDK_DESCRIBEDBY_ID_PREFIX","removeChild","delete","preExistingContainer","getElementById","parentNode","setAttribute","style","display","body","originalReferenceIds","filter","indexOf","join","addAriaReferencedId","ids","some","existingId","trim","push","removeAriaReferencedId","filteredIds","val","referenceIds","messageId","trimmedMessage","ariaLabel","nodeType","ELEMENT_NODE","decorators","type","Injectable","args","providedIn","ctorParameters","undefined","Inject","DOCUMENT","ngInjectableDef","ɵɵdefineInjectable","AriaDescriber_Factory","ɵɵinject","token","ListKeyManager","_items","_this","_activeItemIndex","_activeItem","_wrap","_letterKeyStream","Subject","_typeaheadSubscription","Subscription","EMPTY","_vertical","_allowedModifierKeys","_skipPredicateFn","item","disabled","_pressedLetters","tabOut","change","QueryList","changes","subscribe","newItems","newIndex","toArray","skipPredicate","predicate","withWrap","shouldWrap","withVerticalOrientation","enabled","withHorizontalOrientation","direction","_horizontal","withAllowedModifierKeys","keys","withTypeAhead","debounceInterval","getLabel","Error","unsubscribe","pipe","tap","keyCode","debounceTime","map","inputString","items","_getItemsArray","index","toUpperCase","setActiveItem","previousIndex","updateActiveItem","next","onKeydown","event","isModifierAllowed","every","modifier","TAB","DOWN_ARROW","setNextItemActive","UP_ARROW","setPreviousItemActive","RIGHT_ARROW","LEFT_ARROW","hasModifierKey","key","toLocaleUpperCase","A","Z","ZERO","NINE","String","fromCharCode","preventDefault","Object","defineProperty","enumerable","configurable","setFirstItemActive","_setActiveItemByIndex","setLastItemActive","_setActiveItemByDelta","itemArray","activeItem","delta","_setActiveInWrapMode","_setActiveInDefaultMode","fallbackDelta","ActiveDescendantKeyManager","_super","apply","arguments","__extends","setInactiveStyles","call","setActiveStyles","FocusKeyManager","_origin","setFocusOrigin","origin","focus","InteractivityChecker","_platform","isDisabled","hasAttribute","isVisible","hasGeometry","offsetWidth","offsetHeight","getClientRects","getComputedStyle","visibility","isTabbable","isBrowser","frameElement","getFrameElement","window","_a","getWindow","node","ownerDocument","defaultView","frameType","nodeName","toLowerCase","getTabIndexValue","BLINK","WEBKIT","tabIndexValue","TRIDENT","FIREFOX","IOS","isPotentiallyTabbableIOS","inputType","tabIndex","isFocusable","isPotentiallyFocusable","isHiddenInput","isInputElement","isNativeFormElement","isAnchorWithHref","isAnchorElement","hasValidTabIndex","Platform","InteractivityChecker_Factory","isNaN","parseInt","FocusTrap","_element","_checker","_ngZone","deferAnchors","_hasAttached","startAnchorListener","focusLastTabbableElement","endAnchorListener","focusFirstTabbableElement","_enabled","attachAnchors","value","_startAnchor","_endAnchor","_toggleAnchorTabIndex","destroy","startAnchor","endAnchor","removeEventListener","runOutsideAngular","_createAnchor","addEventListener","insertBefore","nextSibling","focusInitialElementWhenReady","Promise","resolve","_executeOnStable","focusInitialElement","focusFirstTabbableElementWhenReady","focusLastTabbableElementWhenReady","_getRegionBoundary","bound","markers","console","warn","_getFirstTabbableElement","_getLastTabbableElement","redirectToElement","querySelector","isDevMode","hasAttached","root","children","tabbableChild","anchor","classList","add","isEnabled","fn","isStable","onStable","asObservable","take","FocusTrapFactory","create","deferCaptureElements","NgZone","FocusTrapFactory_Factory","CdkTrapFocus","_elementRef","_focusTrapFactory","_previouslyFocusedElement","focusTrap","nativeElement","coerceBooleanProperty","_autoCapture","ngAfterContentInit","autoCapture","activeElement","ngDoCheck","Directive","selector","exportAs","ElementRef","propDecorators","Input","LIVE_ANNOUNCER_ELEMENT_TOKEN","InjectionToken","LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY","LIVE_ANNOUNCER_DEFAULT_OPTIONS","LiveAnnouncer","elementToken","_defaultOptions","_liveElement","_createLiveElement","announce","_i","politeness","duration","defaultOptions","__read","clearTimeout","_previousTimeout","setTimeout","previousElements","getElementsByClassName","liveEl","Optional","LiveAnnouncer_Factory","CdkAriaLive","_liveAnnouncer","_contentObserver","_politeness","_subscription","observe","elementText","_previousAnnouncedText","ContentObserver","TOUCH_BUFFER_MS","captureEventListenerOptions","normalizePassiveListenerOptions","passive","capture","FocusMonitor","_windowFocused","_elementInfo","_monitoredElementCount","_documentKeydownListener","_lastTouchTarget","_setOriginForCurrentEventQueue","_documentMousedownListener","_documentTouchstartListener","_touchTimeoutId","composedPath","target","_windowFocusListener","_windowFocusTimeoutId","monitor","checkChildren","of","coerceElement","cachedInfo","subject","info","unlisten","_incrementMonitoredElementCount","focusListener","_onFocus","blurListener","_onBlur","stopMonitoring","elementInfo","complete","_setClasses","_decrementMonitoredElementCount","focusVia","options","forEach","_info","_toggleClass","className","shouldSet","remove","_originTimeoutId","_wasCausedByTouch","focusTarget","Node","contains","_lastFocusOrigin","_emitOrigin","relatedTarget","run","document","FocusMonitor_Factory","CdkMonitorFocus","_focusMonitor","cdkFocusChange","EventEmitter","_monitorSubscription","emit","Output","A11yModule","NgModule","imports","CommonModule","PlatformModule","ObserversModule","declarations","MESSAGES_CONTAINER_ID","CDK_DESCRIBEDBY_HOST_ATTRIBUTE","isFakeMousedownFromScreenReader","buttons"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('tslib'), require('rxjs'), require('@angular/cdk/keycodes'), require('rxjs/operators'), require('@angular/cdk/coercion'), require('@angular/cdk/platform'), require('@angular/cdk/observers')) :\n    typeof define === 'function' && define.amd ? define('@angular/cdk/a11y', ['exports', '@angular/common', '@angular/core', 'tslib', 'rxjs', '@angular/cdk/keycodes', 'rxjs/operators', '@angular/cdk/coercion', '@angular/cdk/platform', '@angular/cdk/observers'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.cdk = global.ng.cdk || {}, global.ng.cdk.a11Y = {}), global.ng.common, global.ng.core, global.tslib, global.rxjs, global.ng.cdk.keycodes, global.rxjs.operators, global.ng.cdk.coercion, global.ng.cdk.platform, global.ng.cdk.observers));\n}(this, function (exports, i2, i0, tslib_1, rxjs, keycodes, operators, coercion, i1, observers) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** IDs are deliminated by an empty space, as per the spec. */\n    var ID_DELIMINATOR = ' ';\n    /**\n     * Adds the given ID to the specified ARIA attribute on an element.\n     * Used for attributes such as aria-labelledby, aria-owns, etc.\n     */\n    function addAriaReferencedId(el, attr, id) {\n        var ids = getAriaReferenceIds(el, attr);\n        if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n            return;\n        }\n        ids.push(id.trim());\n        el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n    }\n    /**\n     * Removes the given ID from the specified ARIA attribute on an element.\n     * Used for attributes such as aria-labelledby, aria-owns, etc.\n     */\n    function removeAriaReferencedId(el, attr, id) {\n        var ids = getAriaReferenceIds(el, attr);\n        var filteredIds = ids.filter(function (val) { return val != id.trim(); });\n        if (filteredIds.length) {\n            el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n        }\n        else {\n            el.removeAttribute(attr);\n        }\n    }\n    /**\n     * Gets the list of IDs referenced by the given ARIA attribute on an element.\n     * Used for attributes such as aria-labelledby, aria-owns, etc.\n     */\n    function getAriaReferenceIds(el, attr) {\n        // Get string array of all individual ids (whitespace deliminated) in the attribute value\n        return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** ID used for the body container where all messages are appended. */\n    var MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n    /** ID prefix used for each created message element. */\n    var CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n    /** Attribute given to each host element that is described by a message element. */\n    var CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n    /** Global incremental identifier for each registered message element. */\n    var nextId = 0;\n    /** Global map of all registered message elements that have been placed into the document. */\n    var messageRegistry = new Map();\n    /** Container for all registered messages. */\n    var messagesContainer = null;\n    /**\n     * Utility that creates visually hidden elements with a message content. Useful for elements that\n     * want to use aria-describedby to further describe themselves without adding additional visual\n     * content.\n     */\n    var AriaDescriber = /** @class */ (function () {\n        function AriaDescriber(_document) {\n            this._document = _document;\n        }\n        /**\n         * Adds to the host element an aria-describedby reference to a hidden element that contains\n         * the message. If the same message has already been registered, then it will reuse the created\n         * message element.\n         */\n        AriaDescriber.prototype.describe = function (hostElement, message) {\n            if (!this._canBeDescribed(hostElement, message)) {\n                return;\n            }\n            if (typeof message !== 'string') {\n                // We need to ensure that the element has an ID.\n                this._setMessageId(message);\n                messageRegistry.set(message, { messageElement: message, referenceCount: 0 });\n            }\n            else if (!messageRegistry.has(message)) {\n                this._createMessageElement(message);\n            }\n            if (!this._isElementDescribedByMessage(hostElement, message)) {\n                this._addMessageReference(hostElement, message);\n            }\n        };\n        /** Removes the host element's aria-describedby reference to the message element. */\n        AriaDescriber.prototype.removeDescription = function (hostElement, message) {\n            if (!this._isElementNode(hostElement)) {\n                return;\n            }\n            if (this._isElementDescribedByMessage(hostElement, message)) {\n                this._removeMessageReference(hostElement, message);\n            }\n            // If the message is a string, it means that it's one that we created for the\n            // consumer so we can remove it safely, otherwise we should leave it in place.\n            if (typeof message === 'string') {\n                var registeredMessage = messageRegistry.get(message);\n                if (registeredMessage && registeredMessage.referenceCount === 0) {\n                    this._deleteMessageElement(message);\n                }\n            }\n            if (messagesContainer && messagesContainer.childNodes.length === 0) {\n                this._deleteMessagesContainer();\n            }\n        };\n        /** Unregisters all created message elements and removes the message container. */\n        AriaDescriber.prototype.ngOnDestroy = function () {\n            var describedElements = this._document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n            for (var i = 0; i < describedElements.length; i++) {\n                this._removeCdkDescribedByReferenceIds(describedElements[i]);\n                describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n            }\n            if (messagesContainer) {\n                this._deleteMessagesContainer();\n            }\n            messageRegistry.clear();\n        };\n        /**\n         * Creates a new element in the visually hidden message container element with the message\n         * as its content and adds it to the message registry.\n         */\n        AriaDescriber.prototype._createMessageElement = function (message) {\n            var messageElement = this._document.createElement('div');\n            this._setMessageId(messageElement);\n            messageElement.textContent = message;\n            this._createMessagesContainer();\n            messagesContainer.appendChild(messageElement);\n            messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n        };\n        /** Assigns a unique ID to an element, if it doesn't have one already. */\n        AriaDescriber.prototype._setMessageId = function (element) {\n            if (!element.id) {\n                element.id = CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++;\n            }\n        };\n        /** Deletes the message element from the global messages container. */\n        AriaDescriber.prototype._deleteMessageElement = function (message) {\n            var registeredMessage = messageRegistry.get(message);\n            var messageElement = registeredMessage && registeredMessage.messageElement;\n            if (messagesContainer && messageElement) {\n                messagesContainer.removeChild(messageElement);\n            }\n            messageRegistry.delete(message);\n        };\n        /** Creates the global container for all aria-describedby messages. */\n        AriaDescriber.prototype._createMessagesContainer = function () {\n            if (!messagesContainer) {\n                var preExistingContainer = this._document.getElementById(MESSAGES_CONTAINER_ID);\n                // When going from the server to the client, we may end up in a situation where there's\n                // already a container on the page, but we don't have a reference to it. Clear the\n                // old container so we don't get duplicates. Doing this, instead of emptying the previous\n                // container, should be slightly faster.\n                if (preExistingContainer) {\n                    preExistingContainer.parentNode.removeChild(preExistingContainer);\n                }\n                messagesContainer = this._document.createElement('div');\n                messagesContainer.id = MESSAGES_CONTAINER_ID;\n                messagesContainer.setAttribute('aria-hidden', 'true');\n                messagesContainer.style.display = 'none';\n                this._document.body.appendChild(messagesContainer);\n            }\n        };\n        /** Deletes the global messages container. */\n        AriaDescriber.prototype._deleteMessagesContainer = function () {\n            if (messagesContainer && messagesContainer.parentNode) {\n                messagesContainer.parentNode.removeChild(messagesContainer);\n                messagesContainer = null;\n            }\n        };\n        /** Removes all cdk-describedby messages that are hosted through the element. */\n        AriaDescriber.prototype._removeCdkDescribedByReferenceIds = function (element) {\n            // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n            var originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n                .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n            element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n        };\n        /**\n         * Adds a message reference to the element using aria-describedby and increments the registered\n         * message's reference count.\n         */\n        AriaDescriber.prototype._addMessageReference = function (element, message) {\n            var registeredMessage = messageRegistry.get(message);\n            // Add the aria-describedby reference and set the\n            // describedby_host attribute to mark the element.\n            addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n            element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n            registeredMessage.referenceCount++;\n        };\n        /**\n         * Removes a message reference from the element using aria-describedby\n         * and decrements the registered message's reference count.\n         */\n        AriaDescriber.prototype._removeMessageReference = function (element, message) {\n            var registeredMessage = messageRegistry.get(message);\n            registeredMessage.referenceCount--;\n            removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n            element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        };\n        /** Returns true if the element has been described by the provided message ID. */\n        AriaDescriber.prototype._isElementDescribedByMessage = function (element, message) {\n            var referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n            var registeredMessage = messageRegistry.get(message);\n            var messageId = registeredMessage && registeredMessage.messageElement.id;\n            return !!messageId && referenceIds.indexOf(messageId) != -1;\n        };\n        /** Determines whether a message can be described on a particular element. */\n        AriaDescriber.prototype._canBeDescribed = function (element, message) {\n            if (!this._isElementNode(element)) {\n                return false;\n            }\n            if (message && typeof message === 'object') {\n                // We'd have to make some assumptions about the description element's text, if the consumer\n                // passed in an element. Assume that if an element is passed in, the consumer has verified\n                // that it can be used as a description.\n                return true;\n            }\n            var trimmedMessage = message == null ? '' : (\"\" + message).trim();\n            var ariaLabel = element.getAttribute('aria-label');\n            // We shouldn't set descriptions if they're exactly the same as the `aria-label` of the\n            // element, because screen readers will end up reading out the same text twice in a row.\n            return trimmedMessage ? (!ariaLabel || ariaLabel.trim() !== trimmedMessage) : false;\n        };\n        /** Checks whether a node is an Element node. */\n        AriaDescriber.prototype._isElementNode = function (element) {\n            return element.nodeType === this._document.ELEMENT_NODE;\n        };\n        AriaDescriber.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        AriaDescriber.ctorParameters = function () { return [\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] }\n        ]; };\n        AriaDescriber.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function AriaDescriber_Factory() { return new AriaDescriber(i0.ɵɵinject(i2.DOCUMENT)); }, token: AriaDescriber, providedIn: \"root\" });\n        return AriaDescriber;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * This class manages keyboard events for selectable lists. If you pass it a query list\n     * of items, it will set the active item correctly when arrow events occur.\n     */\n    var ListKeyManager = /** @class */ (function () {\n        function ListKeyManager(_items) {\n            var _this = this;\n            this._items = _items;\n            this._activeItemIndex = -1;\n            this._activeItem = null;\n            this._wrap = false;\n            this._letterKeyStream = new rxjs.Subject();\n            this._typeaheadSubscription = rxjs.Subscription.EMPTY;\n            this._vertical = true;\n            this._allowedModifierKeys = [];\n            /**\n             * Predicate function that can be used to check whether an item should be skipped\n             * by the key manager. By default, disabled items are skipped.\n             */\n            this._skipPredicateFn = function (item) { return item.disabled; };\n            // Buffer for the letters that the user has pressed when the typeahead option is turned on.\n            this._pressedLetters = [];\n            /**\n             * Stream that emits any time the TAB key is pressed, so components can react\n             * when focus is shifted off of the list.\n             */\n            this.tabOut = new rxjs.Subject();\n            /** Stream that emits whenever the active item of the list manager changes. */\n            this.change = new rxjs.Subject();\n            // We allow for the items to be an array because, in some cases, the consumer may\n            // not have access to a QueryList of the items they want to manage (e.g. when the\n            // items aren't being collected via `ViewChildren` or `ContentChildren`).\n            if (_items instanceof i0.QueryList) {\n                _items.changes.subscribe(function (newItems) {\n                    if (_this._activeItem) {\n                        var itemArray = newItems.toArray();\n                        var newIndex = itemArray.indexOf(_this._activeItem);\n                        if (newIndex > -1 && newIndex !== _this._activeItemIndex) {\n                            _this._activeItemIndex = newIndex;\n                        }\n                    }\n                });\n            }\n        }\n        /**\n         * Sets the predicate function that determines which items should be skipped by the\n         * list key manager.\n         * @param predicate Function that determines whether the given item should be skipped.\n         */\n        ListKeyManager.prototype.skipPredicate = function (predicate) {\n            this._skipPredicateFn = predicate;\n            return this;\n        };\n        /**\n         * Configures wrapping mode, which determines whether the active item will wrap to\n         * the other end of list when there are no more items in the given direction.\n         * @param shouldWrap Whether the list should wrap when reaching the end.\n         */\n        ListKeyManager.prototype.withWrap = function (shouldWrap) {\n            if (shouldWrap === void 0) { shouldWrap = true; }\n            this._wrap = shouldWrap;\n            return this;\n        };\n        /**\n         * Configures whether the key manager should be able to move the selection vertically.\n         * @param enabled Whether vertical selection should be enabled.\n         */\n        ListKeyManager.prototype.withVerticalOrientation = function (enabled) {\n            if (enabled === void 0) { enabled = true; }\n            this._vertical = enabled;\n            return this;\n        };\n        /**\n         * Configures the key manager to move the selection horizontally.\n         * Passing in `null` will disable horizontal movement.\n         * @param direction Direction in which the selection can be moved.\n         */\n        ListKeyManager.prototype.withHorizontalOrientation = function (direction) {\n            this._horizontal = direction;\n            return this;\n        };\n        /**\n         * Modifier keys which are allowed to be held down and whose default actions will be prevented\n         * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n         */\n        ListKeyManager.prototype.withAllowedModifierKeys = function (keys) {\n            this._allowedModifierKeys = keys;\n            return this;\n        };\n        /**\n         * Turns on typeahead mode which allows users to set the active item by typing.\n         * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n         */\n        ListKeyManager.prototype.withTypeAhead = function (debounceInterval) {\n            var _this = this;\n            if (debounceInterval === void 0) { debounceInterval = 200; }\n            if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n                throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n            }\n            this._typeaheadSubscription.unsubscribe();\n            // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n            // and convert those letters back into a string. Afterwards find the first item that starts\n            // with that string and select it.\n            this._typeaheadSubscription = this._letterKeyStream.pipe(operators.tap(function (keyCode) { return _this._pressedLetters.push(keyCode); }), operators.debounceTime(debounceInterval), operators.filter(function () { return _this._pressedLetters.length > 0; }), operators.map(function () { return _this._pressedLetters.join(''); })).subscribe(function (inputString) {\n                var items = _this._getItemsArray();\n                // Start at 1 because we want to start searching at the item immediately\n                // following the current active item.\n                for (var i = 1; i < items.length + 1; i++) {\n                    var index = (_this._activeItemIndex + i) % items.length;\n                    var item = items[index];\n                    if (!_this._skipPredicateFn(item) &&\n                        item.getLabel().toUpperCase().trim().indexOf(inputString) === 0) {\n                        _this.setActiveItem(index);\n                        break;\n                    }\n                }\n                _this._pressedLetters = [];\n            });\n            return this;\n        };\n        ListKeyManager.prototype.setActiveItem = function (item) {\n            var previousIndex = this._activeItemIndex;\n            this.updateActiveItem(item);\n            if (this._activeItemIndex !== previousIndex) {\n                this.change.next(this._activeItemIndex);\n            }\n        };\n        /**\n         * Sets the active item depending on the key event passed in.\n         * @param event Keyboard event to be used for determining which element should be active.\n         */\n        ListKeyManager.prototype.onKeydown = function (event) {\n            var _this = this;\n            var keyCode = event.keyCode;\n            var modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n            var isModifierAllowed = modifiers.every(function (modifier) {\n                return !event[modifier] || _this._allowedModifierKeys.indexOf(modifier) > -1;\n            });\n            switch (keyCode) {\n                case keycodes.TAB:\n                    this.tabOut.next();\n                    return;\n                case keycodes.DOWN_ARROW:\n                    if (this._vertical && isModifierAllowed) {\n                        this.setNextItemActive();\n                        break;\n                    }\n                    else {\n                        return;\n                    }\n                case keycodes.UP_ARROW:\n                    if (this._vertical && isModifierAllowed) {\n                        this.setPreviousItemActive();\n                        break;\n                    }\n                    else {\n                        return;\n                    }\n                case keycodes.RIGHT_ARROW:\n                    if (this._horizontal && isModifierAllowed) {\n                        this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n                        break;\n                    }\n                    else {\n                        return;\n                    }\n                case keycodes.LEFT_ARROW:\n                    if (this._horizontal && isModifierAllowed) {\n                        this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n                        break;\n                    }\n                    else {\n                        return;\n                    }\n                default:\n                    if (isModifierAllowed || keycodes.hasModifierKey(event, 'shiftKey')) {\n                        // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                        // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                        if (event.key && event.key.length === 1) {\n                            this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                        }\n                        else if ((keyCode >= keycodes.A && keyCode <= keycodes.Z) || (keyCode >= keycodes.ZERO && keyCode <= keycodes.NINE)) {\n                            this._letterKeyStream.next(String.fromCharCode(keyCode));\n                        }\n                    }\n                    // Note that we return here, in order to avoid preventing\n                    // the default action of non-navigational keys.\n                    return;\n            }\n            this._pressedLetters = [];\n            event.preventDefault();\n        };\n        Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n            /** Index of the currently active item. */\n            get: function () {\n                return this._activeItemIndex;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n            /** The active item. */\n            get: function () {\n                return this._activeItem;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Sets the active item to the first enabled item in the list. */\n        ListKeyManager.prototype.setFirstItemActive = function () {\n            this._setActiveItemByIndex(0, 1);\n        };\n        /** Sets the active item to the last enabled item in the list. */\n        ListKeyManager.prototype.setLastItemActive = function () {\n            this._setActiveItemByIndex(this._items.length - 1, -1);\n        };\n        /** Sets the active item to the next enabled item in the list. */\n        ListKeyManager.prototype.setNextItemActive = function () {\n            this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n        };\n        /** Sets the active item to a previous enabled item in the list. */\n        ListKeyManager.prototype.setPreviousItemActive = function () {\n            this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n                : this._setActiveItemByDelta(-1);\n        };\n        ListKeyManager.prototype.updateActiveItem = function (item) {\n            var itemArray = this._getItemsArray();\n            var index = typeof item === 'number' ? item : itemArray.indexOf(item);\n            var activeItem = itemArray[index];\n            // Explicitly check for `null` and `undefined` because other falsy values are valid.\n            this._activeItem = activeItem == null ? null : activeItem;\n            this._activeItemIndex = index;\n        };\n        /**\n         * This method sets the active item, given a list of items and the delta between the\n         * currently active item and the new active item. It will calculate differently\n         * depending on whether wrap mode is turned on.\n         */\n        ListKeyManager.prototype._setActiveItemByDelta = function (delta) {\n            this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n        };\n        /**\n         * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n         * down the list until it finds an item that is not disabled, and it will wrap if it\n         * encounters either end of the list.\n         */\n        ListKeyManager.prototype._setActiveInWrapMode = function (delta) {\n            var items = this._getItemsArray();\n            for (var i = 1; i <= items.length; i++) {\n                var index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\n                var item = items[index];\n                if (!this._skipPredicateFn(item)) {\n                    this.setActiveItem(index);\n                    return;\n                }\n            }\n        };\n        /**\n         * Sets the active item properly given the default mode. In other words, it will\n         * continue to move down the list until it finds an item that is not disabled. If\n         * it encounters either end of the list, it will stop and not wrap.\n         */\n        ListKeyManager.prototype._setActiveInDefaultMode = function (delta) {\n            this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n        };\n        /**\n         * Sets the active item to the first enabled item starting at the index specified. If the\n         * item is disabled, it will move in the fallbackDelta direction until it either\n         * finds an enabled item or encounters the end of the list.\n         */\n        ListKeyManager.prototype._setActiveItemByIndex = function (index, fallbackDelta) {\n            var items = this._getItemsArray();\n            if (!items[index]) {\n                return;\n            }\n            while (this._skipPredicateFn(items[index])) {\n                index += fallbackDelta;\n                if (!items[index]) {\n                    return;\n                }\n            }\n            this.setActiveItem(index);\n        };\n        /** Returns the items as an array. */\n        ListKeyManager.prototype._getItemsArray = function () {\n            return this._items instanceof i0.QueryList ? this._items.toArray() : this._items;\n        };\n        return ListKeyManager;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var ActiveDescendantKeyManager = /** @class */ (function (_super) {\n        tslib_1.__extends(ActiveDescendantKeyManager, _super);\n        function ActiveDescendantKeyManager() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        ActiveDescendantKeyManager.prototype.setActiveItem = function (index) {\n            if (this.activeItem) {\n                this.activeItem.setInactiveStyles();\n            }\n            _super.prototype.setActiveItem.call(this, index);\n            if (this.activeItem) {\n                this.activeItem.setActiveStyles();\n            }\n        };\n        return ActiveDescendantKeyManager;\n    }(ListKeyManager));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var FocusKeyManager = /** @class */ (function (_super) {\n        tslib_1.__extends(FocusKeyManager, _super);\n        function FocusKeyManager() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this._origin = 'program';\n            return _this;\n        }\n        /**\n         * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n         * @param origin Focus origin to be used when focusing items.\n         */\n        FocusKeyManager.prototype.setFocusOrigin = function (origin) {\n            this._origin = origin;\n            return this;\n        };\n        FocusKeyManager.prototype.setActiveItem = function (item) {\n            _super.prototype.setActiveItem.call(this, item);\n            if (this.activeItem) {\n                this.activeItem.focus(this._origin);\n            }\n        };\n        return FocusKeyManager;\n    }(ListKeyManager));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // The InteractivityChecker leans heavily on the ally.js accessibility utilities.\n    // Methods like `isTabbable` are only covering specific edge-cases for the browsers which are\n    // supported.\n    /**\n     * Utility for checking the interactivity of an element, such as whether is is focusable or\n     * tabbable.\n     */\n    var InteractivityChecker = /** @class */ (function () {\n        function InteractivityChecker(_platform) {\n            this._platform = _platform;\n        }\n        /**\n         * Gets whether an element is disabled.\n         *\n         * @param element Element to be checked.\n         * @returns Whether the element is disabled.\n         */\n        InteractivityChecker.prototype.isDisabled = function (element) {\n            // This does not capture some cases, such as a non-form control with a disabled attribute or\n            // a form control inside of a disabled form, but should capture the most common cases.\n            return element.hasAttribute('disabled');\n        };\n        /**\n         * Gets whether an element is visible for the purposes of interactivity.\n         *\n         * This will capture states like `display: none` and `visibility: hidden`, but not things like\n         * being clipped by an `overflow: hidden` parent or being outside the viewport.\n         *\n         * @returns Whether the element is visible.\n         */\n        InteractivityChecker.prototype.isVisible = function (element) {\n            return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n        };\n        /**\n         * Gets whether an element can be reached via Tab key.\n         * Assumes that the element has already been checked with isFocusable.\n         *\n         * @param element Element to be checked.\n         * @returns Whether the element is tabbable.\n         */\n        InteractivityChecker.prototype.isTabbable = function (element) {\n            // Nothing is tabbable on the server 😎\n            if (!this._platform.isBrowser) {\n                return false;\n            }\n            var frameElement = getFrameElement(getWindow(element));\n            if (frameElement) {\n                var frameType = frameElement && frameElement.nodeName.toLowerCase();\n                // Frame elements inherit their tabindex onto all child elements.\n                if (getTabIndexValue(frameElement) === -1) {\n                    return false;\n                }\n                // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n                if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                    return false;\n                }\n                // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n                if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                    return false;\n                }\n            }\n            var nodeName = element.nodeName.toLowerCase();\n            var tabIndexValue = getTabIndexValue(element);\n            if (element.hasAttribute('contenteditable')) {\n                return tabIndexValue !== -1;\n            }\n            if (nodeName === 'iframe') {\n                // The frames may be tabbable depending on content, but it's not possibly to reliably\n                // investigate the content of the frames.\n                return false;\n            }\n            if (nodeName === 'audio') {\n                if (!element.hasAttribute('controls')) {\n                    // By default an <audio> element without the controls enabled is not tabbable.\n                    return false;\n                }\n                else if (this._platform.BLINK) {\n                    // In Blink <audio controls> elements are always tabbable.\n                    return true;\n                }\n            }\n            if (nodeName === 'video') {\n                if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                    // In Trident a <video> element without the controls enabled is not tabbable.\n                    return false;\n                }\n                else if (this._platform.BLINK || this._platform.FIREFOX) {\n                    // In Chrome and Firefox <video controls> elements are always tabbable.\n                    return true;\n                }\n            }\n            if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n                // In all Blink and WebKit based browsers <object> elements are never tabbable.\n                return false;\n            }\n            // In iOS the browser only considers some specific elements as tabbable.\n            if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n                return false;\n            }\n            return element.tabIndex >= 0;\n        };\n        /**\n         * Gets whether an element can be focused by the user.\n         *\n         * @param element Element to be checked.\n         * @returns Whether the element is focusable.\n         */\n        InteractivityChecker.prototype.isFocusable = function (element) {\n            // Perform checks in order of left to most expensive.\n            // Again, naive approach that does not capture many edge cases and browser quirks.\n            return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n        };\n        InteractivityChecker.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        InteractivityChecker.ctorParameters = function () { return [\n            { type: i1.Platform }\n        ]; };\n        InteractivityChecker.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function InteractivityChecker_Factory() { return new InteractivityChecker(i0.ɵɵinject(i1.Platform)); }, token: InteractivityChecker, providedIn: \"root\" });\n        return InteractivityChecker;\n    }());\n    /**\n     * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n     * the frameElement property is being accessed from a different host address, this property\n     * should be accessed carefully.\n     */\n    function getFrameElement(window) {\n        try {\n            return window.frameElement;\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n    /** Checks whether the specified element has any geometry / rectangles. */\n    function hasGeometry(element) {\n        // Use logic from jQuery to check for an invisible element.\n        // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n        return !!(element.offsetWidth || element.offsetHeight ||\n            (typeof element.getClientRects === 'function' && element.getClientRects().length));\n    }\n    /** Gets whether an element's  */\n    function isNativeFormElement(element) {\n        var nodeName = element.nodeName.toLowerCase();\n        return nodeName === 'input' ||\n            nodeName === 'select' ||\n            nodeName === 'button' ||\n            nodeName === 'textarea';\n    }\n    /** Gets whether an element is an `<input type=\"hidden\">`. */\n    function isHiddenInput(element) {\n        return isInputElement(element) && element.type == 'hidden';\n    }\n    /** Gets whether an element is an anchor that has an href attribute. */\n    function isAnchorWithHref(element) {\n        return isAnchorElement(element) && element.hasAttribute('href');\n    }\n    /** Gets whether an element is an input element. */\n    function isInputElement(element) {\n        return element.nodeName.toLowerCase() == 'input';\n    }\n    /** Gets whether an element is an anchor element. */\n    function isAnchorElement(element) {\n        return element.nodeName.toLowerCase() == 'a';\n    }\n    /** Gets whether an element has a valid tabindex. */\n    function hasValidTabIndex(element) {\n        if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n            return false;\n        }\n        var tabIndex = element.getAttribute('tabindex');\n        // IE11 parses tabindex=\"\" as the value \"-32768\"\n        if (tabIndex == '-32768') {\n            return false;\n        }\n        return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n    }\n    /**\n     * Returns the parsed tabindex from the element attributes instead of returning the\n     * evaluated tabindex from the browsers defaults.\n     */\n    function getTabIndexValue(element) {\n        if (!hasValidTabIndex(element)) {\n            return null;\n        }\n        // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n        var tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n        return isNaN(tabIndex) ? -1 : tabIndex;\n    }\n    /** Checks whether the specified element is potentially tabbable on iOS */\n    function isPotentiallyTabbableIOS(element) {\n        var nodeName = element.nodeName.toLowerCase();\n        var inputType = nodeName === 'input' && element.type;\n        return inputType === 'text'\n            || inputType === 'password'\n            || nodeName === 'select'\n            || nodeName === 'textarea';\n    }\n    /**\n     * Gets whether an element is potentially focusable without taking current visible/disabled state\n     * into account.\n     */\n    function isPotentiallyFocusable(element) {\n        // Inputs are potentially focusable *unless* they're type=\"hidden\".\n        if (isHiddenInput(element)) {\n            return false;\n        }\n        return isNativeFormElement(element) ||\n            isAnchorWithHref(element) ||\n            element.hasAttribute('contenteditable') ||\n            hasValidTabIndex(element);\n    }\n    /** Gets the parent window of a DOM node with regards of being inside of an iframe. */\n    function getWindow(node) {\n        // ownerDocument is null if `node` itself *is* a document.\n        return node.ownerDocument && node.ownerDocument.defaultView || window;\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Class that allows for trapping focus within a DOM element.\n     *\n     * This class currently uses a relatively simple approach to focus trapping.\n     * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n     * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.\n     */\n    var FocusTrap = /** @class */ (function () {\n        function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {\n            var _this = this;\n            if (deferAnchors === void 0) { deferAnchors = false; }\n            this._element = _element;\n            this._checker = _checker;\n            this._ngZone = _ngZone;\n            this._document = _document;\n            this._hasAttached = false;\n            // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.\n            this.startAnchorListener = function () { return _this.focusLastTabbableElement(); };\n            this.endAnchorListener = function () { return _this.focusFirstTabbableElement(); };\n            this._enabled = true;\n            if (!deferAnchors) {\n                this.attachAnchors();\n            }\n        }\n        Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n            /** Whether the focus trap is active. */\n            get: function () { return this._enabled; },\n            set: function (value) {\n                this._enabled = value;\n                if (this._startAnchor && this._endAnchor) {\n                    this._toggleAnchorTabIndex(value, this._startAnchor);\n                    this._toggleAnchorTabIndex(value, this._endAnchor);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Destroys the focus trap by cleaning up the anchors. */\n        FocusTrap.prototype.destroy = function () {\n            var startAnchor = this._startAnchor;\n            var endAnchor = this._endAnchor;\n            if (startAnchor) {\n                startAnchor.removeEventListener('focus', this.startAnchorListener);\n                if (startAnchor.parentNode) {\n                    startAnchor.parentNode.removeChild(startAnchor);\n                }\n            }\n            if (endAnchor) {\n                endAnchor.removeEventListener('focus', this.endAnchorListener);\n                if (endAnchor.parentNode) {\n                    endAnchor.parentNode.removeChild(endAnchor);\n                }\n            }\n            this._startAnchor = this._endAnchor = null;\n        };\n        /**\n         * Inserts the anchors into the DOM. This is usually done automatically\n         * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n         * @returns Whether the focus trap managed to attach successfuly. This may not be the case\n         * if the target element isn't currently in the DOM.\n         */\n        FocusTrap.prototype.attachAnchors = function () {\n            var _this = this;\n            // If we're not on the browser, there can be no focus to trap.\n            if (this._hasAttached) {\n                return true;\n            }\n            this._ngZone.runOutsideAngular(function () {\n                if (!_this._startAnchor) {\n                    _this._startAnchor = _this._createAnchor();\n                    _this._startAnchor.addEventListener('focus', _this.startAnchorListener);\n                }\n                if (!_this._endAnchor) {\n                    _this._endAnchor = _this._createAnchor();\n                    _this._endAnchor.addEventListener('focus', _this.endAnchorListener);\n                }\n            });\n            if (this._element.parentNode) {\n                this._element.parentNode.insertBefore(this._startAnchor, this._element);\n                this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);\n                this._hasAttached = true;\n            }\n            return this._hasAttached;\n        };\n        /**\n         * Waits for the zone to stabilize, then either focuses the first element that the\n         * user specified, or the first tabbable element.\n         * @returns Returns a promise that resolves with a boolean, depending\n         * on whether focus was moved successfuly.\n         */\n        FocusTrap.prototype.focusInitialElementWhenReady = function () {\n            var _this = this;\n            return new Promise(function (resolve) {\n                _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n            });\n        };\n        /**\n         * Waits for the zone to stabilize, then focuses\n         * the first tabbable element within the focus trap region.\n         * @returns Returns a promise that resolves with a boolean, depending\n         * on whether focus was moved successfuly.\n         */\n        FocusTrap.prototype.focusFirstTabbableElementWhenReady = function () {\n            var _this = this;\n            return new Promise(function (resolve) {\n                _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n            });\n        };\n        /**\n         * Waits for the zone to stabilize, then focuses\n         * the last tabbable element within the focus trap region.\n         * @returns Returns a promise that resolves with a boolean, depending\n         * on whether focus was moved successfuly.\n         */\n        FocusTrap.prototype.focusLastTabbableElementWhenReady = function () {\n            var _this = this;\n            return new Promise(function (resolve) {\n                _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n            });\n        };\n        /**\n         * Get the specified boundary element of the trapped region.\n         * @param bound The boundary to get (start or end of trapped region).\n         * @returns The boundary element.\n         */\n        FocusTrap.prototype._getRegionBoundary = function (bound) {\n            // Contains the deprecated version of selector, for temporary backwards comparability.\n            var markers = this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n                (\"[cdkFocusRegion\" + bound + \"], \") +\n                (\"[cdk-focus-\" + bound + \"]\"));\n            for (var i = 0; i < markers.length; i++) {\n                // @breaking-change 8.0.0\n                if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                    console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"', \" +\n                        (\"use 'cdkFocusRegion\" + bound + \"' instead. The deprecated \") +\n                        \"attribute will be removed in 8.0.0.\", markers[i]);\n                }\n                else if (markers[i].hasAttribute(\"cdk-focus-region-\" + bound)) {\n                    console.warn(\"Found use of deprecated attribute 'cdk-focus-region-\" + bound + \"', \" +\n                        (\"use 'cdkFocusRegion\" + bound + \"' instead. The deprecated attribute \") +\n                        \"will be removed in 8.0.0.\", markers[i]);\n                }\n            }\n            if (bound == 'start') {\n                return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n            }\n            return markers.length ?\n                markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n        };\n        /**\n         * Focuses the element that should be focused when the focus trap is initialized.\n         * @returns Whether focus was moved successfuly.\n         */\n        FocusTrap.prototype.focusInitialElement = function () {\n            // Contains the deprecated version of selector, for temporary backwards comparability.\n            var redirectToElement = this._element.querySelector(\"[cdk-focus-initial], \" +\n                \"[cdkFocusInitial]\");\n            if (redirectToElement) {\n                // @breaking-change 8.0.0\n                if (redirectToElement.hasAttribute(\"cdk-focus-initial\")) {\n                    console.warn(\"Found use of deprecated attribute 'cdk-focus-initial', \" +\n                        \"use 'cdkFocusInitial' instead. The deprecated attribute \" +\n                        \"will be removed in 8.0.0\", redirectToElement);\n                }\n                // Warn the consumer if the element they've pointed to\n                // isn't focusable, when not in production mode.\n                if (i0.isDevMode() && !this._checker.isFocusable(redirectToElement)) {\n                    console.warn(\"Element matching '[cdkFocusInitial]' is not focusable.\", redirectToElement);\n                }\n                redirectToElement.focus();\n                return true;\n            }\n            return this.focusFirstTabbableElement();\n        };\n        /**\n         * Focuses the first tabbable element within the focus trap region.\n         * @returns Whether focus was moved successfuly.\n         */\n        FocusTrap.prototype.focusFirstTabbableElement = function () {\n            var redirectToElement = this._getRegionBoundary('start');\n            if (redirectToElement) {\n                redirectToElement.focus();\n            }\n            return !!redirectToElement;\n        };\n        /**\n         * Focuses the last tabbable element within the focus trap region.\n         * @returns Whether focus was moved successfuly.\n         */\n        FocusTrap.prototype.focusLastTabbableElement = function () {\n            var redirectToElement = this._getRegionBoundary('end');\n            if (redirectToElement) {\n                redirectToElement.focus();\n            }\n            return !!redirectToElement;\n        };\n        /**\n         * Checks whether the focus trap has successfuly been attached.\n         */\n        FocusTrap.prototype.hasAttached = function () {\n            return this._hasAttached;\n        };\n        /** Get the first tabbable element from a DOM subtree (inclusive). */\n        FocusTrap.prototype._getFirstTabbableElement = function (root) {\n            if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n                return root;\n            }\n            // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n            // back to `childNodes` which includes text nodes, comments etc.\n            var children = root.children || root.childNodes;\n            for (var i = 0; i < children.length; i++) {\n                var tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                    this._getFirstTabbableElement(children[i]) :\n                    null;\n                if (tabbableChild) {\n                    return tabbableChild;\n                }\n            }\n            return null;\n        };\n        /** Get the last tabbable element from a DOM subtree (inclusive). */\n        FocusTrap.prototype._getLastTabbableElement = function (root) {\n            if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n                return root;\n            }\n            // Iterate in reverse DOM order.\n            var children = root.children || root.childNodes;\n            for (var i = children.length - 1; i >= 0; i--) {\n                var tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                    this._getLastTabbableElement(children[i]) :\n                    null;\n                if (tabbableChild) {\n                    return tabbableChild;\n                }\n            }\n            return null;\n        };\n        /** Creates an anchor element. */\n        FocusTrap.prototype._createAnchor = function () {\n            var anchor = this._document.createElement('div');\n            this._toggleAnchorTabIndex(this._enabled, anchor);\n            anchor.classList.add('cdk-visually-hidden');\n            anchor.classList.add('cdk-focus-trap-anchor');\n            anchor.setAttribute('aria-hidden', 'true');\n            return anchor;\n        };\n        /**\n         * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\n         * @param isEnabled Whether the focus trap is enabled.\n         * @param anchor Anchor on which to toggle the tabindex.\n         */\n        FocusTrap.prototype._toggleAnchorTabIndex = function (isEnabled, anchor) {\n            // Remove the tabindex completely, rather than setting it to -1, because if the\n            // element has a tabindex, the user might still hit it when navigating with the arrow keys.\n            isEnabled ? anchor.setAttribute('tabindex', '0') : anchor.removeAttribute('tabindex');\n        };\n        /** Executes a function when the zone is stable. */\n        FocusTrap.prototype._executeOnStable = function (fn) {\n            if (this._ngZone.isStable) {\n                fn();\n            }\n            else {\n                this._ngZone.onStable.asObservable().pipe(operators.take(1)).subscribe(fn);\n            }\n        };\n        return FocusTrap;\n    }());\n    /** Factory that allows easy instantiation of focus traps. */\n    var FocusTrapFactory = /** @class */ (function () {\n        function FocusTrapFactory(_checker, _ngZone, _document) {\n            this._checker = _checker;\n            this._ngZone = _ngZone;\n            this._document = _document;\n        }\n        /**\n         * Creates a focus-trapped region around the given element.\n         * @param element The element around which focus will be trapped.\n         * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n         *     manually by the user.\n         * @returns The created focus trap instance.\n         */\n        FocusTrapFactory.prototype.create = function (element, deferCaptureElements) {\n            if (deferCaptureElements === void 0) { deferCaptureElements = false; }\n            return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n        };\n        FocusTrapFactory.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        FocusTrapFactory.ctorParameters = function () { return [\n            { type: InteractivityChecker },\n            { type: i0.NgZone },\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] }\n        ]; };\n        FocusTrapFactory.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function FocusTrapFactory_Factory() { return new FocusTrapFactory(i0.ɵɵinject(InteractivityChecker), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i2.DOCUMENT)); }, token: FocusTrapFactory, providedIn: \"root\" });\n        return FocusTrapFactory;\n    }());\n    /** Directive for trapping focus within a region. */\n    var CdkTrapFocus = /** @class */ (function () {\n        function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {\n            this._elementRef = _elementRef;\n            this._focusTrapFactory = _focusTrapFactory;\n            /** Previously focused element to restore focus to upon destroy when using autoCapture. */\n            this._previouslyFocusedElement = null;\n            this._document = _document;\n            this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n        }\n        Object.defineProperty(CdkTrapFocus.prototype, \"enabled\", {\n            /** Whether the focus trap is active. */\n            get: function () { return this.focusTrap.enabled; },\n            set: function (value) { this.focusTrap.enabled = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CdkTrapFocus.prototype, \"autoCapture\", {\n            /**\n             * Whether the directive should automatially move focus into the trapped region upon\n             * initialization and return focus to the previous activeElement upon destruction.\n             */\n            get: function () { return this._autoCapture; },\n            set: function (value) { this._autoCapture = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        CdkTrapFocus.prototype.ngOnDestroy = function () {\n            this.focusTrap.destroy();\n            // If we stored a previously focused element when using autoCapture, return focus to that\n            // element now that the trapped region is being destroyed.\n            if (this._previouslyFocusedElement) {\n                this._previouslyFocusedElement.focus();\n                this._previouslyFocusedElement = null;\n            }\n        };\n        CdkTrapFocus.prototype.ngAfterContentInit = function () {\n            this.focusTrap.attachAnchors();\n            if (this.autoCapture) {\n                this._previouslyFocusedElement = this._document.activeElement;\n                this.focusTrap.focusInitialElementWhenReady();\n            }\n        };\n        CdkTrapFocus.prototype.ngDoCheck = function () {\n            if (!this.focusTrap.hasAttached()) {\n                this.focusTrap.attachAnchors();\n            }\n        };\n        CdkTrapFocus.decorators = [\n            { type: i0.Directive, args: [{\n                        selector: '[cdkTrapFocus]',\n                        exportAs: 'cdkTrapFocus',\n                    },] }\n        ];\n        /** @nocollapse */\n        CdkTrapFocus.ctorParameters = function () { return [\n            { type: i0.ElementRef },\n            { type: FocusTrapFactory },\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] }\n        ]; };\n        CdkTrapFocus.propDecorators = {\n            enabled: [{ type: i0.Input, args: ['cdkTrapFocus',] }],\n            autoCapture: [{ type: i0.Input, args: ['cdkTrapFocusAutoCapture',] }]\n        };\n        return CdkTrapFocus;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var LIVE_ANNOUNCER_ELEMENT_TOKEN = new i0.InjectionToken('liveAnnouncerElement', {\n        providedIn: 'root',\n        factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\n    });\n    /** @docs-private */\n    function LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {\n        return null;\n    }\n    /** Injection token that can be used to configure the default options for the LiveAnnouncer. */\n    var LIVE_ANNOUNCER_DEFAULT_OPTIONS = new i0.InjectionToken('LIVE_ANNOUNCER_DEFAULT_OPTIONS');\n\n    var LiveAnnouncer = /** @class */ (function () {\n        function LiveAnnouncer(elementToken, _ngZone, _document, _defaultOptions) {\n            this._ngZone = _ngZone;\n            this._defaultOptions = _defaultOptions;\n            // We inject the live element and document as `any` because the constructor signature cannot\n            // reference browser globals (HTMLElement, Document) on non-browser environments, since having\n            // a class decorator causes TypeScript to preserve the constructor signature types.\n            this._document = _document;\n            this._liveElement = elementToken || this._createLiveElement();\n        }\n        LiveAnnouncer.prototype.announce = function (message) {\n            var _a;\n            var _this = this;\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            var defaultOptions = this._defaultOptions;\n            var politeness;\n            var duration;\n            if (args.length === 1 && typeof args[0] === 'number') {\n                duration = args[0];\n            }\n            else {\n                _a = tslib_1.__read(args, 2), politeness = _a[0], duration = _a[1];\n            }\n            this.clear();\n            clearTimeout(this._previousTimeout);\n            if (!politeness) {\n                politeness =\n                    (defaultOptions && defaultOptions.politeness) ? defaultOptions.politeness : 'polite';\n            }\n            if (duration == null && defaultOptions) {\n                duration = defaultOptions.duration;\n            }\n            // TODO: ensure changing the politeness works on all environments we support.\n            this._liveElement.setAttribute('aria-live', politeness);\n            // This 100ms timeout is necessary for some browser + screen-reader combinations:\n            // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n            // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n            //   second time without clearing and then using a non-zero delay.\n            // (using JAWS 17 at time of this writing).\n            return this._ngZone.runOutsideAngular(function () {\n                return new Promise(function (resolve) {\n                    clearTimeout(_this._previousTimeout);\n                    _this._previousTimeout = setTimeout(function () {\n                        _this._liveElement.textContent = message;\n                        resolve();\n                        if (typeof duration === 'number') {\n                            _this._previousTimeout = setTimeout(function () { return _this.clear(); }, duration);\n                        }\n                    }, 100);\n                });\n            });\n        };\n        /**\n         * Clears the current text from the announcer element. Can be used to prevent\n         * screen readers from reading the text out again while the user is going\n         * through the page landmarks.\n         */\n        LiveAnnouncer.prototype.clear = function () {\n            if (this._liveElement) {\n                this._liveElement.textContent = '';\n            }\n        };\n        LiveAnnouncer.prototype.ngOnDestroy = function () {\n            clearTimeout(this._previousTimeout);\n            if (this._liveElement && this._liveElement.parentNode) {\n                this._liveElement.parentNode.removeChild(this._liveElement);\n                this._liveElement = null;\n            }\n        };\n        LiveAnnouncer.prototype._createLiveElement = function () {\n            var elementClass = 'cdk-live-announcer-element';\n            var previousElements = this._document.getElementsByClassName(elementClass);\n            var liveEl = this._document.createElement('div');\n            // Remove any old containers. This can happen when coming in from a server-side-rendered page.\n            for (var i = 0; i < previousElements.length; i++) {\n                previousElements[i].parentNode.removeChild(previousElements[i]);\n            }\n            liveEl.classList.add(elementClass);\n            liveEl.classList.add('cdk-visually-hidden');\n            liveEl.setAttribute('aria-atomic', 'true');\n            liveEl.setAttribute('aria-live', 'polite');\n            this._document.body.appendChild(liveEl);\n            return liveEl;\n        };\n        LiveAnnouncer.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        LiveAnnouncer.ctorParameters = function () { return [\n            { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] }] },\n            { type: i0.NgZone },\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },\n            { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [LIVE_ANNOUNCER_DEFAULT_OPTIONS,] }] }\n        ]; };\n        LiveAnnouncer.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function LiveAnnouncer_Factory() { return new LiveAnnouncer(i0.ɵɵinject(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i2.DOCUMENT), i0.ɵɵinject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8)); }, token: LiveAnnouncer, providedIn: \"root\" });\n        return LiveAnnouncer;\n    }());\n    /**\n     * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\n     * with a wider range of browsers and screen readers.\n     */\n    var CdkAriaLive = /** @class */ (function () {\n        function CdkAriaLive(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {\n            this._elementRef = _elementRef;\n            this._liveAnnouncer = _liveAnnouncer;\n            this._contentObserver = _contentObserver;\n            this._ngZone = _ngZone;\n            this._politeness = 'off';\n        }\n        Object.defineProperty(CdkAriaLive.prototype, \"politeness\", {\n            /** The aria-live politeness level to use when announcing messages. */\n            get: function () { return this._politeness; },\n            set: function (value) {\n                var _this = this;\n                this._politeness = value === 'polite' || value === 'assertive' ? value : 'off';\n                if (this._politeness === 'off') {\n                    if (this._subscription) {\n                        this._subscription.unsubscribe();\n                        this._subscription = null;\n                    }\n                }\n                else if (!this._subscription) {\n                    this._subscription = this._ngZone.runOutsideAngular(function () {\n                        return _this._contentObserver\n                            .observe(_this._elementRef)\n                            .subscribe(function () {\n                            // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\n                            var elementText = _this._elementRef.nativeElement.textContent;\n                            // The `MutationObserver` fires also for attribute\n                            // changes which we don't want to announce.\n                            if (elementText !== _this._previousAnnouncedText) {\n                                _this._liveAnnouncer.announce(elementText, _this._politeness);\n                                _this._previousAnnouncedText = elementText;\n                            }\n                        });\n                    });\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        CdkAriaLive.prototype.ngOnDestroy = function () {\n            if (this._subscription) {\n                this._subscription.unsubscribe();\n            }\n        };\n        CdkAriaLive.decorators = [\n            { type: i0.Directive, args: [{\n                        selector: '[cdkAriaLive]',\n                        exportAs: 'cdkAriaLive',\n                    },] }\n        ];\n        /** @nocollapse */\n        CdkAriaLive.ctorParameters = function () { return [\n            { type: i0.ElementRef },\n            { type: LiveAnnouncer },\n            { type: observers.ContentObserver },\n            { type: i0.NgZone }\n        ]; };\n        CdkAriaLive.propDecorators = {\n            politeness: [{ type: i0.Input, args: ['cdkAriaLive',] }]\n        };\n        return CdkAriaLive;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n    // that a value of around 650ms seems appropriate.\n    var TOUCH_BUFFER_MS = 650;\n    /**\n     * Event listener options that enable capturing and also\n     * mark the listener as passive if the browser supports it.\n     */\n    var captureEventListenerOptions = i1.normalizePassiveListenerOptions({\n        passive: true,\n        capture: true\n    });\n    /** Monitors mouse and keyboard events to determine the cause of focus events. */\n    var FocusMonitor = /** @class */ (function () {\n        function FocusMonitor(_ngZone, _platform) {\n            var _this = this;\n            this._ngZone = _ngZone;\n            this._platform = _platform;\n            /** The focus origin that the next focus event is a result of. */\n            this._origin = null;\n            /** Whether the window has just been focused. */\n            this._windowFocused = false;\n            /** Map of elements being monitored to their info. */\n            this._elementInfo = new Map();\n            /** The number of elements currently being monitored. */\n            this._monitoredElementCount = 0;\n            /**\n             * Event listener for `keydown` events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._documentKeydownListener = function () {\n                // On keydown record the origin and clear any touch event that may be in progress.\n                _this._lastTouchTarget = null;\n                _this._setOriginForCurrentEventQueue('keyboard');\n            };\n            /**\n             * Event listener for `mousedown` events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._documentMousedownListener = function () {\n                // On mousedown record the origin only if there is not touch\n                // target, since a mousedown can happen as a result of a touch event.\n                if (!_this._lastTouchTarget) {\n                    _this._setOriginForCurrentEventQueue('mouse');\n                }\n            };\n            /**\n             * Event listener for `touchstart` events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._documentTouchstartListener = function (event) {\n                // When the touchstart event fires the focus event is not yet in the event queue. This means\n                // we can't rely on the trick used above (setting timeout of 1ms). Instead we wait 650ms to\n                // see if a focus happens.\n                if (_this._touchTimeoutId != null) {\n                    clearTimeout(_this._touchTimeoutId);\n                }\n                // Since this listener is bound on the `document` level, any events coming from the shadow DOM\n                // will have their `target` set to the shadow root. If available, use `composedPath` to\n                // figure out the event target.\n                _this._lastTouchTarget = event.composedPath ? event.composedPath()[0] : event.target;\n                _this._touchTimeoutId = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n            };\n            /**\n             * Event listener for `focus` events on the window.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._windowFocusListener = function () {\n                // Make a note of when the window regains focus, so we can\n                // restore the origin info for the focused element.\n                _this._windowFocused = true;\n                _this._windowFocusTimeoutId = setTimeout(function () { return _this._windowFocused = false; });\n            };\n        }\n        FocusMonitor.prototype.monitor = function (element, checkChildren) {\n            var _this = this;\n            if (checkChildren === void 0) { checkChildren = false; }\n            // Do nothing if we're not on the browser platform.\n            if (!this._platform.isBrowser) {\n                return rxjs.of(null);\n            }\n            var nativeElement = coercion.coerceElement(element);\n            // Check if we're already monitoring this element.\n            if (this._elementInfo.has(nativeElement)) {\n                var cachedInfo = this._elementInfo.get(nativeElement);\n                cachedInfo.checkChildren = checkChildren;\n                return cachedInfo.subject.asObservable();\n            }\n            // Create monitored element info.\n            var info = {\n                unlisten: function () { },\n                checkChildren: checkChildren,\n                subject: new rxjs.Subject()\n            };\n            this._elementInfo.set(nativeElement, info);\n            this._incrementMonitoredElementCount();\n            // Start listening. We need to listen in capture phase since focus events don't bubble.\n            var focusListener = function (event) { return _this._onFocus(event, nativeElement); };\n            var blurListener = function (event) { return _this._onBlur(event, nativeElement); };\n            this._ngZone.runOutsideAngular(function () {\n                nativeElement.addEventListener('focus', focusListener, true);\n                nativeElement.addEventListener('blur', blurListener, true);\n            });\n            // Create an unlisten function for later.\n            info.unlisten = function () {\n                nativeElement.removeEventListener('focus', focusListener, true);\n                nativeElement.removeEventListener('blur', blurListener, true);\n            };\n            return info.subject.asObservable();\n        };\n        FocusMonitor.prototype.stopMonitoring = function (element) {\n            var nativeElement = coercion.coerceElement(element);\n            var elementInfo = this._elementInfo.get(nativeElement);\n            if (elementInfo) {\n                elementInfo.unlisten();\n                elementInfo.subject.complete();\n                this._setClasses(nativeElement);\n                this._elementInfo.delete(nativeElement);\n                this._decrementMonitoredElementCount();\n            }\n        };\n        FocusMonitor.prototype.focusVia = function (element, origin, options) {\n            var nativeElement = coercion.coerceElement(element);\n            this._setOriginForCurrentEventQueue(origin);\n            // `focus` isn't available on the server\n            if (typeof nativeElement.focus === 'function') {\n                // Cast the element to `any`, because the TS typings don't have the `options` parameter yet.\n                nativeElement.focus(options);\n            }\n        };\n        FocusMonitor.prototype.ngOnDestroy = function () {\n            var _this = this;\n            this._elementInfo.forEach(function (_info, element) { return _this.stopMonitoring(element); });\n        };\n        FocusMonitor.prototype._toggleClass = function (element, className, shouldSet) {\n            if (shouldSet) {\n                element.classList.add(className);\n            }\n            else {\n                element.classList.remove(className);\n            }\n        };\n        /**\n         * Sets the focus classes on the element based on the given focus origin.\n         * @param element The element to update the classes on.\n         * @param origin The focus origin.\n         */\n        FocusMonitor.prototype._setClasses = function (element, origin) {\n            var elementInfo = this._elementInfo.get(element);\n            if (elementInfo) {\n                this._toggleClass(element, 'cdk-focused', !!origin);\n                this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n                this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n                this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n                this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n            }\n        };\n        /**\n         * Sets the origin and schedules an async function to clear it at the end of the event queue.\n         * @param origin The origin to set.\n         */\n        FocusMonitor.prototype._setOriginForCurrentEventQueue = function (origin) {\n            var _this = this;\n            this._ngZone.runOutsideAngular(function () {\n                _this._origin = origin;\n                // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*\n                // tick after the interaction event fired. To ensure the focus origin is always correct,\n                // the focus origin will be determined at the beginning of the next tick.\n                _this._originTimeoutId = setTimeout(function () { return _this._origin = null; }, 1);\n            });\n        };\n        /**\n         * Checks whether the given focus event was caused by a touchstart event.\n         * @param event The focus event to check.\n         * @returns Whether the event was caused by a touch.\n         */\n        FocusMonitor.prototype._wasCausedByTouch = function (event) {\n            // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n            // Consider the following dom structure:\n            //\n            // <div #parent tabindex=\"0\" cdkFocusClasses>\n            //   <div #child (click)=\"#parent.focus()\"></div>\n            // </div>\n            //\n            // If the user touches the #child element and the #parent is programmatically focused as a\n            // result, this code will still consider it to have been caused by the touch event and will\n            // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n            // relatively small edge-case that can be worked around by using\n            // focusVia(parentEl, 'program') to focus the parent element.\n            //\n            // If we decide that we absolutely must handle this case correctly, we can do so by listening\n            // for the first focus event after the touchstart, and then the first blur event after that\n            // focus event. When that blur event fires we know that whatever follows is not a result of the\n            // touchstart.\n            var focusTarget = event.target;\n            return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n                (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n        };\n        /**\n         * Handles focus events on a registered element.\n         * @param event The focus event.\n         * @param element The monitored element.\n         */\n        FocusMonitor.prototype._onFocus = function (event, element) {\n            // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n            // focus event affecting the monitored element. If we want to use the origin of the first event\n            // instead we should check for the cdk-focused class here and return if the element already has\n            // it. (This only matters for elements that have includesChildren = true).\n            // If we are not counting child-element-focus as focused, make sure that the event target is the\n            // monitored element itself.\n            var elementInfo = this._elementInfo.get(element);\n            if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n                return;\n            }\n            // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n            // 1) The window has just regained focus, in which case we want to restore the focused state of\n            //    the element from before the window blurred.\n            // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n            // 3) The element was programmatically focused, in which case we should mark the origin as\n            //    'program'.\n            var origin = this._origin;\n            if (!origin) {\n                if (this._windowFocused && this._lastFocusOrigin) {\n                    origin = this._lastFocusOrigin;\n                }\n                else if (this._wasCausedByTouch(event)) {\n                    origin = 'touch';\n                }\n                else {\n                    origin = 'program';\n                }\n            }\n            this._setClasses(element, origin);\n            this._emitOrigin(elementInfo.subject, origin);\n            this._lastFocusOrigin = origin;\n        };\n        /**\n         * Handles blur events on a registered element.\n         * @param event The blur event.\n         * @param element The monitored element.\n         */\n        FocusMonitor.prototype._onBlur = function (event, element) {\n            // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n            // order to focus another child of the monitored element.\n            var elementInfo = this._elementInfo.get(element);\n            if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n                element.contains(event.relatedTarget))) {\n                return;\n            }\n            this._setClasses(element);\n            this._emitOrigin(elementInfo.subject, null);\n        };\n        FocusMonitor.prototype._emitOrigin = function (subject, origin) {\n            this._ngZone.run(function () { return subject.next(origin); });\n        };\n        FocusMonitor.prototype._incrementMonitoredElementCount = function () {\n            var _this = this;\n            // Register global listeners when first element is monitored.\n            if (++this._monitoredElementCount == 1 && this._platform.isBrowser) {\n                // Note: we listen to events in the capture phase so we\n                // can detect them even if the user stops propagation.\n                this._ngZone.runOutsideAngular(function () {\n                    document.addEventListener('keydown', _this._documentKeydownListener, captureEventListenerOptions);\n                    document.addEventListener('mousedown', _this._documentMousedownListener, captureEventListenerOptions);\n                    document.addEventListener('touchstart', _this._documentTouchstartListener, captureEventListenerOptions);\n                    window.addEventListener('focus', _this._windowFocusListener);\n                });\n            }\n        };\n        FocusMonitor.prototype._decrementMonitoredElementCount = function () {\n            // Unregister global listeners when last element is unmonitored.\n            if (!--this._monitoredElementCount) {\n                document.removeEventListener('keydown', this._documentKeydownListener, captureEventListenerOptions);\n                document.removeEventListener('mousedown', this._documentMousedownListener, captureEventListenerOptions);\n                document.removeEventListener('touchstart', this._documentTouchstartListener, captureEventListenerOptions);\n                window.removeEventListener('focus', this._windowFocusListener);\n                // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n                clearTimeout(this._windowFocusTimeoutId);\n                clearTimeout(this._touchTimeoutId);\n                clearTimeout(this._originTimeoutId);\n            }\n        };\n        FocusMonitor.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        FocusMonitor.ctorParameters = function () { return [\n            { type: i0.NgZone },\n            { type: i1.Platform }\n        ]; };\n        FocusMonitor.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function FocusMonitor_Factory() { return new FocusMonitor(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.Platform)); }, token: FocusMonitor, providedIn: \"root\" });\n        return FocusMonitor;\n    }());\n    /**\n     * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n     * programmatically) and adds corresponding classes to the element.\n     *\n     * There are two variants of this directive:\n     * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n     *    focused.\n     * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n     */\n    var CdkMonitorFocus = /** @class */ (function () {\n        function CdkMonitorFocus(_elementRef, _focusMonitor) {\n            var _this = this;\n            this._elementRef = _elementRef;\n            this._focusMonitor = _focusMonitor;\n            this.cdkFocusChange = new i0.EventEmitter();\n            this._monitorSubscription = this._focusMonitor.monitor(this._elementRef, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n                .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n        }\n        CdkMonitorFocus.prototype.ngOnDestroy = function () {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n            this._monitorSubscription.unsubscribe();\n        };\n        CdkMonitorFocus.decorators = [\n            { type: i0.Directive, args: [{\n                        selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                    },] }\n        ];\n        /** @nocollapse */\n        CdkMonitorFocus.ctorParameters = function () { return [\n            { type: i0.ElementRef },\n            { type: FocusMonitor }\n        ]; };\n        CdkMonitorFocus.propDecorators = {\n            cdkFocusChange: [{ type: i0.Output }]\n        };\n        return CdkMonitorFocus;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Screenreaders will often fire fake mousedown events when a focusable element\n     * is activated using the keyboard. We can typically distinguish between these faked\n     * mousedown events and real mousedown events using the \"buttons\" property. While\n     * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n     * the left mouse button), faked mousedowns will usually set the property value to 0.\n     */\n    function isFakeMousedownFromScreenReader(event) {\n        return event.buttons === 0;\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var A11yModule = /** @class */ (function () {\n        function A11yModule() {\n        }\n        A11yModule.decorators = [\n            { type: i0.NgModule, args: [{\n                        imports: [i2.CommonModule, i1.PlatformModule, observers.ObserversModule],\n                        declarations: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n                        exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n                    },] }\n        ];\n        return A11yModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.MESSAGES_CONTAINER_ID = MESSAGES_CONTAINER_ID;\n    exports.CDK_DESCRIBEDBY_ID_PREFIX = CDK_DESCRIBEDBY_ID_PREFIX;\n    exports.CDK_DESCRIBEDBY_HOST_ATTRIBUTE = CDK_DESCRIBEDBY_HOST_ATTRIBUTE;\n    exports.AriaDescriber = AriaDescriber;\n    exports.ActiveDescendantKeyManager = ActiveDescendantKeyManager;\n    exports.FocusKeyManager = FocusKeyManager;\n    exports.ListKeyManager = ListKeyManager;\n    exports.FocusTrap = FocusTrap;\n    exports.FocusTrapFactory = FocusTrapFactory;\n    exports.CdkTrapFocus = CdkTrapFocus;\n    exports.InteractivityChecker = InteractivityChecker;\n    exports.LiveAnnouncer = LiveAnnouncer;\n    exports.CdkAriaLive = CdkAriaLive;\n    exports.LIVE_ANNOUNCER_ELEMENT_TOKEN = LIVE_ANNOUNCER_ELEMENT_TOKEN;\n    exports.LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY = LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY;\n    exports.LIVE_ANNOUNCER_DEFAULT_OPTIONS = LIVE_ANNOUNCER_DEFAULT_OPTIONS;\n    exports.TOUCH_BUFFER_MS = TOUCH_BUFFER_MS;\n    exports.FocusMonitor = FocusMonitor;\n    exports.CdkMonitorFocus = CdkMonitorFocus;\n    exports.isFakeMousedownFromScreenReader = isFakeMousedownFromScreenReader;\n    exports.A11yModule = A11yModule;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=cdk-a11y.umd.js.map\n"]}