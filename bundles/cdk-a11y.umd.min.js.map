{"version":3,"sources":["src/cdk/cdk-a11y.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","cdk","a11Y","common","core","tslib","rxjs","keycodes","operators","coercion","platform","observers","this","i2","i0","tslib_1","i1","getAriaReferenceIds","el","attr","getAttribute","match","nextId","messageRegistry","Map","messagesContainer","AriaDescriber","_document","prototype","describe","hostElement","message","_canBeDescribed","_setMessageId","set","messageElement","referenceCount","has","_createMessageElement","_isElementDescribedByMessage","_addMessageReference","removeDescription","_isElementNode","_removeMessageReference","registeredMessage","get","_deleteMessageElement","childNodes","length","_deleteMessagesContainer","ngOnDestroy","describedElements","querySelectorAll","i","_removeCdkDescribedByReferenceIds","removeAttribute","clear","createElement","textContent","_createMessagesContainer","appendChild","element","id","CDK_DESCRIBEDBY_ID_PREFIX","removeChild","delete","preExistingContainer","getElementById","parentNode","setAttribute","style","display","body","originalReferenceIds","filter","indexOf","join","addAriaReferencedId","ids","some","existingId","trim","push","removeAriaReferencedId","filteredIds","val","referenceIds","messageId","trimmedMessage","ariaLabel","nodeType","ELEMENT_NODE","decorators","type","Injectable","args","providedIn","ctorParameters","undefined","Inject","DOCUMENT","ngInjectableDef","ɵɵdefineInjectable","AriaDescriber_Factory","ɵɵinject","token","ARIA_DESCRIBER_PROVIDER_FACTORY","parentDispatcher","ARIA_DESCRIBER_PROVIDER","provide","deps","Optional","SkipSelf","useFactory","ListKeyManager","_items","_this","_activeItemIndex","_activeItem","_wrap","_letterKeyStream","Subject","_typeaheadSubscription","Subscription","EMPTY","_vertical","_allowedModifierKeys","_skipPredicateFn","item","disabled","_pressedLetters","tabOut","change","QueryList","changes","subscribe","newItems","newIndex","toArray","skipPredicate","predicate","withWrap","shouldWrap","withVerticalOrientation","enabled","withHorizontalOrientation","direction","_horizontal","withAllowedModifierKeys","keys","withTypeAhead","debounceInterval","getLabel","Error","unsubscribe","pipe","tap","keyCode","debounceTime","map","inputString","items","_getItemsArray","index","toUpperCase","setActiveItem","previousIndex","updateActiveItem","next","onKeydown","event","isModifierAllowed","every","modifier","TAB","DOWN_ARROW","setNextItemActive","UP_ARROW","setPreviousItemActive","RIGHT_ARROW","LEFT_ARROW","hasModifierKey","key","toLocaleUpperCase","A","Z","ZERO","NINE","String","fromCharCode","preventDefault","Object","defineProperty","enumerable","configurable","setFirstItemActive","_setActiveItemByIndex","setLastItemActive","_setActiveItemByDelta","itemArray","activeItem","updateActiveItemIndex","delta","_setActiveInWrapMode","_setActiveInDefaultMode","fallbackDelta","ActiveDescendantKeyManager","_super","apply","arguments","__extends","setInactiveStyles","call","setActiveStyles","FocusKeyManager","_origin","setFocusOrigin","origin","focus","InteractivityChecker","_platform","isDisabled","hasAttribute","isVisible","hasGeometry","offsetWidth","offsetHeight","getClientRects","getComputedStyle","visibility","isTabbable","isBrowser","frameElement","getFrameElement","window","_a","getWindow","node","ownerDocument","defaultView","frameType","nodeName","toLowerCase","getTabIndexValue","BLINK","WEBKIT","tabIndexValue","TRIDENT","FIREFOX","IOS","isPotentiallyTabbableIOS","inputType","tabIndex","isFocusable","isPotentiallyFocusable","isHiddenInput","isInputElement","isNativeFormElement","isAnchorWithHref","isAnchorElement","hasValidTabIndex","Platform","InteractivityChecker_Factory","isNaN","parseInt","FocusTrap","_element","_checker","_ngZone","deferAnchors","_hasAttached","startAnchorListener","focusLastTabbableElement","endAnchorListener","focusFirstTabbableElement","_enabled","attachAnchors","value","_startAnchor","_endAnchor","_toggleAnchorTabIndex","destroy","startAnchor","endAnchor","removeEventListener","runOutsideAngular","_createAnchor","addEventListener","insertBefore","nextSibling","focusInitialElementWhenReady","Promise","resolve","_executeOnStable","focusInitialElement","focusFirstTabbableElementWhenReady","focusLastTabbableElementWhenReady","_getRegionBoundary","bound","markers","console","warn","_getFirstTabbableElement","_getLastTabbableElement","redirectToElement","querySelector","isDevMode","hasAttached","root","children","tabbableChild","anchor","classList","add","isEnabled","fn","isStable","onStable","asObservable","take","FocusTrapFactory","create","deferCaptureElements","NgZone","FocusTrapFactory_Factory","CdkTrapFocus","_elementRef","_focusTrapFactory","_previouslyFocusedElement","focusTrap","nativeElement","coerceBooleanProperty","_autoCapture","ngAfterContentInit","autoCapture","activeElement","ngDoCheck","Directive","selector","exportAs","ElementRef","propDecorators","Input","LIVE_ANNOUNCER_ELEMENT_TOKEN","InjectionToken","LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY","LIVE_ANNOUNCER_DEFAULT_OPTIONS","LiveAnnouncer","elementToken","_defaultOptions","_liveElement","_createLiveElement","announce","_i","politeness","duration","defaultOptions","__read","clearTimeout","_previousTimeout","setTimeout","previousElements","getElementsByClassName","liveEl","LiveAnnouncer_Factory","CdkAriaLive","_liveAnnouncer","_contentObserver","_politeness","_subscription","observe","elementText","_previousAnnouncedText","ContentObserver","LIVE_ANNOUNCER_PROVIDER_FACTORY","parentAnnouncer","liveElement","ngZone","LIVE_ANNOUNCER_PROVIDER","TOUCH_BUFFER_MS","captureEventListenerOptions","normalizePassiveListenerOptions","passive","capture","FocusMonitor","_windowFocused","_elementInfo","_monitoredElementCount","_documentKeydownListener","_lastTouchTarget","_setOriginForCurrentEventQueue","_documentMousedownListener","_documentTouchstartListener","_touchTimeoutId","composedPath","target","_windowFocusListener","_windowFocusTimeoutId","monitor","checkChildren","of","coerceElement","cachedInfo","subject","info","unlisten","_incrementMonitoredElementCount","focusListener","_onFocus","blurListener","_onBlur","stopMonitoring","elementInfo","complete","_setClasses","_decrementMonitoredElementCount","focusVia","options","forEach","_info","_toggleClass","className","shouldSet","remove","_originTimeoutId","_wasCausedByTouch","focusTarget","Node","contains","_lastFocusOrigin","_emitOrigin","relatedTarget","run","document","FocusMonitor_Factory","CdkMonitorFocus","_focusMonitor","cdkFocusChange","EventEmitter","_monitorSubscription","emit","Output","FOCUS_MONITOR_PROVIDER_FACTORY","FOCUS_MONITOR_PROVIDER","A11yModule","NgModule","imports","CommonModule","PlatformModule","ObserversModule","declarations","MESSAGES_CONTAINER_ID","CDK_DESCRIBEDBY_HOST_ATTRIBUTE","isFakeMousedownFromScreenReader","buttons"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('tslib'), require('rxjs'), require('@angular/cdk/keycodes'), require('rxjs/operators'), require('@angular/cdk/coercion'), require('@angular/cdk/platform'), require('@angular/cdk/observers')) :\n    typeof define === 'function' && define.amd ? define('@angular/cdk/a11y', ['exports', '@angular/common', '@angular/core', 'tslib', 'rxjs', '@angular/cdk/keycodes', 'rxjs/operators', '@angular/cdk/coercion', '@angular/cdk/platform', '@angular/cdk/observers'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.cdk = global.ng.cdk || {}, global.ng.cdk.a11Y = {}), global.ng.common, global.ng.core, global.tslib, global.rxjs, global.ng.cdk.keycodes, global.rxjs.operators, global.ng.cdk.coercion, global.ng.cdk.platform, global.ng.cdk.observers));\n}(this, function (exports, i2, i0, tslib_1, rxjs, keycodes, operators, coercion, i1, observers) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** IDs are deliminated by an empty space, as per the spec. */\n    var ID_DELIMINATOR = ' ';\n    /**\n     * Adds the given ID to the specified ARIA attribute on an element.\n     * Used for attributes such as aria-labelledby, aria-owns, etc.\n     */\n    function addAriaReferencedId(el, attr, id) {\n        var ids = getAriaReferenceIds(el, attr);\n        if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n            return;\n        }\n        ids.push(id.trim());\n        el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n    }\n    /**\n     * Removes the given ID from the specified ARIA attribute on an element.\n     * Used for attributes such as aria-labelledby, aria-owns, etc.\n     */\n    function removeAriaReferencedId(el, attr, id) {\n        var ids = getAriaReferenceIds(el, attr);\n        var filteredIds = ids.filter(function (val) { return val != id.trim(); });\n        if (filteredIds.length) {\n            el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n        }\n        else {\n            el.removeAttribute(attr);\n        }\n    }\n    /**\n     * Gets the list of IDs referenced by the given ARIA attribute on an element.\n     * Used for attributes such as aria-labelledby, aria-owns, etc.\n     */\n    function getAriaReferenceIds(el, attr) {\n        // Get string array of all individual ids (whitespace deliminated) in the attribute value\n        return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** ID used for the body container where all messages are appended. */\n    var MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n    /** ID prefix used for each created message element. */\n    var CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n    /** Attribute given to each host element that is described by a message element. */\n    var CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n    /** Global incremental identifier for each registered message element. */\n    var nextId = 0;\n    /** Global map of all registered message elements that have been placed into the document. */\n    var messageRegistry = new Map();\n    /** Container for all registered messages. */\n    var messagesContainer = null;\n    /**\n     * Utility that creates visually hidden elements with a message content. Useful for elements that\n     * want to use aria-describedby to further describe themselves without adding additional visual\n     * content.\n     */\n    var AriaDescriber = /** @class */ (function () {\n        function AriaDescriber(_document) {\n            this._document = _document;\n        }\n        /**\n         * Adds to the host element an aria-describedby reference to a hidden element that contains\n         * the message. If the same message has already been registered, then it will reuse the created\n         * message element.\n         */\n        AriaDescriber.prototype.describe = function (hostElement, message) {\n            if (!this._canBeDescribed(hostElement, message)) {\n                return;\n            }\n            if (typeof message !== 'string') {\n                // We need to ensure that the element has an ID.\n                this._setMessageId(message);\n                messageRegistry.set(message, { messageElement: message, referenceCount: 0 });\n            }\n            else if (!messageRegistry.has(message)) {\n                this._createMessageElement(message);\n            }\n            if (!this._isElementDescribedByMessage(hostElement, message)) {\n                this._addMessageReference(hostElement, message);\n            }\n        };\n        /** Removes the host element's aria-describedby reference to the message element. */\n        AriaDescriber.prototype.removeDescription = function (hostElement, message) {\n            if (!this._isElementNode(hostElement)) {\n                return;\n            }\n            if (this._isElementDescribedByMessage(hostElement, message)) {\n                this._removeMessageReference(hostElement, message);\n            }\n            // If the message is a string, it means that it's one that we created for the\n            // consumer so we can remove it safely, otherwise we should leave it in place.\n            if (typeof message === 'string') {\n                var registeredMessage = messageRegistry.get(message);\n                if (registeredMessage && registeredMessage.referenceCount === 0) {\n                    this._deleteMessageElement(message);\n                }\n            }\n            if (messagesContainer && messagesContainer.childNodes.length === 0) {\n                this._deleteMessagesContainer();\n            }\n        };\n        /** Unregisters all created message elements and removes the message container. */\n        AriaDescriber.prototype.ngOnDestroy = function () {\n            var describedElements = this._document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n            for (var i = 0; i < describedElements.length; i++) {\n                this._removeCdkDescribedByReferenceIds(describedElements[i]);\n                describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n            }\n            if (messagesContainer) {\n                this._deleteMessagesContainer();\n            }\n            messageRegistry.clear();\n        };\n        /**\n         * Creates a new element in the visually hidden message container element with the message\n         * as its content and adds it to the message registry.\n         */\n        AriaDescriber.prototype._createMessageElement = function (message) {\n            var messageElement = this._document.createElement('div');\n            this._setMessageId(messageElement);\n            messageElement.textContent = message;\n            this._createMessagesContainer();\n            messagesContainer.appendChild(messageElement);\n            messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n        };\n        /** Assigns a unique ID to an element, if it doesn't have one already. */\n        AriaDescriber.prototype._setMessageId = function (element) {\n            if (!element.id) {\n                element.id = CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++;\n            }\n        };\n        /** Deletes the message element from the global messages container. */\n        AriaDescriber.prototype._deleteMessageElement = function (message) {\n            var registeredMessage = messageRegistry.get(message);\n            var messageElement = registeredMessage && registeredMessage.messageElement;\n            if (messagesContainer && messageElement) {\n                messagesContainer.removeChild(messageElement);\n            }\n            messageRegistry.delete(message);\n        };\n        /** Creates the global container for all aria-describedby messages. */\n        AriaDescriber.prototype._createMessagesContainer = function () {\n            if (!messagesContainer) {\n                var preExistingContainer = this._document.getElementById(MESSAGES_CONTAINER_ID);\n                // When going from the server to the client, we may end up in a situation where there's\n                // already a container on the page, but we don't have a reference to it. Clear the\n                // old container so we don't get duplicates. Doing this, instead of emptying the previous\n                // container, should be slightly faster.\n                if (preExistingContainer) {\n                    preExistingContainer.parentNode.removeChild(preExistingContainer);\n                }\n                messagesContainer = this._document.createElement('div');\n                messagesContainer.id = MESSAGES_CONTAINER_ID;\n                messagesContainer.setAttribute('aria-hidden', 'true');\n                messagesContainer.style.display = 'none';\n                this._document.body.appendChild(messagesContainer);\n            }\n        };\n        /** Deletes the global messages container. */\n        AriaDescriber.prototype._deleteMessagesContainer = function () {\n            if (messagesContainer && messagesContainer.parentNode) {\n                messagesContainer.parentNode.removeChild(messagesContainer);\n                messagesContainer = null;\n            }\n        };\n        /** Removes all cdk-describedby messages that are hosted through the element. */\n        AriaDescriber.prototype._removeCdkDescribedByReferenceIds = function (element) {\n            // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n            var originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n                .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n            element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n        };\n        /**\n         * Adds a message reference to the element using aria-describedby and increments the registered\n         * message's reference count.\n         */\n        AriaDescriber.prototype._addMessageReference = function (element, message) {\n            var registeredMessage = messageRegistry.get(message);\n            // Add the aria-describedby reference and set the\n            // describedby_host attribute to mark the element.\n            addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n            element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n            registeredMessage.referenceCount++;\n        };\n        /**\n         * Removes a message reference from the element using aria-describedby\n         * and decrements the registered message's reference count.\n         */\n        AriaDescriber.prototype._removeMessageReference = function (element, message) {\n            var registeredMessage = messageRegistry.get(message);\n            registeredMessage.referenceCount--;\n            removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n            element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        };\n        /** Returns true if the element has been described by the provided message ID. */\n        AriaDescriber.prototype._isElementDescribedByMessage = function (element, message) {\n            var referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n            var registeredMessage = messageRegistry.get(message);\n            var messageId = registeredMessage && registeredMessage.messageElement.id;\n            return !!messageId && referenceIds.indexOf(messageId) != -1;\n        };\n        /** Determines whether a message can be described on a particular element. */\n        AriaDescriber.prototype._canBeDescribed = function (element, message) {\n            if (!this._isElementNode(element)) {\n                return false;\n            }\n            if (message && typeof message === 'object') {\n                // We'd have to make some assumptions about the description element's text, if the consumer\n                // passed in an element. Assume that if an element is passed in, the consumer has verified\n                // that it can be used as a description.\n                return true;\n            }\n            var trimmedMessage = message == null ? '' : (\"\" + message).trim();\n            var ariaLabel = element.getAttribute('aria-label');\n            // We shouldn't set descriptions if they're exactly the same as the `aria-label` of the\n            // element, because screen readers will end up reading out the same text twice in a row.\n            return trimmedMessage ? (!ariaLabel || ariaLabel.trim() !== trimmedMessage) : false;\n        };\n        /** Checks whether a node is an Element node. */\n        AriaDescriber.prototype._isElementNode = function (element) {\n            return element.nodeType === this._document.ELEMENT_NODE;\n        };\n        AriaDescriber.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        AriaDescriber.ctorParameters = function () { return [\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] }\n        ]; };\n        AriaDescriber.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function AriaDescriber_Factory() { return new AriaDescriber(i0.ɵɵinject(i2.DOCUMENT)); }, token: AriaDescriber, providedIn: \"root\" });\n        return AriaDescriber;\n    }());\n    /** @docs-private @deprecated @breaking-change 8.0.0 */\n    function ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {\n        return parentDispatcher || new AriaDescriber(_document);\n    }\n    /** @docs-private @deprecated @breaking-change 8.0.0 */\n    var ARIA_DESCRIBER_PROVIDER = {\n        // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n        provide: AriaDescriber,\n        deps: [\n            [new i0.Optional(), new i0.SkipSelf(), AriaDescriber],\n            i2.DOCUMENT\n        ],\n        useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n    };\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * This class manages keyboard events for selectable lists. If you pass it a query list\n     * of items, it will set the active item correctly when arrow events occur.\n     */\n    var ListKeyManager = /** @class */ (function () {\n        function ListKeyManager(_items) {\n            var _this = this;\n            this._items = _items;\n            this._activeItemIndex = -1;\n            this._activeItem = null;\n            this._wrap = false;\n            this._letterKeyStream = new rxjs.Subject();\n            this._typeaheadSubscription = rxjs.Subscription.EMPTY;\n            this._vertical = true;\n            this._allowedModifierKeys = [];\n            /**\n             * Predicate function that can be used to check whether an item should be skipped\n             * by the key manager. By default, disabled items are skipped.\n             */\n            this._skipPredicateFn = function (item) { return item.disabled; };\n            // Buffer for the letters that the user has pressed when the typeahead option is turned on.\n            this._pressedLetters = [];\n            /**\n             * Stream that emits any time the TAB key is pressed, so components can react\n             * when focus is shifted off of the list.\n             */\n            this.tabOut = new rxjs.Subject();\n            /** Stream that emits whenever the active item of the list manager changes. */\n            this.change = new rxjs.Subject();\n            // We allow for the items to be an array because, in some cases, the consumer may\n            // not have access to a QueryList of the items they want to manage (e.g. when the\n            // items aren't being collected via `ViewChildren` or `ContentChildren`).\n            if (_items instanceof i0.QueryList) {\n                _items.changes.subscribe(function (newItems) {\n                    if (_this._activeItem) {\n                        var itemArray = newItems.toArray();\n                        var newIndex = itemArray.indexOf(_this._activeItem);\n                        if (newIndex > -1 && newIndex !== _this._activeItemIndex) {\n                            _this._activeItemIndex = newIndex;\n                        }\n                    }\n                });\n            }\n        }\n        /**\n         * Sets the predicate function that determines which items should be skipped by the\n         * list key manager.\n         * @param predicate Function that determines whether the given item should be skipped.\n         */\n        ListKeyManager.prototype.skipPredicate = function (predicate) {\n            this._skipPredicateFn = predicate;\n            return this;\n        };\n        /**\n         * Configures wrapping mode, which determines whether the active item will wrap to\n         * the other end of list when there are no more items in the given direction.\n         * @param shouldWrap Whether the list should wrap when reaching the end.\n         */\n        ListKeyManager.prototype.withWrap = function (shouldWrap) {\n            if (shouldWrap === void 0) { shouldWrap = true; }\n            this._wrap = shouldWrap;\n            return this;\n        };\n        /**\n         * Configures whether the key manager should be able to move the selection vertically.\n         * @param enabled Whether vertical selection should be enabled.\n         */\n        ListKeyManager.prototype.withVerticalOrientation = function (enabled) {\n            if (enabled === void 0) { enabled = true; }\n            this._vertical = enabled;\n            return this;\n        };\n        /**\n         * Configures the key manager to move the selection horizontally.\n         * Passing in `null` will disable horizontal movement.\n         * @param direction Direction in which the selection can be moved.\n         */\n        ListKeyManager.prototype.withHorizontalOrientation = function (direction) {\n            this._horizontal = direction;\n            return this;\n        };\n        /**\n         * Modifier keys which are allowed to be held down and whose default actions will be prevented\n         * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n         */\n        ListKeyManager.prototype.withAllowedModifierKeys = function (keys) {\n            this._allowedModifierKeys = keys;\n            return this;\n        };\n        /**\n         * Turns on typeahead mode which allows users to set the active item by typing.\n         * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n         */\n        ListKeyManager.prototype.withTypeAhead = function (debounceInterval) {\n            var _this = this;\n            if (debounceInterval === void 0) { debounceInterval = 200; }\n            if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n                throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n            }\n            this._typeaheadSubscription.unsubscribe();\n            // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n            // and convert those letters back into a string. Afterwards find the first item that starts\n            // with that string and select it.\n            this._typeaheadSubscription = this._letterKeyStream.pipe(operators.tap(function (keyCode) { return _this._pressedLetters.push(keyCode); }), operators.debounceTime(debounceInterval), operators.filter(function () { return _this._pressedLetters.length > 0; }), operators.map(function () { return _this._pressedLetters.join(''); })).subscribe(function (inputString) {\n                var items = _this._getItemsArray();\n                // Start at 1 because we want to start searching at the item immediately\n                // following the current active item.\n                for (var i = 1; i < items.length + 1; i++) {\n                    var index = (_this._activeItemIndex + i) % items.length;\n                    var item = items[index];\n                    if (!_this._skipPredicateFn(item) &&\n                        item.getLabel().toUpperCase().trim().indexOf(inputString) === 0) {\n                        _this.setActiveItem(index);\n                        break;\n                    }\n                }\n                _this._pressedLetters = [];\n            });\n            return this;\n        };\n        ListKeyManager.prototype.setActiveItem = function (item) {\n            var previousIndex = this._activeItemIndex;\n            this.updateActiveItem(item);\n            if (this._activeItemIndex !== previousIndex) {\n                this.change.next(this._activeItemIndex);\n            }\n        };\n        /**\n         * Sets the active item depending on the key event passed in.\n         * @param event Keyboard event to be used for determining which element should be active.\n         */\n        ListKeyManager.prototype.onKeydown = function (event) {\n            var _this = this;\n            var keyCode = event.keyCode;\n            var modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n            var isModifierAllowed = modifiers.every(function (modifier) {\n                return !event[modifier] || _this._allowedModifierKeys.indexOf(modifier) > -1;\n            });\n            switch (keyCode) {\n                case keycodes.TAB:\n                    this.tabOut.next();\n                    return;\n                case keycodes.DOWN_ARROW:\n                    if (this._vertical && isModifierAllowed) {\n                        this.setNextItemActive();\n                        break;\n                    }\n                    else {\n                        return;\n                    }\n                case keycodes.UP_ARROW:\n                    if (this._vertical && isModifierAllowed) {\n                        this.setPreviousItemActive();\n                        break;\n                    }\n                    else {\n                        return;\n                    }\n                case keycodes.RIGHT_ARROW:\n                    if (this._horizontal && isModifierAllowed) {\n                        this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n                        break;\n                    }\n                    else {\n                        return;\n                    }\n                case keycodes.LEFT_ARROW:\n                    if (this._horizontal && isModifierAllowed) {\n                        this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n                        break;\n                    }\n                    else {\n                        return;\n                    }\n                default:\n                    if (isModifierAllowed || keycodes.hasModifierKey(event, 'shiftKey')) {\n                        // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                        // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                        if (event.key && event.key.length === 1) {\n                            this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                        }\n                        else if ((keyCode >= keycodes.A && keyCode <= keycodes.Z) || (keyCode >= keycodes.ZERO && keyCode <= keycodes.NINE)) {\n                            this._letterKeyStream.next(String.fromCharCode(keyCode));\n                        }\n                    }\n                    // Note that we return here, in order to avoid preventing\n                    // the default action of non-navigational keys.\n                    return;\n            }\n            this._pressedLetters = [];\n            event.preventDefault();\n        };\n        Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n            /** Index of the currently active item. */\n            get: function () {\n                return this._activeItemIndex;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n            /** The active item. */\n            get: function () {\n                return this._activeItem;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Sets the active item to the first enabled item in the list. */\n        ListKeyManager.prototype.setFirstItemActive = function () {\n            this._setActiveItemByIndex(0, 1);\n        };\n        /** Sets the active item to the last enabled item in the list. */\n        ListKeyManager.prototype.setLastItemActive = function () {\n            this._setActiveItemByIndex(this._items.length - 1, -1);\n        };\n        /** Sets the active item to the next enabled item in the list. */\n        ListKeyManager.prototype.setNextItemActive = function () {\n            this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n        };\n        /** Sets the active item to a previous enabled item in the list. */\n        ListKeyManager.prototype.setPreviousItemActive = function () {\n            this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n                : this._setActiveItemByDelta(-1);\n        };\n        ListKeyManager.prototype.updateActiveItem = function (item) {\n            var itemArray = this._getItemsArray();\n            var index = typeof item === 'number' ? item : itemArray.indexOf(item);\n            var activeItem = itemArray[index];\n            // Explicitly check for `null` and `undefined` because other falsy values are valid.\n            this._activeItem = activeItem == null ? null : activeItem;\n            this._activeItemIndex = index;\n        };\n        /**\n         * Allows setting of the activeItemIndex without any other effects.\n         * @param index The new activeItemIndex.\n         * @deprecated Use `updateActiveItem` instead.\n         * @breaking-change 8.0.0\n         */\n        ListKeyManager.prototype.updateActiveItemIndex = function (index) {\n            this.updateActiveItem(index);\n        };\n        /**\n         * This method sets the active item, given a list of items and the delta between the\n         * currently active item and the new active item. It will calculate differently\n         * depending on whether wrap mode is turned on.\n         */\n        ListKeyManager.prototype._setActiveItemByDelta = function (delta) {\n            this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n        };\n        /**\n         * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n         * down the list until it finds an item that is not disabled, and it will wrap if it\n         * encounters either end of the list.\n         */\n        ListKeyManager.prototype._setActiveInWrapMode = function (delta) {\n            var items = this._getItemsArray();\n            for (var i = 1; i <= items.length; i++) {\n                var index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\n                var item = items[index];\n                if (!this._skipPredicateFn(item)) {\n                    this.setActiveItem(index);\n                    return;\n                }\n            }\n        };\n        /**\n         * Sets the active item properly given the default mode. In other words, it will\n         * continue to move down the list until it finds an item that is not disabled. If\n         * it encounters either end of the list, it will stop and not wrap.\n         */\n        ListKeyManager.prototype._setActiveInDefaultMode = function (delta) {\n            this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n        };\n        /**\n         * Sets the active item to the first enabled item starting at the index specified. If the\n         * item is disabled, it will move in the fallbackDelta direction until it either\n         * finds an enabled item or encounters the end of the list.\n         */\n        ListKeyManager.prototype._setActiveItemByIndex = function (index, fallbackDelta) {\n            var items = this._getItemsArray();\n            if (!items[index]) {\n                return;\n            }\n            while (this._skipPredicateFn(items[index])) {\n                index += fallbackDelta;\n                if (!items[index]) {\n                    return;\n                }\n            }\n            this.setActiveItem(index);\n        };\n        /** Returns the items as an array. */\n        ListKeyManager.prototype._getItemsArray = function () {\n            return this._items instanceof i0.QueryList ? this._items.toArray() : this._items;\n        };\n        return ListKeyManager;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var ActiveDescendantKeyManager = /** @class */ (function (_super) {\n        tslib_1.__extends(ActiveDescendantKeyManager, _super);\n        function ActiveDescendantKeyManager() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        ActiveDescendantKeyManager.prototype.setActiveItem = function (index) {\n            if (this.activeItem) {\n                this.activeItem.setInactiveStyles();\n            }\n            _super.prototype.setActiveItem.call(this, index);\n            if (this.activeItem) {\n                this.activeItem.setActiveStyles();\n            }\n        };\n        return ActiveDescendantKeyManager;\n    }(ListKeyManager));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var FocusKeyManager = /** @class */ (function (_super) {\n        tslib_1.__extends(FocusKeyManager, _super);\n        function FocusKeyManager() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this._origin = 'program';\n            return _this;\n        }\n        /**\n         * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n         * @param origin Focus origin to be used when focusing items.\n         */\n        FocusKeyManager.prototype.setFocusOrigin = function (origin) {\n            this._origin = origin;\n            return this;\n        };\n        FocusKeyManager.prototype.setActiveItem = function (item) {\n            _super.prototype.setActiveItem.call(this, item);\n            if (this.activeItem) {\n                this.activeItem.focus(this._origin);\n            }\n        };\n        return FocusKeyManager;\n    }(ListKeyManager));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // The InteractivityChecker leans heavily on the ally.js accessibility utilities.\n    // Methods like `isTabbable` are only covering specific edge-cases for the browsers which are\n    // supported.\n    /**\n     * Utility for checking the interactivity of an element, such as whether is is focusable or\n     * tabbable.\n     */\n    var InteractivityChecker = /** @class */ (function () {\n        function InteractivityChecker(_platform) {\n            this._platform = _platform;\n        }\n        /**\n         * Gets whether an element is disabled.\n         *\n         * @param element Element to be checked.\n         * @returns Whether the element is disabled.\n         */\n        InteractivityChecker.prototype.isDisabled = function (element) {\n            // This does not capture some cases, such as a non-form control with a disabled attribute or\n            // a form control inside of a disabled form, but should capture the most common cases.\n            return element.hasAttribute('disabled');\n        };\n        /**\n         * Gets whether an element is visible for the purposes of interactivity.\n         *\n         * This will capture states like `display: none` and `visibility: hidden`, but not things like\n         * being clipped by an `overflow: hidden` parent or being outside the viewport.\n         *\n         * @returns Whether the element is visible.\n         */\n        InteractivityChecker.prototype.isVisible = function (element) {\n            return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n        };\n        /**\n         * Gets whether an element can be reached via Tab key.\n         * Assumes that the element has already been checked with isFocusable.\n         *\n         * @param element Element to be checked.\n         * @returns Whether the element is tabbable.\n         */\n        InteractivityChecker.prototype.isTabbable = function (element) {\n            // Nothing is tabbable on the server 😎\n            if (!this._platform.isBrowser) {\n                return false;\n            }\n            var frameElement = getFrameElement(getWindow(element));\n            if (frameElement) {\n                var frameType = frameElement && frameElement.nodeName.toLowerCase();\n                // Frame elements inherit their tabindex onto all child elements.\n                if (getTabIndexValue(frameElement) === -1) {\n                    return false;\n                }\n                // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n                if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                    return false;\n                }\n                // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n                if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                    return false;\n                }\n            }\n            var nodeName = element.nodeName.toLowerCase();\n            var tabIndexValue = getTabIndexValue(element);\n            if (element.hasAttribute('contenteditable')) {\n                return tabIndexValue !== -1;\n            }\n            if (nodeName === 'iframe') {\n                // The frames may be tabbable depending on content, but it's not possibly to reliably\n                // investigate the content of the frames.\n                return false;\n            }\n            if (nodeName === 'audio') {\n                if (!element.hasAttribute('controls')) {\n                    // By default an <audio> element without the controls enabled is not tabbable.\n                    return false;\n                }\n                else if (this._platform.BLINK) {\n                    // In Blink <audio controls> elements are always tabbable.\n                    return true;\n                }\n            }\n            if (nodeName === 'video') {\n                if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                    // In Trident a <video> element without the controls enabled is not tabbable.\n                    return false;\n                }\n                else if (this._platform.BLINK || this._platform.FIREFOX) {\n                    // In Chrome and Firefox <video controls> elements are always tabbable.\n                    return true;\n                }\n            }\n            if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n                // In all Blink and WebKit based browsers <object> elements are never tabbable.\n                return false;\n            }\n            // In iOS the browser only considers some specific elements as tabbable.\n            if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n                return false;\n            }\n            return element.tabIndex >= 0;\n        };\n        /**\n         * Gets whether an element can be focused by the user.\n         *\n         * @param element Element to be checked.\n         * @returns Whether the element is focusable.\n         */\n        InteractivityChecker.prototype.isFocusable = function (element) {\n            // Perform checks in order of left to most expensive.\n            // Again, naive approach that does not capture many edge cases and browser quirks.\n            return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n        };\n        InteractivityChecker.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        InteractivityChecker.ctorParameters = function () { return [\n            { type: i1.Platform }\n        ]; };\n        InteractivityChecker.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function InteractivityChecker_Factory() { return new InteractivityChecker(i0.ɵɵinject(i1.Platform)); }, token: InteractivityChecker, providedIn: \"root\" });\n        return InteractivityChecker;\n    }());\n    /**\n     * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n     * the frameElement property is being accessed from a different host address, this property\n     * should be accessed carefully.\n     */\n    function getFrameElement(window) {\n        try {\n            return window.frameElement;\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n    /** Checks whether the specified element has any geometry / rectangles. */\n    function hasGeometry(element) {\n        // Use logic from jQuery to check for an invisible element.\n        // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n        return !!(element.offsetWidth || element.offsetHeight ||\n            (typeof element.getClientRects === 'function' && element.getClientRects().length));\n    }\n    /** Gets whether an element's  */\n    function isNativeFormElement(element) {\n        var nodeName = element.nodeName.toLowerCase();\n        return nodeName === 'input' ||\n            nodeName === 'select' ||\n            nodeName === 'button' ||\n            nodeName === 'textarea';\n    }\n    /** Gets whether an element is an `<input type=\"hidden\">`. */\n    function isHiddenInput(element) {\n        return isInputElement(element) && element.type == 'hidden';\n    }\n    /** Gets whether an element is an anchor that has an href attribute. */\n    function isAnchorWithHref(element) {\n        return isAnchorElement(element) && element.hasAttribute('href');\n    }\n    /** Gets whether an element is an input element. */\n    function isInputElement(element) {\n        return element.nodeName.toLowerCase() == 'input';\n    }\n    /** Gets whether an element is an anchor element. */\n    function isAnchorElement(element) {\n        return element.nodeName.toLowerCase() == 'a';\n    }\n    /** Gets whether an element has a valid tabindex. */\n    function hasValidTabIndex(element) {\n        if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n            return false;\n        }\n        var tabIndex = element.getAttribute('tabindex');\n        // IE11 parses tabindex=\"\" as the value \"-32768\"\n        if (tabIndex == '-32768') {\n            return false;\n        }\n        return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n    }\n    /**\n     * Returns the parsed tabindex from the element attributes instead of returning the\n     * evaluated tabindex from the browsers defaults.\n     */\n    function getTabIndexValue(element) {\n        if (!hasValidTabIndex(element)) {\n            return null;\n        }\n        // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n        var tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n        return isNaN(tabIndex) ? -1 : tabIndex;\n    }\n    /** Checks whether the specified element is potentially tabbable on iOS */\n    function isPotentiallyTabbableIOS(element) {\n        var nodeName = element.nodeName.toLowerCase();\n        var inputType = nodeName === 'input' && element.type;\n        return inputType === 'text'\n            || inputType === 'password'\n            || nodeName === 'select'\n            || nodeName === 'textarea';\n    }\n    /**\n     * Gets whether an element is potentially focusable without taking current visible/disabled state\n     * into account.\n     */\n    function isPotentiallyFocusable(element) {\n        // Inputs are potentially focusable *unless* they're type=\"hidden\".\n        if (isHiddenInput(element)) {\n            return false;\n        }\n        return isNativeFormElement(element) ||\n            isAnchorWithHref(element) ||\n            element.hasAttribute('contenteditable') ||\n            hasValidTabIndex(element);\n    }\n    /** Gets the parent window of a DOM node with regards of being inside of an iframe. */\n    function getWindow(node) {\n        // ownerDocument is null if `node` itself *is* a document.\n        return node.ownerDocument && node.ownerDocument.defaultView || window;\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Class that allows for trapping focus within a DOM element.\n     *\n     * This class currently uses a relatively simple approach to focus trapping.\n     * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n     * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.\n     */\n    var FocusTrap = /** @class */ (function () {\n        function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {\n            var _this = this;\n            if (deferAnchors === void 0) { deferAnchors = false; }\n            this._element = _element;\n            this._checker = _checker;\n            this._ngZone = _ngZone;\n            this._document = _document;\n            this._hasAttached = false;\n            // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.\n            this.startAnchorListener = function () { return _this.focusLastTabbableElement(); };\n            this.endAnchorListener = function () { return _this.focusFirstTabbableElement(); };\n            this._enabled = true;\n            if (!deferAnchors) {\n                this.attachAnchors();\n            }\n        }\n        Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n            /** Whether the focus trap is active. */\n            get: function () { return this._enabled; },\n            set: function (value) {\n                this._enabled = value;\n                if (this._startAnchor && this._endAnchor) {\n                    this._toggleAnchorTabIndex(value, this._startAnchor);\n                    this._toggleAnchorTabIndex(value, this._endAnchor);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Destroys the focus trap by cleaning up the anchors. */\n        FocusTrap.prototype.destroy = function () {\n            var startAnchor = this._startAnchor;\n            var endAnchor = this._endAnchor;\n            if (startAnchor) {\n                startAnchor.removeEventListener('focus', this.startAnchorListener);\n                if (startAnchor.parentNode) {\n                    startAnchor.parentNode.removeChild(startAnchor);\n                }\n            }\n            if (endAnchor) {\n                endAnchor.removeEventListener('focus', this.endAnchorListener);\n                if (endAnchor.parentNode) {\n                    endAnchor.parentNode.removeChild(endAnchor);\n                }\n            }\n            this._startAnchor = this._endAnchor = null;\n        };\n        /**\n         * Inserts the anchors into the DOM. This is usually done automatically\n         * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n         * @returns Whether the focus trap managed to attach successfuly. This may not be the case\n         * if the target element isn't currently in the DOM.\n         */\n        FocusTrap.prototype.attachAnchors = function () {\n            var _this = this;\n            // If we're not on the browser, there can be no focus to trap.\n            if (this._hasAttached) {\n                return true;\n            }\n            this._ngZone.runOutsideAngular(function () {\n                if (!_this._startAnchor) {\n                    _this._startAnchor = _this._createAnchor();\n                    _this._startAnchor.addEventListener('focus', _this.startAnchorListener);\n                }\n                if (!_this._endAnchor) {\n                    _this._endAnchor = _this._createAnchor();\n                    _this._endAnchor.addEventListener('focus', _this.endAnchorListener);\n                }\n            });\n            if (this._element.parentNode) {\n                this._element.parentNode.insertBefore(this._startAnchor, this._element);\n                this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);\n                this._hasAttached = true;\n            }\n            return this._hasAttached;\n        };\n        /**\n         * Waits for the zone to stabilize, then either focuses the first element that the\n         * user specified, or the first tabbable element.\n         * @returns Returns a promise that resolves with a boolean, depending\n         * on whether focus was moved successfuly.\n         */\n        FocusTrap.prototype.focusInitialElementWhenReady = function () {\n            var _this = this;\n            return new Promise(function (resolve) {\n                _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n            });\n        };\n        /**\n         * Waits for the zone to stabilize, then focuses\n         * the first tabbable element within the focus trap region.\n         * @returns Returns a promise that resolves with a boolean, depending\n         * on whether focus was moved successfuly.\n         */\n        FocusTrap.prototype.focusFirstTabbableElementWhenReady = function () {\n            var _this = this;\n            return new Promise(function (resolve) {\n                _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n            });\n        };\n        /**\n         * Waits for the zone to stabilize, then focuses\n         * the last tabbable element within the focus trap region.\n         * @returns Returns a promise that resolves with a boolean, depending\n         * on whether focus was moved successfuly.\n         */\n        FocusTrap.prototype.focusLastTabbableElementWhenReady = function () {\n            var _this = this;\n            return new Promise(function (resolve) {\n                _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n            });\n        };\n        /**\n         * Get the specified boundary element of the trapped region.\n         * @param bound The boundary to get (start or end of trapped region).\n         * @returns The boundary element.\n         */\n        FocusTrap.prototype._getRegionBoundary = function (bound) {\n            // Contains the deprecated version of selector, for temporary backwards comparability.\n            var markers = this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n                (\"[cdkFocusRegion\" + bound + \"], \") +\n                (\"[cdk-focus-\" + bound + \"]\"));\n            for (var i = 0; i < markers.length; i++) {\n                // @breaking-change 8.0.0\n                if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                    console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"', \" +\n                        (\"use 'cdkFocusRegion\" + bound + \"' instead. The deprecated \") +\n                        \"attribute will be removed in 8.0.0.\", markers[i]);\n                }\n                else if (markers[i].hasAttribute(\"cdk-focus-region-\" + bound)) {\n                    console.warn(\"Found use of deprecated attribute 'cdk-focus-region-\" + bound + \"', \" +\n                        (\"use 'cdkFocusRegion\" + bound + \"' instead. The deprecated attribute \") +\n                        \"will be removed in 8.0.0.\", markers[i]);\n                }\n            }\n            if (bound == 'start') {\n                return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n            }\n            return markers.length ?\n                markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n        };\n        /**\n         * Focuses the element that should be focused when the focus trap is initialized.\n         * @returns Whether focus was moved successfuly.\n         */\n        FocusTrap.prototype.focusInitialElement = function () {\n            // Contains the deprecated version of selector, for temporary backwards comparability.\n            var redirectToElement = this._element.querySelector(\"[cdk-focus-initial], \" +\n                \"[cdkFocusInitial]\");\n            if (redirectToElement) {\n                // @breaking-change 8.0.0\n                if (redirectToElement.hasAttribute(\"cdk-focus-initial\")) {\n                    console.warn(\"Found use of deprecated attribute 'cdk-focus-initial', \" +\n                        \"use 'cdkFocusInitial' instead. The deprecated attribute \" +\n                        \"will be removed in 8.0.0\", redirectToElement);\n                }\n                // Warn the consumer if the element they've pointed to\n                // isn't focusable, when not in production mode.\n                if (i0.isDevMode() && !this._checker.isFocusable(redirectToElement)) {\n                    console.warn(\"Element matching '[cdkFocusInitial]' is not focusable.\", redirectToElement);\n                }\n                redirectToElement.focus();\n                return true;\n            }\n            return this.focusFirstTabbableElement();\n        };\n        /**\n         * Focuses the first tabbable element within the focus trap region.\n         * @returns Whether focus was moved successfuly.\n         */\n        FocusTrap.prototype.focusFirstTabbableElement = function () {\n            var redirectToElement = this._getRegionBoundary('start');\n            if (redirectToElement) {\n                redirectToElement.focus();\n            }\n            return !!redirectToElement;\n        };\n        /**\n         * Focuses the last tabbable element within the focus trap region.\n         * @returns Whether focus was moved successfuly.\n         */\n        FocusTrap.prototype.focusLastTabbableElement = function () {\n            var redirectToElement = this._getRegionBoundary('end');\n            if (redirectToElement) {\n                redirectToElement.focus();\n            }\n            return !!redirectToElement;\n        };\n        /**\n         * Checks whether the focus trap has successfuly been attached.\n         */\n        FocusTrap.prototype.hasAttached = function () {\n            return this._hasAttached;\n        };\n        /** Get the first tabbable element from a DOM subtree (inclusive). */\n        FocusTrap.prototype._getFirstTabbableElement = function (root) {\n            if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n                return root;\n            }\n            // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n            // back to `childNodes` which includes text nodes, comments etc.\n            var children = root.children || root.childNodes;\n            for (var i = 0; i < children.length; i++) {\n                var tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                    this._getFirstTabbableElement(children[i]) :\n                    null;\n                if (tabbableChild) {\n                    return tabbableChild;\n                }\n            }\n            return null;\n        };\n        /** Get the last tabbable element from a DOM subtree (inclusive). */\n        FocusTrap.prototype._getLastTabbableElement = function (root) {\n            if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n                return root;\n            }\n            // Iterate in reverse DOM order.\n            var children = root.children || root.childNodes;\n            for (var i = children.length - 1; i >= 0; i--) {\n                var tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                    this._getLastTabbableElement(children[i]) :\n                    null;\n                if (tabbableChild) {\n                    return tabbableChild;\n                }\n            }\n            return null;\n        };\n        /** Creates an anchor element. */\n        FocusTrap.prototype._createAnchor = function () {\n            var anchor = this._document.createElement('div');\n            this._toggleAnchorTabIndex(this._enabled, anchor);\n            anchor.classList.add('cdk-visually-hidden');\n            anchor.classList.add('cdk-focus-trap-anchor');\n            anchor.setAttribute('aria-hidden', 'true');\n            return anchor;\n        };\n        /**\n         * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\n         * @param isEnabled Whether the focus trap is enabled.\n         * @param anchor Anchor on which to toggle the tabindex.\n         */\n        FocusTrap.prototype._toggleAnchorTabIndex = function (isEnabled, anchor) {\n            // Remove the tabindex completely, rather than setting it to -1, because if the\n            // element has a tabindex, the user might still hit it when navigating with the arrow keys.\n            isEnabled ? anchor.setAttribute('tabindex', '0') : anchor.removeAttribute('tabindex');\n        };\n        /** Executes a function when the zone is stable. */\n        FocusTrap.prototype._executeOnStable = function (fn) {\n            if (this._ngZone.isStable) {\n                fn();\n            }\n            else {\n                this._ngZone.onStable.asObservable().pipe(operators.take(1)).subscribe(fn);\n            }\n        };\n        return FocusTrap;\n    }());\n    /** Factory that allows easy instantiation of focus traps. */\n    var FocusTrapFactory = /** @class */ (function () {\n        function FocusTrapFactory(_checker, _ngZone, _document) {\n            this._checker = _checker;\n            this._ngZone = _ngZone;\n            this._document = _document;\n        }\n        /**\n         * Creates a focus-trapped region around the given element.\n         * @param element The element around which focus will be trapped.\n         * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n         *     manually by the user.\n         * @returns The created focus trap instance.\n         */\n        FocusTrapFactory.prototype.create = function (element, deferCaptureElements) {\n            if (deferCaptureElements === void 0) { deferCaptureElements = false; }\n            return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n        };\n        FocusTrapFactory.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        FocusTrapFactory.ctorParameters = function () { return [\n            { type: InteractivityChecker },\n            { type: i0.NgZone },\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] }\n        ]; };\n        FocusTrapFactory.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function FocusTrapFactory_Factory() { return new FocusTrapFactory(i0.ɵɵinject(InteractivityChecker), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i2.DOCUMENT)); }, token: FocusTrapFactory, providedIn: \"root\" });\n        return FocusTrapFactory;\n    }());\n    /** Directive for trapping focus within a region. */\n    var CdkTrapFocus = /** @class */ (function () {\n        function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {\n            this._elementRef = _elementRef;\n            this._focusTrapFactory = _focusTrapFactory;\n            /** Previously focused element to restore focus to upon destroy when using autoCapture. */\n            this._previouslyFocusedElement = null;\n            this._document = _document;\n            this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n        }\n        Object.defineProperty(CdkTrapFocus.prototype, \"enabled\", {\n            /** Whether the focus trap is active. */\n            get: function () { return this.focusTrap.enabled; },\n            set: function (value) { this.focusTrap.enabled = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CdkTrapFocus.prototype, \"autoCapture\", {\n            /**\n             * Whether the directive should automatially move focus into the trapped region upon\n             * initialization and return focus to the previous activeElement upon destruction.\n             */\n            get: function () { return this._autoCapture; },\n            set: function (value) { this._autoCapture = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        CdkTrapFocus.prototype.ngOnDestroy = function () {\n            this.focusTrap.destroy();\n            // If we stored a previously focused element when using autoCapture, return focus to that\n            // element now that the trapped region is being destroyed.\n            if (this._previouslyFocusedElement) {\n                this._previouslyFocusedElement.focus();\n                this._previouslyFocusedElement = null;\n            }\n        };\n        CdkTrapFocus.prototype.ngAfterContentInit = function () {\n            this.focusTrap.attachAnchors();\n            if (this.autoCapture) {\n                this._previouslyFocusedElement = this._document.activeElement;\n                this.focusTrap.focusInitialElementWhenReady();\n            }\n        };\n        CdkTrapFocus.prototype.ngDoCheck = function () {\n            if (!this.focusTrap.hasAttached()) {\n                this.focusTrap.attachAnchors();\n            }\n        };\n        CdkTrapFocus.decorators = [\n            { type: i0.Directive, args: [{\n                        selector: '[cdkTrapFocus]',\n                        exportAs: 'cdkTrapFocus',\n                    },] }\n        ];\n        /** @nocollapse */\n        CdkTrapFocus.ctorParameters = function () { return [\n            { type: i0.ElementRef },\n            { type: FocusTrapFactory },\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] }\n        ]; };\n        CdkTrapFocus.propDecorators = {\n            enabled: [{ type: i0.Input, args: ['cdkTrapFocus',] }],\n            autoCapture: [{ type: i0.Input, args: ['cdkTrapFocusAutoCapture',] }]\n        };\n        return CdkTrapFocus;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var LIVE_ANNOUNCER_ELEMENT_TOKEN = new i0.InjectionToken('liveAnnouncerElement', {\n        providedIn: 'root',\n        factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\n    });\n    /** @docs-private */\n    function LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {\n        return null;\n    }\n    /** Injection token that can be used to configure the default options for the LiveAnnouncer. */\n    var LIVE_ANNOUNCER_DEFAULT_OPTIONS = new i0.InjectionToken('LIVE_ANNOUNCER_DEFAULT_OPTIONS');\n\n    var LiveAnnouncer = /** @class */ (function () {\n        function LiveAnnouncer(elementToken, _ngZone, _document, _defaultOptions) {\n            this._ngZone = _ngZone;\n            this._defaultOptions = _defaultOptions;\n            // We inject the live element and document as `any` because the constructor signature cannot\n            // reference browser globals (HTMLElement, Document) on non-browser environments, since having\n            // a class decorator causes TypeScript to preserve the constructor signature types.\n            this._document = _document;\n            this._liveElement = elementToken || this._createLiveElement();\n        }\n        LiveAnnouncer.prototype.announce = function (message) {\n            var _a;\n            var _this = this;\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            var defaultOptions = this._defaultOptions;\n            var politeness;\n            var duration;\n            if (args.length === 1 && typeof args[0] === 'number') {\n                duration = args[0];\n            }\n            else {\n                _a = tslib_1.__read(args, 2), politeness = _a[0], duration = _a[1];\n            }\n            this.clear();\n            clearTimeout(this._previousTimeout);\n            if (!politeness) {\n                politeness =\n                    (defaultOptions && defaultOptions.politeness) ? defaultOptions.politeness : 'polite';\n            }\n            if (duration == null && defaultOptions) {\n                duration = defaultOptions.duration;\n            }\n            // TODO: ensure changing the politeness works on all environments we support.\n            this._liveElement.setAttribute('aria-live', politeness);\n            // This 100ms timeout is necessary for some browser + screen-reader combinations:\n            // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n            // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n            //   second time without clearing and then using a non-zero delay.\n            // (using JAWS 17 at time of this writing).\n            return this._ngZone.runOutsideAngular(function () {\n                return new Promise(function (resolve) {\n                    clearTimeout(_this._previousTimeout);\n                    _this._previousTimeout = setTimeout(function () {\n                        _this._liveElement.textContent = message;\n                        resolve();\n                        if (typeof duration === 'number') {\n                            _this._previousTimeout = setTimeout(function () { return _this.clear(); }, duration);\n                        }\n                    }, 100);\n                });\n            });\n        };\n        /**\n         * Clears the current text from the announcer element. Can be used to prevent\n         * screen readers from reading the text out again while the user is going\n         * through the page landmarks.\n         */\n        LiveAnnouncer.prototype.clear = function () {\n            if (this._liveElement) {\n                this._liveElement.textContent = '';\n            }\n        };\n        LiveAnnouncer.prototype.ngOnDestroy = function () {\n            clearTimeout(this._previousTimeout);\n            if (this._liveElement && this._liveElement.parentNode) {\n                this._liveElement.parentNode.removeChild(this._liveElement);\n                this._liveElement = null;\n            }\n        };\n        LiveAnnouncer.prototype._createLiveElement = function () {\n            var elementClass = 'cdk-live-announcer-element';\n            var previousElements = this._document.getElementsByClassName(elementClass);\n            var liveEl = this._document.createElement('div');\n            // Remove any old containers. This can happen when coming in from a server-side-rendered page.\n            for (var i = 0; i < previousElements.length; i++) {\n                previousElements[i].parentNode.removeChild(previousElements[i]);\n            }\n            liveEl.classList.add(elementClass);\n            liveEl.classList.add('cdk-visually-hidden');\n            liveEl.setAttribute('aria-atomic', 'true');\n            liveEl.setAttribute('aria-live', 'polite');\n            this._document.body.appendChild(liveEl);\n            return liveEl;\n        };\n        LiveAnnouncer.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        LiveAnnouncer.ctorParameters = function () { return [\n            { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] }] },\n            { type: i0.NgZone },\n            { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] },\n            { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [LIVE_ANNOUNCER_DEFAULT_OPTIONS,] }] }\n        ]; };\n        LiveAnnouncer.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function LiveAnnouncer_Factory() { return new LiveAnnouncer(i0.ɵɵinject(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i2.DOCUMENT), i0.ɵɵinject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8)); }, token: LiveAnnouncer, providedIn: \"root\" });\n        return LiveAnnouncer;\n    }());\n    /**\n     * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\n     * with a wider range of browsers and screen readers.\n     */\n    var CdkAriaLive = /** @class */ (function () {\n        function CdkAriaLive(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {\n            this._elementRef = _elementRef;\n            this._liveAnnouncer = _liveAnnouncer;\n            this._contentObserver = _contentObserver;\n            this._ngZone = _ngZone;\n            this._politeness = 'off';\n        }\n        Object.defineProperty(CdkAriaLive.prototype, \"politeness\", {\n            /** The aria-live politeness level to use when announcing messages. */\n            get: function () { return this._politeness; },\n            set: function (value) {\n                var _this = this;\n                this._politeness = value === 'polite' || value === 'assertive' ? value : 'off';\n                if (this._politeness === 'off') {\n                    if (this._subscription) {\n                        this._subscription.unsubscribe();\n                        this._subscription = null;\n                    }\n                }\n                else if (!this._subscription) {\n                    this._subscription = this._ngZone.runOutsideAngular(function () {\n                        return _this._contentObserver\n                            .observe(_this._elementRef)\n                            .subscribe(function () {\n                            // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\n                            var elementText = _this._elementRef.nativeElement.textContent;\n                            // The `MutationObserver` fires also for attribute\n                            // changes which we don't want to announce.\n                            if (elementText !== _this._previousAnnouncedText) {\n                                _this._liveAnnouncer.announce(elementText, _this._politeness);\n                                _this._previousAnnouncedText = elementText;\n                            }\n                        });\n                    });\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        CdkAriaLive.prototype.ngOnDestroy = function () {\n            if (this._subscription) {\n                this._subscription.unsubscribe();\n            }\n        };\n        CdkAriaLive.decorators = [\n            { type: i0.Directive, args: [{\n                        selector: '[cdkAriaLive]',\n                        exportAs: 'cdkAriaLive',\n                    },] }\n        ];\n        /** @nocollapse */\n        CdkAriaLive.ctorParameters = function () { return [\n            { type: i0.ElementRef },\n            { type: LiveAnnouncer },\n            { type: observers.ContentObserver },\n            { type: i0.NgZone }\n        ]; };\n        CdkAriaLive.propDecorators = {\n            politeness: [{ type: i0.Input, args: ['cdkAriaLive',] }]\n        };\n        return CdkAriaLive;\n    }());\n    /** @docs-private @deprecated @breaking-change 8.0.0 */\n    function LIVE_ANNOUNCER_PROVIDER_FACTORY(parentAnnouncer, liveElement, _document, ngZone) {\n        return parentAnnouncer || new LiveAnnouncer(liveElement, ngZone, _document);\n    }\n    /** @docs-private @deprecated @breaking-change 8.0.0 */\n    var LIVE_ANNOUNCER_PROVIDER = {\n        // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n        provide: LiveAnnouncer,\n        deps: [\n            [new i0.Optional(), new i0.SkipSelf(), LiveAnnouncer],\n            [new i0.Optional(), new i0.Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n            i2.DOCUMENT,\n            i0.NgZone,\n        ],\n        useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n    };\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n    // that a value of around 650ms seems appropriate.\n    var TOUCH_BUFFER_MS = 650;\n    /**\n     * Event listener options that enable capturing and also\n     * mark the listener as passive if the browser supports it.\n     */\n    var captureEventListenerOptions = i1.normalizePassiveListenerOptions({\n        passive: true,\n        capture: true\n    });\n    /** Monitors mouse and keyboard events to determine the cause of focus events. */\n    var FocusMonitor = /** @class */ (function () {\n        function FocusMonitor(_ngZone, _platform) {\n            var _this = this;\n            this._ngZone = _ngZone;\n            this._platform = _platform;\n            /** The focus origin that the next focus event is a result of. */\n            this._origin = null;\n            /** Whether the window has just been focused. */\n            this._windowFocused = false;\n            /** Map of elements being monitored to their info. */\n            this._elementInfo = new Map();\n            /** The number of elements currently being monitored. */\n            this._monitoredElementCount = 0;\n            /**\n             * Event listener for `keydown` events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._documentKeydownListener = function () {\n                // On keydown record the origin and clear any touch event that may be in progress.\n                _this._lastTouchTarget = null;\n                _this._setOriginForCurrentEventQueue('keyboard');\n            };\n            /**\n             * Event listener for `mousedown` events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._documentMousedownListener = function () {\n                // On mousedown record the origin only if there is not touch\n                // target, since a mousedown can happen as a result of a touch event.\n                if (!_this._lastTouchTarget) {\n                    _this._setOriginForCurrentEventQueue('mouse');\n                }\n            };\n            /**\n             * Event listener for `touchstart` events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._documentTouchstartListener = function (event) {\n                // When the touchstart event fires the focus event is not yet in the event queue. This means\n                // we can't rely on the trick used above (setting timeout of 1ms). Instead we wait 650ms to\n                // see if a focus happens.\n                if (_this._touchTimeoutId != null) {\n                    clearTimeout(_this._touchTimeoutId);\n                }\n                // Since this listener is bound on the `document` level, any events coming from the shadow DOM\n                // will have their `target` set to the shadow root. If available, use `composedPath` to\n                // figure out the event target.\n                _this._lastTouchTarget = event.composedPath ? event.composedPath()[0] : event.target;\n                _this._touchTimeoutId = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n            };\n            /**\n             * Event listener for `focus` events on the window.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._windowFocusListener = function () {\n                // Make a note of when the window regains focus, so we can\n                // restore the origin info for the focused element.\n                _this._windowFocused = true;\n                _this._windowFocusTimeoutId = setTimeout(function () { return _this._windowFocused = false; });\n            };\n        }\n        FocusMonitor.prototype.monitor = function (element, checkChildren) {\n            var _this = this;\n            if (checkChildren === void 0) { checkChildren = false; }\n            // Do nothing if we're not on the browser platform.\n            if (!this._platform.isBrowser) {\n                return rxjs.of(null);\n            }\n            var nativeElement = coercion.coerceElement(element);\n            // Check if we're already monitoring this element.\n            if (this._elementInfo.has(nativeElement)) {\n                var cachedInfo = this._elementInfo.get(nativeElement);\n                cachedInfo.checkChildren = checkChildren;\n                return cachedInfo.subject.asObservable();\n            }\n            // Create monitored element info.\n            var info = {\n                unlisten: function () { },\n                checkChildren: checkChildren,\n                subject: new rxjs.Subject()\n            };\n            this._elementInfo.set(nativeElement, info);\n            this._incrementMonitoredElementCount();\n            // Start listening. We need to listen in capture phase since focus events don't bubble.\n            var focusListener = function (event) { return _this._onFocus(event, nativeElement); };\n            var blurListener = function (event) { return _this._onBlur(event, nativeElement); };\n            this._ngZone.runOutsideAngular(function () {\n                nativeElement.addEventListener('focus', focusListener, true);\n                nativeElement.addEventListener('blur', blurListener, true);\n            });\n            // Create an unlisten function for later.\n            info.unlisten = function () {\n                nativeElement.removeEventListener('focus', focusListener, true);\n                nativeElement.removeEventListener('blur', blurListener, true);\n            };\n            return info.subject.asObservable();\n        };\n        FocusMonitor.prototype.stopMonitoring = function (element) {\n            var nativeElement = coercion.coerceElement(element);\n            var elementInfo = this._elementInfo.get(nativeElement);\n            if (elementInfo) {\n                elementInfo.unlisten();\n                elementInfo.subject.complete();\n                this._setClasses(nativeElement);\n                this._elementInfo.delete(nativeElement);\n                this._decrementMonitoredElementCount();\n            }\n        };\n        FocusMonitor.prototype.focusVia = function (element, origin, options) {\n            var nativeElement = coercion.coerceElement(element);\n            this._setOriginForCurrentEventQueue(origin);\n            // `focus` isn't available on the server\n            if (typeof nativeElement.focus === 'function') {\n                // Cast the element to `any`, because the TS typings don't have the `options` parameter yet.\n                nativeElement.focus(options);\n            }\n        };\n        FocusMonitor.prototype.ngOnDestroy = function () {\n            var _this = this;\n            this._elementInfo.forEach(function (_info, element) { return _this.stopMonitoring(element); });\n        };\n        FocusMonitor.prototype._toggleClass = function (element, className, shouldSet) {\n            if (shouldSet) {\n                element.classList.add(className);\n            }\n            else {\n                element.classList.remove(className);\n            }\n        };\n        /**\n         * Sets the focus classes on the element based on the given focus origin.\n         * @param element The element to update the classes on.\n         * @param origin The focus origin.\n         */\n        FocusMonitor.prototype._setClasses = function (element, origin) {\n            var elementInfo = this._elementInfo.get(element);\n            if (elementInfo) {\n                this._toggleClass(element, 'cdk-focused', !!origin);\n                this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n                this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n                this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n                this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n            }\n        };\n        /**\n         * Sets the origin and schedules an async function to clear it at the end of the event queue.\n         * @param origin The origin to set.\n         */\n        FocusMonitor.prototype._setOriginForCurrentEventQueue = function (origin) {\n            var _this = this;\n            this._ngZone.runOutsideAngular(function () {\n                _this._origin = origin;\n                // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*\n                // tick after the interaction event fired. To ensure the focus origin is always correct,\n                // the focus origin will be determined at the beginning of the next tick.\n                _this._originTimeoutId = setTimeout(function () { return _this._origin = null; }, 1);\n            });\n        };\n        /**\n         * Checks whether the given focus event was caused by a touchstart event.\n         * @param event The focus event to check.\n         * @returns Whether the event was caused by a touch.\n         */\n        FocusMonitor.prototype._wasCausedByTouch = function (event) {\n            // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n            // Consider the following dom structure:\n            //\n            // <div #parent tabindex=\"0\" cdkFocusClasses>\n            //   <div #child (click)=\"#parent.focus()\"></div>\n            // </div>\n            //\n            // If the user touches the #child element and the #parent is programmatically focused as a\n            // result, this code will still consider it to have been caused by the touch event and will\n            // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n            // relatively small edge-case that can be worked around by using\n            // focusVia(parentEl, 'program') to focus the parent element.\n            //\n            // If we decide that we absolutely must handle this case correctly, we can do so by listening\n            // for the first focus event after the touchstart, and then the first blur event after that\n            // focus event. When that blur event fires we know that whatever follows is not a result of the\n            // touchstart.\n            var focusTarget = event.target;\n            return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n                (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n        };\n        /**\n         * Handles focus events on a registered element.\n         * @param event The focus event.\n         * @param element The monitored element.\n         */\n        FocusMonitor.prototype._onFocus = function (event, element) {\n            // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n            // focus event affecting the monitored element. If we want to use the origin of the first event\n            // instead we should check for the cdk-focused class here and return if the element already has\n            // it. (This only matters for elements that have includesChildren = true).\n            // If we are not counting child-element-focus as focused, make sure that the event target is the\n            // monitored element itself.\n            var elementInfo = this._elementInfo.get(element);\n            if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n                return;\n            }\n            // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n            // 1) The window has just regained focus, in which case we want to restore the focused state of\n            //    the element from before the window blurred.\n            // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n            // 3) The element was programmatically focused, in which case we should mark the origin as\n            //    'program'.\n            var origin = this._origin;\n            if (!origin) {\n                if (this._windowFocused && this._lastFocusOrigin) {\n                    origin = this._lastFocusOrigin;\n                }\n                else if (this._wasCausedByTouch(event)) {\n                    origin = 'touch';\n                }\n                else {\n                    origin = 'program';\n                }\n            }\n            this._setClasses(element, origin);\n            this._emitOrigin(elementInfo.subject, origin);\n            this._lastFocusOrigin = origin;\n        };\n        /**\n         * Handles blur events on a registered element.\n         * @param event The blur event.\n         * @param element The monitored element.\n         */\n        FocusMonitor.prototype._onBlur = function (event, element) {\n            // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n            // order to focus another child of the monitored element.\n            var elementInfo = this._elementInfo.get(element);\n            if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n                element.contains(event.relatedTarget))) {\n                return;\n            }\n            this._setClasses(element);\n            this._emitOrigin(elementInfo.subject, null);\n        };\n        FocusMonitor.prototype._emitOrigin = function (subject, origin) {\n            this._ngZone.run(function () { return subject.next(origin); });\n        };\n        FocusMonitor.prototype._incrementMonitoredElementCount = function () {\n            var _this = this;\n            // Register global listeners when first element is monitored.\n            if (++this._monitoredElementCount == 1 && this._platform.isBrowser) {\n                // Note: we listen to events in the capture phase so we\n                // can detect them even if the user stops propagation.\n                this._ngZone.runOutsideAngular(function () {\n                    document.addEventListener('keydown', _this._documentKeydownListener, captureEventListenerOptions);\n                    document.addEventListener('mousedown', _this._documentMousedownListener, captureEventListenerOptions);\n                    document.addEventListener('touchstart', _this._documentTouchstartListener, captureEventListenerOptions);\n                    window.addEventListener('focus', _this._windowFocusListener);\n                });\n            }\n        };\n        FocusMonitor.prototype._decrementMonitoredElementCount = function () {\n            // Unregister global listeners when last element is unmonitored.\n            if (!--this._monitoredElementCount) {\n                document.removeEventListener('keydown', this._documentKeydownListener, captureEventListenerOptions);\n                document.removeEventListener('mousedown', this._documentMousedownListener, captureEventListenerOptions);\n                document.removeEventListener('touchstart', this._documentTouchstartListener, captureEventListenerOptions);\n                window.removeEventListener('focus', this._windowFocusListener);\n                // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n                clearTimeout(this._windowFocusTimeoutId);\n                clearTimeout(this._touchTimeoutId);\n                clearTimeout(this._originTimeoutId);\n            }\n        };\n        FocusMonitor.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        FocusMonitor.ctorParameters = function () { return [\n            { type: i0.NgZone },\n            { type: i1.Platform }\n        ]; };\n        FocusMonitor.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function FocusMonitor_Factory() { return new FocusMonitor(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.Platform)); }, token: FocusMonitor, providedIn: \"root\" });\n        return FocusMonitor;\n    }());\n    /**\n     * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n     * programmatically) and adds corresponding classes to the element.\n     *\n     * There are two variants of this directive:\n     * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n     *    focused.\n     * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n     */\n    var CdkMonitorFocus = /** @class */ (function () {\n        function CdkMonitorFocus(_elementRef, _focusMonitor) {\n            var _this = this;\n            this._elementRef = _elementRef;\n            this._focusMonitor = _focusMonitor;\n            this.cdkFocusChange = new i0.EventEmitter();\n            this._monitorSubscription = this._focusMonitor.monitor(this._elementRef, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n                .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n        }\n        CdkMonitorFocus.prototype.ngOnDestroy = function () {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n            this._monitorSubscription.unsubscribe();\n        };\n        CdkMonitorFocus.decorators = [\n            { type: i0.Directive, args: [{\n                        selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                    },] }\n        ];\n        /** @nocollapse */\n        CdkMonitorFocus.ctorParameters = function () { return [\n            { type: i0.ElementRef },\n            { type: FocusMonitor }\n        ]; };\n        CdkMonitorFocus.propDecorators = {\n            cdkFocusChange: [{ type: i0.Output }]\n        };\n        return CdkMonitorFocus;\n    }());\n    /** @docs-private @deprecated @breaking-change 8.0.0 */\n    function FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n        return parentDispatcher || new FocusMonitor(ngZone, platform);\n    }\n    /** @docs-private @deprecated @breaking-change 8.0.0 */\n    var FOCUS_MONITOR_PROVIDER = {\n        // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n        provide: FocusMonitor,\n        deps: [[new i0.Optional(), new i0.SkipSelf(), FocusMonitor], i0.NgZone, i1.Platform],\n        useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n    };\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Screenreaders will often fire fake mousedown events when a focusable element\n     * is activated using the keyboard. We can typically distinguish between these faked\n     * mousedown events and real mousedown events using the \"buttons\" property. While\n     * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n     * the left mouse button), faked mousedowns will usually set the property value to 0.\n     */\n    function isFakeMousedownFromScreenReader(event) {\n        return event.buttons === 0;\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var A11yModule = /** @class */ (function () {\n        function A11yModule() {\n        }\n        A11yModule.decorators = [\n            { type: i0.NgModule, args: [{\n                        imports: [i2.CommonModule, i1.PlatformModule, observers.ObserversModule],\n                        declarations: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n                        exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n                    },] }\n        ];\n        return A11yModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.MESSAGES_CONTAINER_ID = MESSAGES_CONTAINER_ID;\n    exports.CDK_DESCRIBEDBY_ID_PREFIX = CDK_DESCRIBEDBY_ID_PREFIX;\n    exports.CDK_DESCRIBEDBY_HOST_ATTRIBUTE = CDK_DESCRIBEDBY_HOST_ATTRIBUTE;\n    exports.AriaDescriber = AriaDescriber;\n    exports.ARIA_DESCRIBER_PROVIDER_FACTORY = ARIA_DESCRIBER_PROVIDER_FACTORY;\n    exports.ARIA_DESCRIBER_PROVIDER = ARIA_DESCRIBER_PROVIDER;\n    exports.ActiveDescendantKeyManager = ActiveDescendantKeyManager;\n    exports.FocusKeyManager = FocusKeyManager;\n    exports.ListKeyManager = ListKeyManager;\n    exports.FocusTrap = FocusTrap;\n    exports.FocusTrapFactory = FocusTrapFactory;\n    exports.CdkTrapFocus = CdkTrapFocus;\n    exports.InteractivityChecker = InteractivityChecker;\n    exports.LiveAnnouncer = LiveAnnouncer;\n    exports.CdkAriaLive = CdkAriaLive;\n    exports.LIVE_ANNOUNCER_PROVIDER_FACTORY = LIVE_ANNOUNCER_PROVIDER_FACTORY;\n    exports.LIVE_ANNOUNCER_PROVIDER = LIVE_ANNOUNCER_PROVIDER;\n    exports.LIVE_ANNOUNCER_ELEMENT_TOKEN = LIVE_ANNOUNCER_ELEMENT_TOKEN;\n    exports.LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY = LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY;\n    exports.LIVE_ANNOUNCER_DEFAULT_OPTIONS = LIVE_ANNOUNCER_DEFAULT_OPTIONS;\n    exports.TOUCH_BUFFER_MS = TOUCH_BUFFER_MS;\n    exports.FocusMonitor = FocusMonitor;\n    exports.CdkMonitorFocus = CdkMonitorFocus;\n    exports.FOCUS_MONITOR_PROVIDER_FACTORY = FOCUS_MONITOR_PROVIDER_FACTORY;\n    exports.FOCUS_MONITOR_PROVIDER = FOCUS_MONITOR_PROVIDER;\n    exports.isFakeMousedownFromScreenReader = isFakeMousedownFromScreenReader;\n    exports.A11yModule = A11yModule;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=cdk-a11y.umd.js.map\n"]}