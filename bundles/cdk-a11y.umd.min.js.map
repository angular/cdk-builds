{"version":3,"file":"cdk-a11y.umd.min.js","sources":["../../node_modules/tslib/tslib.es6.js","../../src/cdk/a11y/interactivity-checker.ts","../../src/cdk/a11y/aria-reference.ts","../../src/cdk/a11y/aria-describer.ts","../../src/cdk/a11y/list-key-manager.ts","../../src/cdk/a11y/index.ts","../../src/cdk/a11y/focus-trap.ts","../../src/cdk/a11y/live-announcer.ts","../../src/cdk/a11y/fake-mousedown.ts","../../src/cdk/a11y/activedescendant-key-manager.ts","../../src/cdk/a11y/focus-key-manager.ts","../../src/cdk/a11y/public_api.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Injectable} from '@angular/core';\nimport {Platform} from '@angular/cdk/platform';\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nexport class InteractivityChecker {\n/**\n * @param {?} _platform\n */\nconstructor(private _platform: Platform) {}\n/**\n * Gets whether an element is disabled.\n * \n * @param {?} element Element to be checked.\n * @return {?} Whether the element is disabled.\n */\nisDisabled(element: HTMLElement): boolean {\n    // This does not capture some cases, such as a non-form control with a disabled attribute or\n    // a form control inside of a disabled form, but should capture the most common cases.\n    return element.hasAttribute('disabled');\n  }\n/**\n * Gets whether an element is visible for the purposes of interactivity.\n * \n * This will capture states like `display: none` and `visibility: hidden`, but not things like\n * being clipped by an `overflow: hidden` parent or being outside the viewport.\n * \n * @param {?} element\n * @return {?} Whether the element is visible.\n */\nisVisible(element: HTMLElement): boolean {\n    return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n  }\n/**\n * Gets whether an element can be reached via Tab key.\n * Assumes that the element has already been checked with isFocusable.\n * \n * @param {?} element Element to be checked.\n * @return {?} Whether the element is tabbable.\n */\nisTabbable(element: HTMLElement): boolean {\n    // Nothing is tabbable on the the server ðŸ˜Ž\n    if (!this._platform.isBrowser) {\n      return false;\n    }\n\n    let /** @type {?} */ frameElement = /** @type {?} */(( getWindow(element).frameElement as HTMLElement));\n\n    if (frameElement) {\n\n      let /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\n\n      // Frame elements inherit their tabindex onto all child elements.\n      if (getTabIndexValue(frameElement) === -1) {\n        return false;\n      }\n\n      // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n      if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n        return false;\n      }\n\n      // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n      if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n        return false;\n      }\n\n    }\n\n    let /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    let /** @type {?} */ tabIndexValue = getTabIndexValue(element);\n\n    if (element.hasAttribute('contenteditable')) {\n      return tabIndexValue !== -1;\n    }\n\n    if (nodeName === 'iframe') {\n      // The frames may be tabbable depending on content, but it's not possibly to reliably\n      // investigate the content of the frames.\n      return false;\n    }\n\n    if (nodeName === 'audio') {\n      if (!element.hasAttribute('controls')) {\n        // By default an <audio> element without the controls enabled is not tabbable.\n        return false;\n      } else if (this._platform.BLINK) {\n        // In Blink <audio controls> elements are always tabbable.\n        return true;\n      }\n    }\n\n    if (nodeName === 'video') {\n      if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n        // In Trident a <video> element without the controls enabled is not tabbable.\n        return false;\n      } else if (this._platform.BLINK || this._platform.FIREFOX) {\n        // In Chrome and Firefox <video controls> elements are always tabbable.\n        return true;\n      }\n    }\n\n    if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n      // In all Blink and WebKit based browsers <object> elements are never tabbable.\n      return false;\n    }\n\n    // In iOS the browser only considers some specific elements as tabbable.\n    if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n      return false;\n    }\n\n    return element.tabIndex >= 0;\n  }\n/**\n * Gets whether an element can be focused by the user.\n * \n * @param {?} element Element to be checked.\n * @return {?} Whether the element is focusable.\n */\nisFocusable(element: HTMLElement): boolean {\n    // Perform checks in order of left to most expensive.\n    // Again, naive approach that does not capture many edge cases and browser quirks.\n    return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n  }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Platform, },\n];\n}\n\nfunction InteractivityChecker_tsickle_Closure_declarations() {\n/** @type {?} */\nInteractivityChecker.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nInteractivityChecker.ctorParameters;\n/** @type {?} */\nInteractivityChecker.prototype._platform;\n}\n\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element: HTMLElement): boolean {\n  // Use logic from jQuery to check for an invisible element.\n  // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n  return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element: Node) {\n  let /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n  return nodeName === 'input' ||\n      nodeName === 'select' ||\n      nodeName === 'button' ||\n      nodeName === 'textarea';\n}\n/**\n * Gets whether an element is an <input type=\"hidden\">.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element: HTMLElement): boolean {\n  return isInputElement(element) && element.type == 'hidden';\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element: HTMLElement): boolean {\n  return isAnchorElement(element) && element.hasAttribute('href');\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element: HTMLElement): element is HTMLInputElement {\n  return element.nodeName.toLowerCase() == 'input';\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element: HTMLElement): element is HTMLAnchorElement {\n  return element.nodeName.toLowerCase() == 'a';\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element: HTMLElement): boolean {\n  if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n    return false;\n  }\n\n  let /** @type {?} */ tabIndex = element.getAttribute('tabindex');\n\n  // IE11 parses tabindex=\"\" as the value \"-32768\"\n  if (tabIndex == '-32768') {\n    return false;\n  }\n\n  return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element: HTMLElement): number | null {\n  if (!hasValidTabIndex(element)) {\n    return null;\n  }\n\n  // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n  const /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n\n  return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element: HTMLElement): boolean {\n  let /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n  let /** @type {?} */ inputType = nodeName === 'input' && ( /** @type {?} */((element as HTMLInputElement))).type;\n\n  return inputType === 'text'\n      || inputType === 'password'\n      || nodeName === 'select'\n      || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element: HTMLElement): boolean {\n  // Inputs are potentially focusable *unless* they're type=\"hidden\".\n  if (isHiddenInput(element)) {\n    return false;\n  }\n\n  return isNativeFormElement(element) ||\n      isAnchorWithHref(element) ||\n      element.hasAttribute('contenteditable') ||\n      hasValidTabIndex(element);\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node: HTMLElement): Window {\n  return node.ownerDocument.defaultView || window;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nconst ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nexport function addAriaReferencedId(el: Element, attr: string, id: string) {\n  const /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n  if (ids.some(existingId => existingId.trim() == id.trim())) { return; }\n  ids.push(id.trim());\n\n  el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nexport function removeAriaReferencedId(el: Element, attr: string, id: string) {\n  const /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n  const /** @type {?} */ filteredIds = ids.filter(val => val != id.trim());\n\n  el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nexport function getAriaReferenceIds(el: Element, attr: string): string[] {\n  // Get string array of all individual ids (whitespace deliminated) in the attribute value\n  return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Injectable, Optional, SkipSelf} from '@angular/core';\nimport {Platform} from '@angular/cdk/platform';\nimport {addAriaReferencedId, getAriaReferenceIds, removeAriaReferencedId} from './aria-reference';\n\n/**\n * Interface used to register message elements and keep a count of how many registrations have\n * the same message and the reference to the message element used for the aria-describedby.\n */\nexport interface RegisteredMessage {\n  messageElement: Element;\n  referenceCount: number;\n}\n/**\n * ID used for the body container where all messages are appended.\n */\nexport const MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nexport const CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nexport const CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nlet nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nconst messageRegistry = new Map<string, RegisteredMessage>();\n/**\n * Container for all registered messages.\n */\nlet messagesContainer: HTMLElement | null = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n * \\@docs-private\n */\nexport class AriaDescriber {\n/**\n * @param {?} _platform\n */\nconstructor(private _platform: Platform) { }\n/**\n * Adds to the host element an aria-describedby reference to a hidden element that contains\n * the message. If the same message has already been registered, then it will reuse the created\n * message element.\n * @param {?} hostElement\n * @param {?} message\n * @return {?}\n */\ndescribe(hostElement: Element, message: string) {\n    if (!this._platform.isBrowser || !message.trim()) { return; }\n\n    if (!messageRegistry.has(message)) {\n      createMessageElement(message);\n    }\n\n    if (!isElementDescribedByMessage(hostElement, message)) {\n      addMessageReference(hostElement, message);\n    }\n  }\n/**\n * Removes the host element's aria-describedby reference to the message element.\n * @param {?} hostElement\n * @param {?} message\n * @return {?}\n */\nremoveDescription(hostElement: Element, message: string) {\n    if (!this._platform.isBrowser || !message.trim()) {\n      return;\n    }\n\n    if (isElementDescribedByMessage(hostElement, message)) {\n      removeMessageReference(hostElement, message);\n    }\n\n    const /** @type {?} */ registeredMessage = messageRegistry.get(message);\n    if (registeredMessage && registeredMessage.referenceCount === 0) {\n      deleteMessageElement(message);\n    }\n\n    if (messagesContainer && messagesContainer.childNodes.length === 0) {\n      deleteMessagesContainer();\n    }\n  }\n/**\n * Unregisters all created message elements and removes the message container.\n * @return {?}\n */\nngOnDestroy() {\n    if (!this._platform.isBrowser) { return; }\n\n    const /** @type {?} */ describedElements = document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}]`);\n    for (let /** @type {?} */ i = 0; i < describedElements.length; i++) {\n      removeCdkDescribedByReferenceIds(describedElements[i]);\n      describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n    }\n\n    if (messagesContainer) {\n      deleteMessagesContainer();\n    }\n\n    messageRegistry.clear();\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Platform, },\n];\n}\n\nfunction AriaDescriber_tsickle_Closure_declarations() {\n/** @type {?} */\nAriaDescriber.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nAriaDescriber.ctorParameters;\n/** @type {?} */\nAriaDescriber.prototype._platform;\n}\n\n/**\n * Creates a new element in the visually hidden message container element with the message\n * as its content and adds it to the message registry.\n * @param {?} message\n * @return {?}\n */\nfunction createMessageElement(message: string) {\n  const /** @type {?} */ messageElement = document.createElement('div');\n  messageElement.setAttribute('id', `${CDK_DESCRIBEDBY_ID_PREFIX}-${nextId++}`);\n  messageElement.appendChild( /** @type {?} */((document.createTextNode(message))));\n\n  if (!messagesContainer) { createMessagesContainer(); } /** @type {?} */((\n  messagesContainer)).appendChild(messageElement);\n\n  messageRegistry.set(message, {messageElement, referenceCount: 0});\n}\n/**\n * Deletes the message element from the global messages container.\n * @param {?} message\n * @return {?}\n */\nfunction deleteMessageElement(message: string) {\n  const /** @type {?} */ registeredMessage = messageRegistry.get(message);\n  const /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\n  if (messagesContainer && messageElement) {\n    messagesContainer.removeChild(messageElement);\n  }\n  messageRegistry.delete(message);\n}\n/**\n * Creates the global container for all aria-describedby messages.\n * @return {?}\n */\nfunction createMessagesContainer() {\n  messagesContainer = document.createElement('div');\n\n  messagesContainer.setAttribute('id', MESSAGES_CONTAINER_ID);\n  messagesContainer.setAttribute('aria-hidden', 'true');\n  messagesContainer.style.display = 'none';\n  document.body.appendChild(messagesContainer);\n}\n/**\n * Deletes the global messages container.\n * @return {?}\n */\nfunction deleteMessagesContainer() {\n  document.body.removeChild( /** @type {?} */((messagesContainer)));\n  messagesContainer = null;\n}\n/**\n * Removes all cdk-describedby messages that are hosted through the element.\n * @param {?} element\n * @return {?}\n */\nfunction removeCdkDescribedByReferenceIds(element: Element) {\n  // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n  const /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n      .filter(id => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);\n  element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n}\n/**\n * Adds a message reference to the element using aria-describedby and increments the registered\n * message's reference count.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction addMessageReference(element: Element, message: string) {\n  const /** @type {?} */ registeredMessage = /** @type {?} */(( messageRegistry.get(message)));\n\n  // Add the aria-describedby reference and set the describedby_host attribute to mark the element.\n  addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n  element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n\n  registeredMessage.referenceCount++;\n}\n/**\n * Removes a message reference from the element using aria-describedby and decrements the registered\n * message's reference count.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction removeMessageReference(element: Element, message: string) {\n  const /** @type {?} */ registeredMessage = /** @type {?} */(( messageRegistry.get(message)));\n  registeredMessage.referenceCount--;\n\n  removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n  element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n}\n/**\n * Returns true if the element has been described by the provided message ID.\n * @param {?} element\n * @param {?} message\n * @return {?}\n */\nfunction isElementDescribedByMessage(element: Element, message: string): boolean {\n  const /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n  const /** @type {?} */ registeredMessage = messageRegistry.get(message);\n  const /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\n\n  return !!messageId && referenceIds.indexOf(messageId) != -1;\n}\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} platform\n * @return {?}\n */\nexport function ARIA_DESCRIBER_PROVIDER_FACTORY(\n    parentDispatcher: AriaDescriber, platform: Platform) {\n  return parentDispatcher || new AriaDescriber(platform);\n}\n/**\n * \\@docs-private\n */\nexport const ARIA_DESCRIBER_PROVIDER = {\n  // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n  provide: AriaDescriber,\n  deps: [\n    [new Optional(), new SkipSelf(), AriaDescriber],\n    Platform\n  ],\n  useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n};\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {QueryList} from '@angular/core';\nimport {Subject} from 'rxjs/Subject';\nimport {Subscription} from 'rxjs/Subscription';\nimport {UP_ARROW, DOWN_ARROW, TAB, A, Z, ZERO, NINE} from '@angular/cdk/keycodes';\nimport {RxChain, debounceTime, filter, map, doOperator} from '@angular/cdk/rxjs';\n\n/**\n * This interface is for items that can be passed to a ListKeyManager.\n */\nexport interface ListKeyManagerOption {\n  disabled?: boolean;\n  getLabel?(): string;\n}\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nexport class ListKeyManager<T extends ListKeyManagerOption> {\nprivate _activeItemIndex = -1;\nprivate _activeItem: T;\nprivate _wrap = false;\nprivate _letterKeyStream = new Subject<string>();\nprivate _typeaheadSubscription = Subscription.EMPTY;\nprivate _pressedLetters: string[] = [];\n/**\n * @param {?} _items\n */\nconstructor(private _items: QueryList<T>) { }\n/**\n * Stream that emits any time the TAB key is pressed, so components can react\n * when focus is shifted off of the list.\n */\ntabOut: Subject<void> = new Subject<void>();\n/**\n * Turns on wrapping mode, which ensures that the active item will wrap to\n * the other end of list when there are no more items in the given direction.\n * @return {?}\n */\nwithWrap(): this {\n    this._wrap = true;\n    return this;\n  }\n/**\n * Turns on typeahead mode which allows users to set the active item by typing.\n * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n * @return {?}\n */\nwithTypeAhead(debounceInterval = 200): this {\n    if (this._items.length && this._items.some(item => typeof item.getLabel !== 'function')) {\n      throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n    }\n\n    this._typeaheadSubscription.unsubscribe();\n\n    // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n    // and convert those letters back into a string. Afterwards find the first item that starts\n    // with that string and select it.\n    this._typeaheadSubscription = RxChain.from(this._letterKeyStream)\n      .call(doOperator, keyCode => this._pressedLetters.push(keyCode))\n      .call(debounceTime, debounceInterval)\n      .call(filter, () => this._pressedLetters.length > 0)\n      .call(map, () => this._pressedLetters.join(''))\n      .subscribe(inputString => {\n        const /** @type {?} */ items = this._items.toArray();\n\n        for (let /** @type {?} */ i = 0; i < items.length; i++) {\n          if ( /** @type {?} */((items[i].getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\n            this.setActiveItem(i);\n            break;\n          }\n        }\n\n        this._pressedLetters = [];\n      });\n\n    return this;\n  }\n/**\n * Sets the active item to the item at the index specified.\n * @param {?} index The index of the item to be set as active.\n * @return {?}\n */\nsetActiveItem(index: number): void {\n    this._activeItemIndex = index;\n    this._activeItem = this._items.toArray()[index];\n  }\n/**\n * Sets the active item depending on the key event passed in.\n * @param {?} event Keyboard event to be used for determining which element should be active.\n * @return {?}\n */\nonKeydown(event: KeyboardEvent): void {\n    switch (event.keyCode) {\n      case DOWN_ARROW: this.setNextItemActive(); break;\n      case UP_ARROW: this.setPreviousItemActive(); break;\n      case TAB: this.tabOut.next(); return;\n      default:\n        const /** @type {?} */ keyCode = event.keyCode;\n\n        // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n        // otherwise fall back to resolving alphanumeric characters via the keyCode.\n        if (event.key && event.key.length === 1) {\n          this._letterKeyStream.next(event.key.toLocaleUpperCase());\n        } else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n          this._letterKeyStream.next(String.fromCharCode(keyCode));\n        }\n\n        // Note that we return here, in order to avoid preventing\n        // the default action of non-navigational keys.\n        return;\n    }\n\n    this._pressedLetters = [];\n    event.preventDefault();\n  }\n/**\n * Index of the currently active item.\n * @return {?}\n */\nget activeItemIndex(): number | null {\n    return this._activeItemIndex;\n  }\n/**\n * The active item.\n * @return {?}\n */\nget activeItem(): T | null {\n    return this._activeItem;\n  }\n/**\n * Sets the active item to the first enabled item in the list.\n * @return {?}\n */\nsetFirstItemActive(): void {\n    this._setActiveItemByIndex(0, 1);\n  }\n/**\n * Sets the active item to the last enabled item in the list.\n * @return {?}\n */\nsetLastItemActive(): void {\n    this._setActiveItemByIndex(this._items.length - 1, -1);\n  }\n/**\n * Sets the active item to the next enabled item in the list.\n * @return {?}\n */\nsetNextItemActive(): void {\n    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n  }\n/**\n * Sets the active item to a previous enabled item in the list.\n * @return {?}\n */\nsetPreviousItemActive(): void {\n    this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n                                            : this._setActiveItemByDelta(-1);\n  }\n/**\n * Allows setting of the activeItemIndex without any other effects.\n * @param {?} index The new activeItemIndex.\n * @return {?}\n */\nupdateActiveItemIndex(index: number) {\n    this._activeItemIndex = index;\n  }\n/**\n * This method sets the active item, given a list of items and the delta between the\n * currently active item and the new active item. It will calculate differently\n * depending on whether wrap mode is turned on.\n * @param {?} delta\n * @param {?=} items\n * @return {?}\n */\nprivate _setActiveItemByDelta(delta: number, items = this._items.toArray()): void {\n    this._wrap ? this._setActiveInWrapMode(delta, items)\n               : this._setActiveInDefaultMode(delta, items);\n  }\n/**\n * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n * down the list until it finds an item that is not disabled, and it will wrap if it\n * encounters either end of the list.\n * @param {?} delta\n * @param {?} items\n * @return {?}\n */\nprivate _setActiveInWrapMode(delta: number, items: T[]): void {\n    // when active item would leave menu, wrap to beginning or end\n    this._activeItemIndex =\n      (this._activeItemIndex + delta + items.length) % items.length;\n\n    // skip all disabled menu items recursively until an enabled one is reached\n    if (items[this._activeItemIndex].disabled) {\n      this._setActiveInWrapMode(delta, items);\n    } else {\n      this.setActiveItem(this._activeItemIndex);\n    }\n  }\n/**\n * Sets the active item properly given the default mode. In other words, it will\n * continue to move down the list until it finds an item that is not disabled. If\n * it encounters either end of the list, it will stop and not wrap.\n * @param {?} delta\n * @param {?} items\n * @return {?}\n */\nprivate _setActiveInDefaultMode(delta: number, items: T[]): void {\n    this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n  }\n/**\n * Sets the active item to the first enabled item starting at the index specified. If the\n * item is disabled, it will move in the fallbackDelta direction until it either\n * finds an enabled item or encounters the end of the list.\n * @param {?} index\n * @param {?} fallbackDelta\n * @param {?=} items\n * @return {?}\n */\nprivate _setActiveItemByIndex(index: number, fallbackDelta: number,\n                                  items = this._items.toArray()): void {\n    if (!items[index]) { return; }\n    while (items[index].disabled) {\n      index += fallbackDelta;\n      if (!items[index]) { return; }\n    }\n    this.setActiveItem(index);\n  }\n}\n\nfunction ListKeyManager_tsickle_Closure_declarations() {\n/** @type {?} */\nListKeyManager.prototype._activeItemIndex;\n/** @type {?} */\nListKeyManager.prototype._activeItem;\n/** @type {?} */\nListKeyManager.prototype._wrap;\n/** @type {?} */\nListKeyManager.prototype._letterKeyStream;\n/** @type {?} */\nListKeyManager.prototype._typeaheadSubscription;\n/** @type {?} */\nListKeyManager.prototype._pressedLetters;\n/**\n * Stream that emits any time the TAB key is pressed, so components can react\n * when focus is shifted off of the list.\n * @type {?}\n */\nListKeyManager.prototype.tabOut;\n/** @type {?} */\nListKeyManager.prototype._items;\n}\n\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport {A11yModule,Highlightable,ActiveDescendantKeyManager,RegisteredMessage,MESSAGES_CONTAINER_ID,CDK_DESCRIBEDBY_ID_PREFIX,CDK_DESCRIBEDBY_HOST_ATTRIBUTE,AriaDescriber,ARIA_DESCRIBER_PROVIDER_FACTORY,ARIA_DESCRIBER_PROVIDER,isFakeMousedownFromScreenReader,FocusableOption,FocusKeyManager,FocusTrap,FocusTrapFactory,FocusTrapDeprecatedDirective,FocusTrapDirective,InteractivityChecker,ListKeyManagerOption,ListKeyManager,LIVE_ANNOUNCER_ELEMENT_TOKEN,AriaLivePoliteness,LiveAnnouncer,LIVE_ANNOUNCER_PROVIDER_FACTORY,LIVE_ANNOUNCER_PROVIDER} from './public_api';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {\n  Directive,\n  ElementRef,\n  Input,\n  NgZone,\n  OnDestroy,\n  AfterContentInit,\n  Injectable,\n} from '@angular/core';\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {Platform} from '@angular/cdk/platform';\nimport {first} from '@angular/cdk/rxjs';\nimport {InteractivityChecker} from './interactivity-checker';\n/**\n * Class that allows for trapping focus within a DOM element.\n * \n * NOTE: This class currently uses a very simple (naive) approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.\n * This will be replaced with a more intelligent solution before the library is considered stable.\n */\nexport class FocusTrap {\nprivate _startAnchor: HTMLElement | null;\nprivate _endAnchor: HTMLElement | null;\n/**\n * Whether the focus trap is active.\n * @return {?}\n */\nget enabled(): boolean { return this._enabled; }\n/**\n * @param {?} val\n * @return {?}\n */\nset enabled(val: boolean) {\n    this._enabled = val;\n\n    if (this._startAnchor && this._endAnchor) {\n      this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\n    }\n  }\nprivate _enabled: boolean = true;\n/**\n * @param {?} _element\n * @param {?} _platform\n * @param {?} _checker\n * @param {?} _ngZone\n * @param {?=} deferAnchors\n */\nconstructor(\nprivate _element: HTMLElement,\nprivate _platform: Platform,\nprivate _checker: InteractivityChecker,\nprivate _ngZone: NgZone,\n    deferAnchors = false) {\n\n    if (!deferAnchors) {\n      this.attachAnchors();\n    }\n  }\n/**\n * Destroys the focus trap by cleaning up the anchors.\n * @return {?}\n */\ndestroy() {\n    if (this._startAnchor && this._startAnchor.parentNode) {\n      this._startAnchor.parentNode.removeChild(this._startAnchor);\n    }\n\n    if (this._endAnchor && this._endAnchor.parentNode) {\n      this._endAnchor.parentNode.removeChild(this._endAnchor);\n    }\n\n    this._startAnchor = this._endAnchor = null;\n  }\n/**\n * Inserts the anchors into the DOM. This is usually done automatically\n * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n * @return {?}\n */\nattachAnchors(): void {\n    // If we're not on the browser, there can be no focus to trap.\n    if (!this._platform.isBrowser) {\n      return;\n    }\n\n    if (!this._startAnchor) {\n      this._startAnchor = this._createAnchor();\n    }\n\n    if (!this._endAnchor) {\n      this._endAnchor = this._createAnchor();\n    }\n\n    this._ngZone.runOutsideAngular(() => { /** @type {?} */((\n      this._startAnchor)).addEventListener('focus', () => {\n        this.focusLastTabbableElement();\n      }); /** @type {?} */((\n\n      this._endAnchor)).addEventListener('focus', () => {\n        this.focusFirstTabbableElement();\n      });\n\n      if (this._element.parentNode) {\n        this._element.parentNode.insertBefore( /** @type {?} */((this._startAnchor)), this._element);\n        this._element.parentNode.insertBefore( /** @type {?} */((this._endAnchor)), this._element.nextSibling);\n      }\n    });\n  }\n/**\n * Waits for the zone to stabilize, then either focuses the first element that the\n * user specified, or the first tabbable element.\n * @return {?} Returns a promise that resolves with a boolean, depending\n * on whether focus was moved successfuly.\n */\nfocusInitialElementWhenReady(): Promise<boolean> {\n    return new Promise<boolean>(resolve => {\n      this._executeOnStable(() => resolve(this.focusInitialElement()));\n    });\n  }\n/**\n * Waits for the zone to stabilize, then focuses\n * the first tabbable element within the focus trap region.\n * @return {?} Returns a promise that resolves with a boolean, depending\n * on whether focus was moved successfuly.\n */\nfocusFirstTabbableElementWhenReady(): Promise<boolean> {\n    return new Promise<boolean>(resolve => {\n      this._executeOnStable(() => resolve(this.focusFirstTabbableElement()));\n    });\n  }\n/**\n * Waits for the zone to stabilize, then focuses\n * the last tabbable element within the focus trap region.\n * @return {?} Returns a promise that resolves with a boolean, depending\n * on whether focus was moved successfuly.\n */\nfocusLastTabbableElementWhenReady(): Promise<boolean> {\n    return new Promise<boolean>(resolve => {\n      this._executeOnStable(() => resolve(this.focusLastTabbableElement()));\n    });\n  }\n/**\n * Get the specified boundary element of the trapped region.\n * @param {?} bound The boundary to get (start or end of trapped region).\n * @return {?} The boundary element.\n */\nprivate _getRegionBoundary(bound: 'start' | 'end'): HTMLElement | null {\n    // Contains the deprecated version of selector, for temporary backwards comparability.\n    let /** @type {?} */ markers = /** @type {?} */(( this._element.querySelectorAll(`[cdk-focus-region-${bound}], ` +\n                                                 `[cdk-focus-${bound}]`) as NodeListOf<HTMLElement>));\n\n    for (let /** @type {?} */ i = 0; i < markers.length; i++) {\n      if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {\n        console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}',` +\n                     ` use 'cdk-focus-region-${bound}' instead.`, markers[i]);\n      }\n    }\n\n    if (bound == 'start') {\n      return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n    }\n    return markers.length ?\n        markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n  }\n/**\n * Focuses the element that should be focused when the focus trap is initialized.\n * @return {?} Returns whether focus was moved successfuly.\n */\nfocusInitialElement(): boolean {\n    const /** @type {?} */ redirectToElement = /** @type {?} */(( this._element.querySelector('[cdk-focus-initial]') as HTMLElement));\n\n    if (redirectToElement) {\n      redirectToElement.focus();\n      return true;\n    }\n\n    return this.focusFirstTabbableElement();\n  }\n/**\n * Focuses the first tabbable element within the focus trap region.\n * @return {?} Returns whether focus was moved successfuly.\n */\nfocusFirstTabbableElement(): boolean {\n    const /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\n\n    if (redirectToElement) {\n      redirectToElement.focus();\n    }\n\n    return !!redirectToElement;\n  }\n/**\n * Focuses the last tabbable element within the focus trap region.\n * @return {?} Returns whether focus was moved successfuly.\n */\nfocusLastTabbableElement(): boolean {\n    const /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\n\n    if (redirectToElement) {\n      redirectToElement.focus();\n    }\n\n    return !!redirectToElement;\n  }\n/**\n * Get the first tabbable element from a DOM subtree (inclusive).\n * @param {?} root\n * @return {?}\n */\nprivate _getFirstTabbableElement(root: HTMLElement): HTMLElement | null {\n    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n      return root;\n    }\n\n    // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n    // back to `childNodes` which includes text nodes, comments etc.\n    let /** @type {?} */ children = root.children || root.childNodes;\n\n    for (let /** @type {?} */ i = 0; i < children.length; i++) {\n      let /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\n        this._getFirstTabbableElement( /** @type {?} */((children[i] as HTMLElement))) :\n        null;\n\n      if (tabbableChild) {\n        return tabbableChild;\n      }\n    }\n\n    return null;\n  }\n/**\n * Get the last tabbable element from a DOM subtree (inclusive).\n * @param {?} root\n * @return {?}\n */\nprivate _getLastTabbableElement(root: HTMLElement): HTMLElement | null {\n    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n      return root;\n    }\n\n    // Iterate in reverse DOM order.\n    let /** @type {?} */ children = root.children || root.childNodes;\n\n    for (let /** @type {?} */ i = children.length - 1; i >= 0; i--) {\n      let /** @type {?} */ tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?\n        this._getLastTabbableElement( /** @type {?} */((children[i] as HTMLElement))) :\n        null;\n\n      if (tabbableChild) {\n        return tabbableChild;\n      }\n    }\n\n    return null;\n  }\n/**\n * Creates an anchor element.\n * @return {?}\n */\nprivate _createAnchor(): HTMLElement {\n    let /** @type {?} */ anchor = document.createElement('div');\n    anchor.tabIndex = this._enabled ? 0 : -1;\n    anchor.classList.add('cdk-visually-hidden');\n    anchor.classList.add('cdk-focus-trap-anchor');\n    return anchor;\n  }\n/**\n * Executes a function when the zone is stable.\n * @param {?} fn\n * @return {?}\n */\nprivate _executeOnStable(fn: () => any): void {\n    if (this._ngZone.isStable) {\n      fn();\n    } else {\n      first.call(this._ngZone.onStable.asObservable()).subscribe(fn);\n    }\n  }\n}\n\nfunction FocusTrap_tsickle_Closure_declarations() {\n/** @type {?} */\nFocusTrap.prototype._startAnchor;\n/** @type {?} */\nFocusTrap.prototype._endAnchor;\n/** @type {?} */\nFocusTrap.prototype._enabled;\n/** @type {?} */\nFocusTrap.prototype._element;\n/** @type {?} */\nFocusTrap.prototype._platform;\n/** @type {?} */\nFocusTrap.prototype._checker;\n/** @type {?} */\nFocusTrap.prototype._ngZone;\n}\n\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nexport class FocusTrapFactory {\n/**\n * @param {?} _checker\n * @param {?} _platform\n * @param {?} _ngZone\n */\nconstructor(\nprivate _checker: InteractivityChecker,\nprivate _platform: Platform,\nprivate _ngZone: NgZone) { }\n/**\n * @param {?} element\n * @param {?=} deferAnchors\n * @return {?}\n */\ncreate(element: HTMLElement, deferAnchors = false): FocusTrap {\n    return new FocusTrap(element, this._platform, this._checker, this._ngZone, deferAnchors);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: InteractivityChecker, },\n{type: Platform, },\n{type: NgZone, },\n];\n}\n\nfunction FocusTrapFactory_tsickle_Closure_declarations() {\n/** @type {?} */\nFocusTrapFactory.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nFocusTrapFactory.ctorParameters;\n/** @type {?} */\nFocusTrapFactory.prototype._checker;\n/** @type {?} */\nFocusTrapFactory.prototype._platform;\n/** @type {?} */\nFocusTrapFactory.prototype._ngZone;\n}\n\n/**\n * Directive for trapping focus within a region.\n * @deprecated\n */\nexport class FocusTrapDeprecatedDirective implements OnDestroy, AfterContentInit {\n  focusTrap: FocusTrap;\n/**\n * Whether the focus trap is active.\n * @return {?}\n */\nget disabled(): boolean { return !this.focusTrap.enabled; }\n/**\n * @param {?} val\n * @return {?}\n */\nset disabled(val: boolean) {\n    this.focusTrap.enabled = !coerceBooleanProperty(val);\n  }\n/**\n * @param {?} _elementRef\n * @param {?} _focusTrapFactory\n */\nconstructor(private _elementRef: ElementRef,\nprivate _focusTrapFactory: FocusTrapFactory) {\n    this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this.focusTrap.destroy();\n  }\n/**\n * @return {?}\n */\nngAfterContentInit() {\n    this.focusTrap.attachAnchors();\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: 'cdk-focus-trap',\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: FocusTrapFactory, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'disabled': [{ type: Input },],\n};\n}\n\nfunction FocusTrapDeprecatedDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nFocusTrapDeprecatedDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nFocusTrapDeprecatedDirective.ctorParameters;\n/** @type {?} */\nFocusTrapDeprecatedDirective.propDecorators;\n/** @type {?} */\nFocusTrapDeprecatedDirective.prototype.focusTrap;\n/** @type {?} */\nFocusTrapDeprecatedDirective.prototype._elementRef;\n/** @type {?} */\nFocusTrapDeprecatedDirective.prototype._focusTrapFactory;\n}\n\n/**\n * Directive for trapping focus within a region.\n */\nexport class FocusTrapDirective implements OnDestroy, AfterContentInit {\n  focusTrap: FocusTrap;\n/**\n * Whether the focus trap is active.\n * @return {?}\n */\nget enabled(): boolean { return this.focusTrap.enabled; }\n/**\n * @param {?} value\n * @return {?}\n */\nset enabled(value: boolean) { this.focusTrap.enabled = coerceBooleanProperty(value); }\n/**\n * @param {?} _elementRef\n * @param {?} _focusTrapFactory\n */\nconstructor(private _elementRef: ElementRef,\nprivate _focusTrapFactory: FocusTrapFactory) {\n    this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this.focusTrap.destroy();\n  }\n/**\n * @return {?}\n */\nngAfterContentInit() {\n    this.focusTrap.attachAnchors();\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: '[cdkTrapFocus]',\n  exportAs: 'cdkTrapFocus',\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: FocusTrapFactory, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'enabled': [{ type: Input, args: ['cdkTrapFocus', ] },],\n};\n}\n\nfunction FocusTrapDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nFocusTrapDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nFocusTrapDirective.ctorParameters;\n/** @type {?} */\nFocusTrapDirective.propDecorators;\n/** @type {?} */\nFocusTrapDirective.prototype.focusTrap;\n/** @type {?} */\nFocusTrapDirective.prototype._elementRef;\n/** @type {?} */\nFocusTrapDirective.prototype._focusTrapFactory;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {\n  Injectable,\n  InjectionToken,\n  Optional,\n  Inject,\n  SkipSelf,\n  OnDestroy,\n} from '@angular/core';\nimport {Platform} from '@angular/cdk/platform';\n\n\nexport const /** @type {?} */ LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken<HTMLElement>('liveAnnouncerElement');\n\n/** Possible politeness levels. */\nexport type AriaLivePoliteness = 'off' | 'polite' | 'assertive';\nexport class LiveAnnouncer implements OnDestroy {\nprivate _liveElement: Element;\n/**\n * @param {?} elementToken\n * @param {?} platform\n */\nconstructor(\n        elementToken: any,\n      platform: Platform) {\n    // Only do anything if we're on the browser platform.\n    if (platform.isBrowser) {\n      // We inject the live element as `any` because the constructor signature cannot reference\n      // browser globals (HTMLElement) on non-browser environments, since having a class decorator\n      // causes TypeScript to preserve the constructor signature types.\n      this._liveElement = elementToken || this._createLiveElement();\n    }\n  }\n/**\n * Announces a message to screenreaders.\n * @param {?} message Message to be announced to the screenreader\n * @param {?=} politeness The politeness of the announcer element\n * @return {?}\n */\nannounce(message: string, politeness: AriaLivePoliteness = 'polite'): void {\n    this._liveElement.textContent = '';\n\n    // TODO: ensure changing the politeness works on all environments we support.\n    this._liveElement.setAttribute('aria-live', politeness);\n\n    // This 100ms timeout is necessary for some browser + screen-reader combinations:\n    // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n    // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n    //   second time without clearing and then using a non-zero delay.\n    // (using JAWS 17 at time of this writing).\n    setTimeout(() => this._liveElement.textContent = message, 100);\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    if (this._liveElement && this._liveElement.parentNode) {\n      this._liveElement.parentNode.removeChild(this._liveElement);\n    }\n  }\n/**\n * @return {?}\n */\nprivate _createLiveElement(): Element {\n    let /** @type {?} */ liveEl = document.createElement('div');\n\n    liveEl.classList.add('cdk-visually-hidden');\n    liveEl.setAttribute('aria-atomic', 'true');\n    liveEl.setAttribute('aria-live', 'polite');\n\n    document.body.appendChild(liveEl);\n\n    return liveEl;\n  }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN, ] }, ]},\n{type: Platform, },\n];\n}\n\nfunction LiveAnnouncer_tsickle_Closure_declarations() {\n/** @type {?} */\nLiveAnnouncer.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nLiveAnnouncer.ctorParameters;\n/** @type {?} */\nLiveAnnouncer.prototype._liveElement;\n}\n\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} platform\n * @return {?}\n */\nexport function LIVE_ANNOUNCER_PROVIDER_FACTORY(\n    parentDispatcher: LiveAnnouncer, liveElement: any, platform: Platform) {\n  return parentDispatcher || new LiveAnnouncer(liveElement, platform);\n}\n/**\n * \\@docs-private\n */\nexport const LIVE_ANNOUNCER_PROVIDER = {\n  // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n  provide: LiveAnnouncer,\n  deps: [\n    [new Optional(), new SkipSelf(), LiveAnnouncer],\n    [new Optional(), new Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n    Platform,\n  ],\n  useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n};\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nexport function isFakeMousedownFromScreenReader(event: MouseEvent): boolean {\n  return event.buttons === 0;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {ListKeyManager, ListKeyManagerOption} from './list-key-manager';\n\n/**\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\n * Each item must know how to style itself as active or inactive and whether or not it is\n * currently disabled.\n */\nexport interface Highlightable extends ListKeyManagerOption {\n  setActiveStyles(): void;\n  setInactiveStyles(): void;\n}\nexport class ActiveDescendantKeyManager<T> extends ListKeyManager<Highlightable & T> {\n/**\n * This method sets the active item to the item at the specified index.\n * It also adds active styles to the newly active item and removes active\n * styles from the previously active item.\n * @param {?} index\n * @return {?}\n */\nsetActiveItem(index: number): void {\n    Promise.resolve().then(() => {\n      if (this.activeItem) {\n        this.activeItem.setInactiveStyles();\n      }\n      super.setActiveItem(index);\n      if (this.activeItem) {\n        this.activeItem.setActiveStyles();\n      }\n    });\n  }\n\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {ListKeyManager, ListKeyManagerOption} from './list-key-manager';\n\n/**\n * This is the interface for focusable items (used by the FocusKeyManager).\n * Each item must know how to focus itself, whether or not it is currently disabled\n * and be able to supply it's label.\n */\nexport interface FocusableOption extends ListKeyManagerOption {\n  focus(): void;\n}\nexport class FocusKeyManager<T> extends ListKeyManager<FocusableOption & T> {\n/**\n * This method sets the active item to the item at the specified index.\n * It also adds focuses the newly active item.\n * @param {?} index\n * @return {?}\n */\nsetActiveItem(index: number): void {\n    super.setActiveItem(index);\n\n    if (this.activeItem) {\n      this.activeItem.focus();\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {NgModule} from '@angular/core';\nimport {FocusTrapDeprecatedDirective, FocusTrapDirective, FocusTrapFactory} from './focus-trap';\nimport {LIVE_ANNOUNCER_PROVIDER} from './live-announcer';\nimport {InteractivityChecker} from './interactivity-checker';\nimport {CommonModule} from '@angular/common';\nimport {PlatformModule} from '@angular/cdk/platform';\nimport {AriaDescriber, ARIA_DESCRIBER_PROVIDER} from './aria-describer';\nexport class A11yModule {static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  imports: [CommonModule, PlatformModule],\n  declarations: [FocusTrapDirective, FocusTrapDeprecatedDirective],\n  exports: [FocusTrapDirective, FocusTrapDeprecatedDirective],\n  providers: [\n    InteractivityChecker,\n    FocusTrapFactory,\n    AriaDescriber,\n    LIVE_ANNOUNCER_PROVIDER,\n    ARIA_DESCRIBER_PROVIDER\n  ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction A11yModule_tsickle_Closure_declarations() {\n/** @type {?} */\nA11yModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nA11yModule.ctorParameters;\n}\n\n\nexport {Highlightable,ActiveDescendantKeyManager} from './activedescendant-key-manager';\nexport {RegisteredMessage,MESSAGES_CONTAINER_ID,CDK_DESCRIBEDBY_ID_PREFIX,CDK_DESCRIBEDBY_HOST_ATTRIBUTE,AriaDescriber,ARIA_DESCRIBER_PROVIDER_FACTORY,ARIA_DESCRIBER_PROVIDER} from './aria-describer';\nexport {isFakeMousedownFromScreenReader} from './fake-mousedown';\nexport {FocusableOption,FocusKeyManager} from './focus-key-manager';\nexport {FocusTrap,FocusTrapFactory,FocusTrapDeprecatedDirective,FocusTrapDirective} from './focus-trap';\nexport {InteractivityChecker} from './interactivity-checker';\nexport {ListKeyManagerOption,ListKeyManager} from './list-key-manager';\nexport {LIVE_ANNOUNCER_ELEMENT_TOKEN,AriaLivePoliteness,LiveAnnouncer,LIVE_ANNOUNCER_PROVIDER_FACTORY,LIVE_ANNOUNCER_PROVIDER} from './live-announcer';\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["__extends","d","b","__","this","constructor","extendStatics","prototype","Object","create","element","offsetWidth","offsetHeight","getClientRects","length","isNativeFormElement","nodeName","toLowerCase","isHiddenInput","isInputElement","type","isAnchorWithHref","isAnchorElement","hasAttribute","hasValidTabIndex","undefined","tabIndex","isNaN","parseInt","getTabIndexValue","getAttribute","isPotentiallyTabbableIOS","inputType","getWindow","node","ownerDocument","defaultView","window","ids","push","id","trim","getAriaReferenceIds","el","attr","messagesContainer","createMessagesContainer","appendChild","messageElement","messageRegistry","set","message","referenceCount","deleteMessageElement","registeredMessage","get","document","createElement","setAttribute","MESSAGES_CONTAINER_ID","deleteMessagesContainer","originalReferenceIds","join","addAriaReferencedId","CDK_DESCRIBEDBY_HOST_ATTRIBUTE","removeAriaReferencedId","isElementDescribedByMessage","referenceIds","messageId","parentDispatcher","AriaDescriber","platform","event","buttons","setPrototypeOf","__proto__","Array","p","hasOwnProperty","InteractivityChecker","_platform","isDisabled","isVisible","hasGeometry","getComputedStyle","visibility","isTabbable","isBrowser","frameElement","frameType","BLINK","WEBKIT","tabIndexValue","TRIDENT","FIREFOX","IOS","isFocusable","isPotentiallyFocusable","decorators","Injectable","ctorParameters","Platform","FocusTrap","_element","_checker","_ngZone","deferAnchors","_enabled","attachAnchors","val","_startAnchor","_endAnchor","destroy","parentNode","removeChild","_this","_createAnchor","runOutsideAngular","addEventListener","focusLastTabbableElement","focusFirstTabbableElement","Promise","resolve","_getRegionBoundary","bound","markers","querySelectorAll","i","console","warn","_getFirstTabbableElement","_getLastTabbableElement","redirectToElement","focus","root","children","childNodes","tabbableChild","anchor","classList","add","_executeOnStable","fn","FocusTrapFactory","NgZone","_focusTrapFactory","focusTrap","_elementRef","nativeElement","enabled","coerceBooleanProperty","enumerable","configurable","FocusTrapDeprecatedDirective","ngAfterContentInit","Directive","args","ElementRef","value","FocusTrapDirective","ngOnDestroy","exportAs","LIVE_ANNOUNCER_ELEMENT_TOKEN","InjectionToken","LiveAnnouncer","politeness","_liveElement","textContent","setTimeout","liveEl","body","Optional","Inject","LIVE_ANNOUNCER_PROVIDER","provide","deps","SkipSelf","describe","hostElement","has","createMessageElement","addMessageReference","removeDescription","removeMessageReference","clear","ARIA_DESCRIBER_PROVIDER","useFactory","ARIA_DESCRIBER_PROVIDER_FACTORY","ListKeyManager","_typeaheadSubscription","Subscription","EMPTY","_pressedLetters","withWrap","_wrap","withTypeAhead","debounceInterval","RxChain","from","_letterKeyStream","call","doOperator","keyCode","items","toUpperCase","indexOf","inputString","setActiveItem","index","_activeItemIndex","_activeItem","_items","toArray","onKeydown","DOWN_ARROW","setNextItemActive","TAB","tabOut","next","key","toLocaleUpperCase","setFirstItemActive","setPreviousItemActive","_setActiveItemByDelta","updateActiveItemIndex","delta","_setActiveInWrapMode","disabled","_setActiveItemByIndex","fallbackDelta","ActiveDescendantKeyManager","_super","activeItem","setActiveStyles","FocusKeyManager"],"mappings":"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"}