/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { getNoKeysSpecifiedError } from '@angular/cdk/testing';
import { COMMA, PERIOD } from '@angular/cdk/keycodes';
import { dispatchFakeEvent, dispatchKeyboardEvent } from './dispatch-events';
import { triggerFocus } from './element-focus';
/** Input types for which the value can be entered incrementally. */
const incrementalInputTypes = new Set([
    'text',
    'email',
    'hidden',
    'password',
    'search',
    'tel',
    'url',
]);
/** Characters whose key code doesn't match their character code. */
const KEYCODE_MISMATCHES = {
    ',': COMMA,
};
/**
 * Checks whether the given Element is a text input element.
 * @docs-private
 */
export function isTextInput(element) {
    const nodeName = element.nodeName.toLowerCase();
    return nodeName === 'input' || nodeName === 'textarea';
}
export function typeInElement(element, ...modifiersAndKeys) {
    const first = modifiersAndKeys[0];
    let modifiers;
    let rest;
    if (first !== undefined &&
        typeof first !== 'string' &&
        first.keyCode === undefined &&
        first.key === undefined) {
        modifiers = first;
        rest = modifiersAndKeys.slice(1);
    }
    else {
        modifiers = {};
        rest = modifiersAndKeys;
    }
    const isInput = isTextInput(element);
    const inputType = element.getAttribute('type') || 'text';
    const keys = rest
        .map(k => typeof k === 'string'
        ? k.split('').map(c => ({
            keyCode: KEYCODE_MISMATCHES.hasOwnProperty(c)
                ? KEYCODE_MISMATCHES[c]
                : c.toUpperCase().charCodeAt(0),
            key: c,
        }))
        : [k])
        .reduce((arr, k) => arr.concat(k), []);
    // Throw an error if no keys have been specified. Calling this function with no
    // keys should not result in a focus event being dispatched unexpectedly.
    if (keys.length === 0) {
        throw getNoKeysSpecifiedError();
    }
    // We simulate the user typing in a value by incrementally assigning the value below. The problem
    // is that for some input types, the browser won't allow for an invalid value to be set via the
    // `value` property which will always be the case when going character-by-character. If we detect
    // such an input, we have to set the value all at once or listeners to the `input` event (e.g.
    // the `ReactiveFormsModule` uses such an approach) won't receive the correct value.
    const enterValueIncrementally = inputType === 'number'
        ? // The value can be set character by character in number inputs if it doesn't have any decimals.
            keys.every(key => key.key !== '.' && key.key !== '-' && key.keyCode !== PERIOD)
        : incrementalInputTypes.has(inputType);
    triggerFocus(element);
    // When we aren't entering the value incrementally, assign it all at once ahead
    // of time so that any listeners to the key events below will have access to it.
    if (!enterValueIncrementally) {
        element.value = keys.reduce((value, key) => value + (key.key || ''), '');
    }
    for (const key of keys) {
        dispatchKeyboardEvent(element, 'keydown', key.keyCode, key.key, modifiers);
        dispatchKeyboardEvent(element, 'keypress', key.keyCode, key.key, modifiers);
        if (isInput && key.key && key.key.length === 1) {
            if (enterValueIncrementally) {
                element.value += key.key;
                dispatchFakeEvent(element, 'input');
            }
        }
        dispatchKeyboardEvent(element, 'keyup', key.keyCode, key.key, modifiers);
    }
    // Since we weren't dispatching `input` events while sending the keys, we have to do it now.
    if (!enterValueIncrementally) {
        dispatchFakeEvent(element, 'input');
    }
}
/**
 * Clears the text in an input or textarea element.
 * @docs-private
 */
export function clearElement(element) {
    triggerFocus(element);
    element.value = '';
    dispatchFakeEvent(element, 'input');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS1pbi1lbGVtZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2Nkay90ZXN0aW5nL3Rlc3RiZWQvZmFrZS1ldmVudHMvdHlwZS1pbi1lbGVtZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyx1QkFBdUIsRUFBZSxNQUFNLHNCQUFzQixDQUFDO0FBQzNFLE9BQU8sRUFBQyxLQUFLLEVBQUUsTUFBTSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDcEQsT0FBTyxFQUFDLGlCQUFpQixFQUFFLHFCQUFxQixFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDM0UsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBRTdDLG9FQUFvRTtBQUNwRSxNQUFNLHFCQUFxQixHQUFHLElBQUksR0FBRyxDQUFDO0lBQ3BDLE1BQU07SUFDTixPQUFPO0lBQ1AsUUFBUTtJQUNSLFVBQVU7SUFDVixRQUFRO0lBQ1IsS0FBSztJQUNMLEtBQUs7Q0FDTixDQUFDLENBQUM7QUFFSCxvRUFBb0U7QUFDcEUsTUFBTSxrQkFBa0IsR0FBMkI7SUFDakQsR0FBRyxFQUFFLEtBQUs7Q0FDWCxDQUFDO0FBRUY7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLFdBQVcsQ0FBQyxPQUFnQjtJQUMxQyxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ2hELE9BQU8sUUFBUSxLQUFLLE9BQU8sSUFBSSxRQUFRLEtBQUssVUFBVSxDQUFDO0FBQ3pELENBQUM7QUE0QkQsTUFBTSxVQUFVLGFBQWEsQ0FBQyxPQUFvQixFQUFFLEdBQUcsZ0JBQXVCO0lBQzVFLE1BQU0sS0FBSyxHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xDLElBQUksU0FBdUIsQ0FBQztJQUM1QixJQUFJLElBQW1ELENBQUM7SUFDeEQsSUFDRSxLQUFLLEtBQUssU0FBUztRQUNuQixPQUFPLEtBQUssS0FBSyxRQUFRO1FBQ3pCLEtBQUssQ0FBQyxPQUFPLEtBQUssU0FBUztRQUMzQixLQUFLLENBQUMsR0FBRyxLQUFLLFNBQVMsRUFDdkI7UUFDQSxTQUFTLEdBQUcsS0FBSyxDQUFDO1FBQ2xCLElBQUksR0FBRyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDbEM7U0FBTTtRQUNMLFNBQVMsR0FBRyxFQUFFLENBQUM7UUFDZixJQUFJLEdBQUcsZ0JBQWdCLENBQUM7S0FDekI7SUFDRCxNQUFNLE9BQU8sR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDckMsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxNQUFNLENBQUM7SUFDekQsTUFBTSxJQUFJLEdBQXVDLElBQUk7U0FDbEQsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQ1AsT0FBTyxDQUFDLEtBQUssUUFBUTtRQUNuQixDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3BCLE9BQU8sRUFBRSxrQkFBa0IsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO2dCQUMzQyxDQUFDLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO2dCQUN2QixDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDakMsR0FBRyxFQUFFLENBQUM7U0FDUCxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDUjtTQUNBLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFFekMsK0VBQStFO0lBQy9FLHlFQUF5RTtJQUN6RSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3JCLE1BQU0sdUJBQXVCLEVBQUUsQ0FBQztLQUNqQztJQUVELGlHQUFpRztJQUNqRywrRkFBK0Y7SUFDL0YsaUdBQWlHO0lBQ2pHLDhGQUE4RjtJQUM5RixvRkFBb0Y7SUFDcEYsTUFBTSx1QkFBdUIsR0FDM0IsU0FBUyxLQUFLLFFBQVE7UUFDcEIsQ0FBQyxDQUFDLGdHQUFnRztZQUNoRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksR0FBRyxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksR0FBRyxDQUFDLE9BQU8sS0FBSyxNQUFNLENBQUM7UUFDakYsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUUzQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFdEIsK0VBQStFO0lBQy9FLGdGQUFnRjtJQUNoRixJQUFJLENBQUMsdUJBQXVCLEVBQUU7UUFDM0IsT0FBNEIsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7S0FDaEc7SUFFRCxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRTtRQUN0QixxQkFBcUIsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLEdBQUcsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztRQUMzRSxxQkFBcUIsQ0FBQyxPQUFPLEVBQUUsVUFBVSxFQUFFLEdBQUcsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztRQUM1RSxJQUFJLE9BQU8sSUFBSSxHQUFHLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUM5QyxJQUFJLHVCQUF1QixFQUFFO2dCQUMxQixPQUFrRCxDQUFDLEtBQUssSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDO2dCQUNyRSxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFDckM7U0FDRjtRQUNELHFCQUFxQixDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsR0FBRyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0tBQzFFO0lBRUQsNEZBQTRGO0lBQzVGLElBQUksQ0FBQyx1QkFBdUIsRUFBRTtRQUM1QixpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDckM7QUFDSCxDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLFlBQVksQ0FBQyxPQUErQztJQUMxRSxZQUFZLENBQUMsT0FBc0IsQ0FBQyxDQUFDO0lBQ3JDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO0lBQ25CLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztBQUN0QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7Z2V0Tm9LZXlzU3BlY2lmaWVkRXJyb3IsIE1vZGlmaWVyS2V5c30gZnJvbSAnQGFuZ3VsYXIvY2RrL3Rlc3RpbmcnO1xuaW1wb3J0IHtDT01NQSwgUEVSSU9EfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHtkaXNwYXRjaEZha2VFdmVudCwgZGlzcGF0Y2hLZXlib2FyZEV2ZW50fSBmcm9tICcuL2Rpc3BhdGNoLWV2ZW50cyc7XG5pbXBvcnQge3RyaWdnZXJGb2N1c30gZnJvbSAnLi9lbGVtZW50LWZvY3VzJztcblxuLyoqIElucHV0IHR5cGVzIGZvciB3aGljaCB0aGUgdmFsdWUgY2FuIGJlIGVudGVyZWQgaW5jcmVtZW50YWxseS4gKi9cbmNvbnN0IGluY3JlbWVudGFsSW5wdXRUeXBlcyA9IG5ldyBTZXQoW1xuICAndGV4dCcsXG4gICdlbWFpbCcsXG4gICdoaWRkZW4nLFxuICAncGFzc3dvcmQnLFxuICAnc2VhcmNoJyxcbiAgJ3RlbCcsXG4gICd1cmwnLFxuXSk7XG5cbi8qKiBDaGFyYWN0ZXJzIHdob3NlIGtleSBjb2RlIGRvZXNuJ3QgbWF0Y2ggdGhlaXIgY2hhcmFjdGVyIGNvZGUuICovXG5jb25zdCBLRVlDT0RFX01JU01BVENIRVM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gICcsJzogQ09NTUEsXG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBFbGVtZW50IGlzIGEgdGV4dCBpbnB1dCBlbGVtZW50LlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUZXh0SW5wdXQoZWxlbWVudDogRWxlbWVudCk6IGVsZW1lbnQgaXMgSFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnQge1xuICBjb25zdCBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnaW5wdXQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnO1xufVxuXG4vKipcbiAqIElmIGtleXMgaGF2ZSBiZWVuIHNwZWNpZmllZCwgZm9jdXNlcyBhbiBpbnB1dCwgc2V0cyBpdHMgdmFsdWUgYW5kIGRpc3BhdGNoZXNcbiAqIHRoZSBgaW5wdXRgIGV2ZW50LCBzaW11bGF0aW5nIHRoZSB1c2VyIHR5cGluZy5cbiAqIEBwYXJhbSBlbGVtZW50IEVsZW1lbnQgb250byB3aGljaCB0byBzZXQgdGhlIHZhbHVlLlxuICogQHBhcmFtIGtleXMgVGhlIGtleXMgdG8gc2VuZCB0byB0aGUgZWxlbWVudC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR5cGVJbkVsZW1lbnQoXG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50LFxuICAuLi5rZXlzOiAoc3RyaW5nIHwge2tleUNvZGU/OiBudW1iZXI7IGtleT86IHN0cmluZ30pW11cbik6IHZvaWQ7XG5cbi8qKlxuICogSWYga2V5cyBoYXZlIGJlZW4gc3BlY2lmaWVkLCBmb2N1c2VzIGFuIGlucHV0LCBzZXRzIGl0cyB2YWx1ZSBhbmQgZGlzcGF0Y2hlc1xuICogdGhlIGBpbnB1dGAgZXZlbnQsIHNpbXVsYXRpbmcgdGhlIHVzZXIgdHlwaW5nLlxuICogQHBhcmFtIGVsZW1lbnQgRWxlbWVudCBvbnRvIHdoaWNoIHRvIHNldCB0aGUgdmFsdWUuXG4gKiBAcGFyYW0gbW9kaWZpZXJzIE1vZGlmaWVyIGtleXMgdGhhdCBhcmUgaGVsZCB3aGlsZSB0eXBpbmcuXG4gKiBAcGFyYW0ga2V5cyBUaGUga2V5cyB0byBzZW5kIHRvIHRoZSBlbGVtZW50LlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHlwZUluRWxlbWVudChcbiAgZWxlbWVudDogSFRNTEVsZW1lbnQsXG4gIG1vZGlmaWVyczogTW9kaWZpZXJLZXlzLFxuICAuLi5rZXlzOiAoc3RyaW5nIHwge2tleUNvZGU/OiBudW1iZXI7IGtleT86IHN0cmluZ30pW11cbik6IHZvaWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlSW5FbGVtZW50KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCAuLi5tb2RpZmllcnNBbmRLZXlzOiBhbnlbXSkge1xuICBjb25zdCBmaXJzdCA9IG1vZGlmaWVyc0FuZEtleXNbMF07XG4gIGxldCBtb2RpZmllcnM6IE1vZGlmaWVyS2V5cztcbiAgbGV0IHJlc3Q6IChzdHJpbmcgfCB7a2V5Q29kZT86IG51bWJlcjsga2V5Pzogc3RyaW5nfSlbXTtcbiAgaWYgKFxuICAgIGZpcnN0ICE9PSB1bmRlZmluZWQgJiZcbiAgICB0eXBlb2YgZmlyc3QgIT09ICdzdHJpbmcnICYmXG4gICAgZmlyc3Qua2V5Q29kZSA9PT0gdW5kZWZpbmVkICYmXG4gICAgZmlyc3Qua2V5ID09PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgbW9kaWZpZXJzID0gZmlyc3Q7XG4gICAgcmVzdCA9IG1vZGlmaWVyc0FuZEtleXMuc2xpY2UoMSk7XG4gIH0gZWxzZSB7XG4gICAgbW9kaWZpZXJzID0ge307XG4gICAgcmVzdCA9IG1vZGlmaWVyc0FuZEtleXM7XG4gIH1cbiAgY29uc3QgaXNJbnB1dCA9IGlzVGV4dElucHV0KGVsZW1lbnQpO1xuICBjb25zdCBpbnB1dFR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpIHx8ICd0ZXh0JztcbiAgY29uc3Qga2V5czoge2tleUNvZGU/OiBudW1iZXI7IGtleT86IHN0cmluZ31bXSA9IHJlc3RcbiAgICAubWFwKGsgPT5cbiAgICAgIHR5cGVvZiBrID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGsuc3BsaXQoJycpLm1hcChjID0+ICh7XG4gICAgICAgICAgICBrZXlDb2RlOiBLRVlDT0RFX01JU01BVENIRVMuaGFzT3duUHJvcGVydHkoYylcbiAgICAgICAgICAgICAgPyBLRVlDT0RFX01JU01BVENIRVNbY11cbiAgICAgICAgICAgICAgOiBjLnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICAgIGtleTogYyxcbiAgICAgICAgICB9KSlcbiAgICAgICAgOiBba10sXG4gICAgKVxuICAgIC5yZWR1Y2UoKGFyciwgaykgPT4gYXJyLmNvbmNhdChrKSwgW10pO1xuXG4gIC8vIFRocm93IGFuIGVycm9yIGlmIG5vIGtleXMgaGF2ZSBiZWVuIHNwZWNpZmllZC4gQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIHdpdGggbm9cbiAgLy8ga2V5cyBzaG91bGQgbm90IHJlc3VsdCBpbiBhIGZvY3VzIGV2ZW50IGJlaW5nIGRpc3BhdGNoZWQgdW5leHBlY3RlZGx5LlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBnZXROb0tleXNTcGVjaWZpZWRFcnJvcigpO1xuICB9XG5cbiAgLy8gV2Ugc2ltdWxhdGUgdGhlIHVzZXIgdHlwaW5nIGluIGEgdmFsdWUgYnkgaW5jcmVtZW50YWxseSBhc3NpZ25pbmcgdGhlIHZhbHVlIGJlbG93LiBUaGUgcHJvYmxlbVxuICAvLyBpcyB0aGF0IGZvciBzb21lIGlucHV0IHR5cGVzLCB0aGUgYnJvd3NlciB3b24ndCBhbGxvdyBmb3IgYW4gaW52YWxpZCB2YWx1ZSB0byBiZSBzZXQgdmlhIHRoZVxuICAvLyBgdmFsdWVgIHByb3BlcnR5IHdoaWNoIHdpbGwgYWx3YXlzIGJlIHRoZSBjYXNlIHdoZW4gZ29pbmcgY2hhcmFjdGVyLWJ5LWNoYXJhY3Rlci4gSWYgd2UgZGV0ZWN0XG4gIC8vIHN1Y2ggYW4gaW5wdXQsIHdlIGhhdmUgdG8gc2V0IHRoZSB2YWx1ZSBhbGwgYXQgb25jZSBvciBsaXN0ZW5lcnMgdG8gdGhlIGBpbnB1dGAgZXZlbnQgKGUuZy5cbiAgLy8gdGhlIGBSZWFjdGl2ZUZvcm1zTW9kdWxlYCB1c2VzIHN1Y2ggYW4gYXBwcm9hY2gpIHdvbid0IHJlY2VpdmUgdGhlIGNvcnJlY3QgdmFsdWUuXG4gIGNvbnN0IGVudGVyVmFsdWVJbmNyZW1lbnRhbGx5ID1cbiAgICBpbnB1dFR5cGUgPT09ICdudW1iZXInXG4gICAgICA/IC8vIFRoZSB2YWx1ZSBjYW4gYmUgc2V0IGNoYXJhY3RlciBieSBjaGFyYWN0ZXIgaW4gbnVtYmVyIGlucHV0cyBpZiBpdCBkb2Vzbid0IGhhdmUgYW55IGRlY2ltYWxzLlxuICAgICAgICBrZXlzLmV2ZXJ5KGtleSA9PiBrZXkua2V5ICE9PSAnLicgJiYga2V5LmtleSAhPT0gJy0nICYmIGtleS5rZXlDb2RlICE9PSBQRVJJT0QpXG4gICAgICA6IGluY3JlbWVudGFsSW5wdXRUeXBlcy5oYXMoaW5wdXRUeXBlKTtcblxuICB0cmlnZ2VyRm9jdXMoZWxlbWVudCk7XG5cbiAgLy8gV2hlbiB3ZSBhcmVuJ3QgZW50ZXJpbmcgdGhlIHZhbHVlIGluY3JlbWVudGFsbHksIGFzc2lnbiBpdCBhbGwgYXQgb25jZSBhaGVhZFxuICAvLyBvZiB0aW1lIHNvIHRoYXQgYW55IGxpc3RlbmVycyB0byB0aGUga2V5IGV2ZW50cyBiZWxvdyB3aWxsIGhhdmUgYWNjZXNzIHRvIGl0LlxuICBpZiAoIWVudGVyVmFsdWVJbmNyZW1lbnRhbGx5KSB7XG4gICAgKGVsZW1lbnQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPSBrZXlzLnJlZHVjZSgodmFsdWUsIGtleSkgPT4gdmFsdWUgKyAoa2V5LmtleSB8fCAnJyksICcnKTtcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBkaXNwYXRjaEtleWJvYXJkRXZlbnQoZWxlbWVudCwgJ2tleWRvd24nLCBrZXkua2V5Q29kZSwga2V5LmtleSwgbW9kaWZpZXJzKTtcbiAgICBkaXNwYXRjaEtleWJvYXJkRXZlbnQoZWxlbWVudCwgJ2tleXByZXNzJywga2V5LmtleUNvZGUsIGtleS5rZXksIG1vZGlmaWVycyk7XG4gICAgaWYgKGlzSW5wdXQgJiYga2V5LmtleSAmJiBrZXkua2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKGVudGVyVmFsdWVJbmNyZW1lbnRhbGx5KSB7XG4gICAgICAgIChlbGVtZW50IGFzIEhUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50KS52YWx1ZSArPSBrZXkua2V5O1xuICAgICAgICBkaXNwYXRjaEZha2VFdmVudChlbGVtZW50LCAnaW5wdXQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGlzcGF0Y2hLZXlib2FyZEV2ZW50KGVsZW1lbnQsICdrZXl1cCcsIGtleS5rZXlDb2RlLCBrZXkua2V5LCBtb2RpZmllcnMpO1xuICB9XG5cbiAgLy8gU2luY2Ugd2Ugd2VyZW4ndCBkaXNwYXRjaGluZyBgaW5wdXRgIGV2ZW50cyB3aGlsZSBzZW5kaW5nIHRoZSBrZXlzLCB3ZSBoYXZlIHRvIGRvIGl0IG5vdy5cbiAgaWYgKCFlbnRlclZhbHVlSW5jcmVtZW50YWxseSkge1xuICAgIGRpc3BhdGNoRmFrZUV2ZW50KGVsZW1lbnQsICdpbnB1dCcpO1xuICB9XG59XG5cbi8qKlxuICogQ2xlYXJzIHRoZSB0ZXh0IGluIGFuIGlucHV0IG9yIHRleHRhcmVhIGVsZW1lbnQuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckVsZW1lbnQoZWxlbWVudDogSFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnQpIHtcbiAgdHJpZ2dlckZvY3VzKGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xuICBlbGVtZW50LnZhbHVlID0gJyc7XG4gIGRpc3BhdGNoRmFrZUV2ZW50KGVsZW1lbnQsICdpbnB1dCcpO1xufVxuIl19